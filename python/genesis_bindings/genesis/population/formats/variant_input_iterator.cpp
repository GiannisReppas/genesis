#include <array>
#include <functional>
#include <genesis/population/formats/frequency_table_input_iterator.hpp>
#include <genesis/population/formats/simple_pileup_reader.hpp>
#include <genesis/population/formats/variant_input_iterator.hpp>
#include <genesis/population/variant.hpp>
#include <genesis/sequence/functions/quality.hpp>
#include <genesis/sequence/reference_genome.hpp>
#include <genesis/utils/containers/lambda_iterator.hpp>
#include <genesis/utils/core/thread_pool.hpp>
#include <genesis/utils/io/base_input_source.hpp>
#include <genesis/utils/io/input_stream.hpp>
#include <iterator>
#include <memory>
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/utils/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/utils/bitvector.hpp>
#include <../python/custom_bindings/extensions/utils/range.hpp>
#include <../python/custom_bindings/extensions/string_target.hpp>
#include <../python/custom_bindings/extensions/sequence/quality.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/reference_genome.hpp>
#include <../python/custom_bindings/extensions/taxonomy/taxopath.hpp>
#include <../python/custom_bindings/extensions/taxonomy/iterator.hpp>
#include <../python/custom_bindings/extensions/tree/tree.hpp>
#include <../python/custom_bindings/extensions/tree/functions_tree.hpp>
#include <genesis/population/genome_region_list.hpp>
#include <../python/custom_bindings/extensions/population/chromosome_iterator.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_population_formats_variant_input_iterator(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// genesis::population::make_variant_input_iterator_from_vector(const class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> > &) file:genesis/population/formats/variant_input_iterator.hpp line:148
	M("genesis::population").def("make_variant_input_iterator_from_vector", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> > &)) &genesis::population::make_variant_input_iterator_from_vector, "Create a VariantInputIterator to iterate the contents of `std::vector` containing Variant%s.\n\n This is a simple wrapper to bring a vector of in-memory Variant%s into the input iterator\n format that we use for file streaming as well. Meant as a speed-up for small files that fit into\n memory, in cases where they for example have to processed multiple times.\n\n The user needs to make sure that the lifetime of the given input  vector is longer\n than the iterator returned here, and that the vector is not modified after calling this function.\n\nC++: genesis::population::make_variant_input_iterator_from_vector(const class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> > &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("variants"));

	// genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class genesis::population::SimplePileupReader &) file:genesis/population/formats/variant_input_iterator.hpp line:189
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", [](const std::string & a0) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_pileup_file(a0); }, "", pybind11::arg("filename"));
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class genesis::population::SimplePileupReader &)) &genesis::population::make_variant_input_iterator_from_pileup_file, "Create a VariantInputIterator to iterate the contents of a (m)pileup file as Variant%s.\n\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class genesis::population::SimplePileupReader &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("reader"));

	// genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool, const class genesis::population::SimplePileupReader &) file:genesis/population/formats/variant_input_iterator.hpp line:207
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", [](const std::string & a0, const class std::vector<unsigned long, class std::allocator<unsigned long> > & a1) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_pileup_file(a0, a1); }, "", pybind11::arg("filename"), pybind11::arg("sample_indices"));
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", [](const std::string & a0, const class std::vector<unsigned long, class std::allocator<unsigned long> > & a1, bool const & a2) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_pileup_file(a0, a1, a2); }, "", pybind11::arg("filename"), pybind11::arg("sample_indices"), pybind11::arg("inverse_sample_indices"));
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool, const class genesis::population::SimplePileupReader &)) &genesis::population::make_variant_input_iterator_from_pileup_file, "Create a VariantInputIterator to iterate the contents of a (m)pileup file as Variant%s.\n\n This uses only the samples at the zero-based indices given in the  list.\n If  is `true`, this list is inversed, that is, all sample indices _but_\n the ones listed are included in the output.\n\n For example, given a list `{ 0, 2 }` and a file with 4 samples, only the first and the third\n sample will be in the output. When however  is also set, then the output\n will contain the second and fourth sample.\n\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool, const class genesis::population::SimplePileupReader &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("sample_indices"), pybind11::arg("inverse_sample_indices"), pybind11::arg("reader"));

	// genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SimplePileupReader &) file:genesis/population/formats/variant_input_iterator.hpp line:220
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", [](const std::string & a0, const class std::vector<bool, class std::allocator<bool> > & a1) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_pileup_file(a0, a1); }, "", pybind11::arg("filename"), pybind11::arg("sample_filter"));
	M("genesis::population").def("make_variant_input_iterator_from_pileup_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SimplePileupReader &)) &genesis::population::make_variant_input_iterator_from_pileup_file, "Create a VariantInputIterator to iterate the contents of a (m)pileup file as Variant%s.\n\n This uses only the samples at the indices where the  is `true`.\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_pileup_file(const std::string &, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SimplePileupReader &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("sample_filter"), pybind11::arg("reader"));

	// genesis::population::make_variant_input_iterator_from_sync_file(const std::string &) file:genesis/population/formats/variant_input_iterator.hpp line:234
	M("genesis::population").def("make_variant_input_iterator_from_sync_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &)) &genesis::population::make_variant_input_iterator_from_sync_file, "Create a VariantInputIterator to iterate the contents of a PoPoolation2 sync file\n as Variant%s.\n\nC++: genesis::population::make_variant_input_iterator_from_sync_file(const std::string &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"));

	// genesis::population::make_variant_input_iterator_from_sync_file(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool) file:genesis/population/formats/variant_input_iterator.hpp line:250
	M("genesis::population").def("make_variant_input_iterator_from_sync_file", [](const std::string & a0, const class std::vector<unsigned long, class std::allocator<unsigned long> > & a1) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_sync_file(a0, a1); }, "", pybind11::arg("filename"), pybind11::arg("sample_indices"));
	M("genesis::population").def("make_variant_input_iterator_from_sync_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool)) &genesis::population::make_variant_input_iterator_from_sync_file, "Create a VariantInputIterator to iterate the contents of a PoPoolation2 sync file\n as Variant%s.\n\n This uses only the samples at the zero-based indices given in the  list.\n If  is `true`, this list is inversed, that is, all sample indices _but_\n the ones listed are included in the output.\n\n For example, given a list `{ 0, 2 }` and a file with 4 samples, only the first and the third\n sample will be in the output. When however  is also set, then the output\n will contain the second and fourth sample.\n\nC++: genesis::population::make_variant_input_iterator_from_sync_file(const std::string &, const class std::vector<unsigned long, class std::allocator<unsigned long> > &, bool) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("sample_indices"), pybind11::arg("inverse_sample_indices"));

	// genesis::population::make_variant_input_iterator_from_sync_file(const std::string &, const class std::vector<bool, class std::allocator<bool> > &) file:genesis/population/formats/variant_input_iterator.hpp line:263
	M("genesis::population").def("make_variant_input_iterator_from_sync_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class std::vector<bool, class std::allocator<bool> > &)) &genesis::population::make_variant_input_iterator_from_sync_file, "Create a VariantInputIterator to iterate the contents of a PoPoolation2 sync file\n as Variant%s.\n\n This uses only the samples at the indices where the  is `true`.\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_sync_file(const std::string &, const class std::vector<bool, class std::allocator<bool> > &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("sample_filter"));

	// genesis::population::make_variant_input_iterator_from_frequency_table_file(const std::string &, char, const class genesis::population::FrequencyTableInputIterator &) file:genesis/population/formats/variant_input_iterator.hpp line:278
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", [](const std::string & a0) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_frequency_table_file(a0); }, "", pybind11::arg("filename"));
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", [](const std::string & a0, char const & a1) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_frequency_table_file(a0, a1); }, "", pybind11::arg("filename"), pybind11::arg("separator_char"));
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, char, const class genesis::population::FrequencyTableInputIterator &)) &genesis::population::make_variant_input_iterator_from_frequency_table_file, "Create a VariantInputIterator to iterate the contents of a frequency table file as\n Variant%s.\n\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_frequency_table_file(const std::string &, char, const class genesis::population::FrequencyTableInputIterator &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("separator_char"), pybind11::arg("reader"));

	// genesis::population::make_variant_input_iterator_from_frequency_table_file(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &, bool, char, const class genesis::population::FrequencyTableInputIterator &) file:genesis/population/formats/variant_input_iterator.hpp line:294
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", [](const std::string & a0, const class std::vector<std::string, class std::allocator<std::string > > & a1) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_frequency_table_file(a0, a1); }, "", pybind11::arg("filename"), pybind11::arg("sample_names_filter"));
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", [](const std::string & a0, const class std::vector<std::string, class std::allocator<std::string > > & a1, bool const & a2) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_frequency_table_file(a0, a1, a2); }, "", pybind11::arg("filename"), pybind11::arg("sample_names_filter"), pybind11::arg("inverse_sample_names_filter"));
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", [](const std::string & a0, const class std::vector<std::string, class std::allocator<std::string > > & a1, bool const & a2, char const & a3) -> genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> { return genesis::population::make_variant_input_iterator_from_frequency_table_file(a0, a1, a2, a3); }, "", pybind11::arg("filename"), pybind11::arg("sample_names_filter"), pybind11::arg("inverse_sample_names_filter"), pybind11::arg("separator_char"));
	M("genesis::population").def("make_variant_input_iterator_from_frequency_table_file", (class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData> (*)(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &, bool, char, const class genesis::population::FrequencyTableInputIterator &)) &genesis::population::make_variant_input_iterator_from_frequency_table_file, "Create a VariantInputIterator to iterate the contents of a frequency table file as\n Variant%s.\n\n Additionally, this version of the function takes a list of  which are used as\n filter so that only those samples (columns of the frequency table) are evaluated and accessible -\n or, if  is set to `true`, instead all but those samples.\n\n Optionally, this takes a  with settings to be used.\n\nC++: genesis::population::make_variant_input_iterator_from_frequency_table_file(const std::string &, const class std::vector<std::string, class std::allocator<std::string > > &, bool, char, const class genesis::population::FrequencyTableInputIterator &) --> class genesis::utils::LambdaIterator<struct genesis::population::Variant, struct genesis::population::VariantInputIteratorData>", pybind11::arg("filename"), pybind11::arg("sample_names_filter"), pybind11::arg("inverse_sample_names_filter"), pybind11::arg("separator_char"), pybind11::arg("reader"));

}
