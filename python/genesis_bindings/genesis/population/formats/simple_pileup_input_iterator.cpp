#include <array>
#include <functional>
#include <genesis/population/formats/frequency_table_input_iterator.hpp>
#include <genesis/population/formats/simple_pileup_input_iterator.hpp>
#include <genesis/population/formats/simple_pileup_reader.hpp>
#include <genesis/population/variant.hpp>
#include <genesis/sequence/functions/quality.hpp>
#include <genesis/sequence/reference_genome.hpp>
#include <genesis/utils/io/base_input_source.hpp>
#include <genesis/utils/io/input_stream.hpp>
#include <iterator>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <unordered_map>
#include <unordered_set>
#include <utility>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/utils/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/utils/bitvector.hpp>
#include <../python/custom_bindings/extensions/utils/range.hpp>
#include <../python/custom_bindings/extensions/to_string.hpp>
#include <../python/custom_bindings/extensions/sequence/quality.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_output_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/reference_genome.hpp>
#include <../python/custom_bindings/extensions/taxonomy/taxopath.hpp>
#include <../python/custom_bindings/extensions/taxonomy/iterator.hpp>
#include <../python/custom_bindings/extensions/tree/tree.hpp>
#include <../python/custom_bindings/extensions/tree/functions_tree.hpp>
#include <genesis/population/genome_region_list.hpp>
#include <../python/custom_bindings/extensions/population/chromosome_iterator.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_population_formats_simple_pileup_input_iterator(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // genesis::population::SimplePileupInputIterator file:genesis/population/formats/simple_pileup_input_iterator.hpp line:79
		pybind11::class_<genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>, std::shared_ptr<genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>>> cl(M("genesis::population"), "SimplePileupInputIterator_genesis_population_SimplePileupReader_Record_t", "");
		cl.def( pybind11::init( [](){ return new genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>(); } ) );
		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0){ return new genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>(a0); } ), "doc" , pybind11::arg("source"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class genesis::population::SimplePileupReader &>(), pybind11::arg("source"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0, const class std::vector<bool, class std::allocator<bool> > & a1){ return new genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>(a0, a1); } ), "doc" , pybind11::arg("source"), pybind11::arg("sample_filter"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SimplePileupReader &>(), pybind11::arg("source"), pybind11::arg("sample_filter"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record> const &o){ return new genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>(o); } ) );
		cl.def("assign", (class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &)) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator=, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator=(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &) --> class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("good", (bool (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)() const) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::good, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::good() const --> bool");
		cl.def("reader", (const class genesis::population::SimplePileupReader & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)() const) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::reader, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::reader() const --> const class genesis::population::SimplePileupReader &", pybind11::return_value_policy::reference_internal);
		cl.def("record", (struct genesis::population::SimplePileupReader::Record & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::record, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::record() --> struct genesis::population::SimplePileupReader::Record &", pybind11::return_value_policy::reference_internal);
		cl.def("arrow", (struct genesis::population::SimplePileupReader::Record * (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator->, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator->() --> struct genesis::population::SimplePileupReader::Record *", pybind11::return_value_policy::reference_internal);
		cl.def("dereference", (struct genesis::population::SimplePileupReader::Record & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator*, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator*() --> struct genesis::population::SimplePileupReader::Record &", pybind11::return_value_policy::reference_internal);
		cl.def("pre_increment", (class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator++, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator++() --> class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &", pybind11::return_value_policy::reference_internal);
		cl.def("post_increment", (class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> & (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)(int)) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator++, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator++(int) --> class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("increment", (void (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::increment, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::increment() --> void");
		cl.def("__eq__", (bool (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &) const) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator==, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator==(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &) const --> bool", pybind11::arg("it"));
		cl.def("__ne__", (bool (genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &) const) &genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator!=, "C++: genesis::population::SimplePileupInputIterator<genesis::population::SimplePileupReader::Record>::operator!=(const class genesis::population::SimplePileupInputIterator<struct genesis::population::SimplePileupReader::Record> &) const --> bool", pybind11::arg("it"));
	}
	{ // genesis::population::SimplePileupInputIterator file:genesis/population/formats/simple_pileup_input_iterator.hpp line:79
		pybind11::class_<genesis::population::SimplePileupInputIterator<genesis::population::Variant>, std::shared_ptr<genesis::population::SimplePileupInputIterator<genesis::population::Variant>>> cl(M("genesis::population"), "SimplePileupInputIterator_genesis_population_Variant_t", "");
		cl.def( pybind11::init( [](){ return new genesis::population::SimplePileupInputIterator<genesis::population::Variant>(); } ) );
		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0){ return new genesis::population::SimplePileupInputIterator<genesis::population::Variant>(a0); } ), "doc" , pybind11::arg("source"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class genesis::population::SimplePileupReader &>(), pybind11::arg("source"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0, const class std::vector<bool, class std::allocator<bool> > & a1){ return new genesis::population::SimplePileupInputIterator<genesis::population::Variant>(a0, a1); } ), "doc" , pybind11::arg("source"), pybind11::arg("sample_filter"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SimplePileupReader &>(), pybind11::arg("source"), pybind11::arg("sample_filter"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](genesis::population::SimplePileupInputIterator<genesis::population::Variant> const &o){ return new genesis::population::SimplePileupInputIterator<genesis::population::Variant>(o); } ) );
		cl.def("assign", (class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &)) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator=, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator=(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &) --> class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("good", (bool (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)() const) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::good, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::good() const --> bool");
		cl.def("reader", (const class genesis::population::SimplePileupReader & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)() const) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::reader, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::reader() const --> const class genesis::population::SimplePileupReader &", pybind11::return_value_policy::reference_internal);
		cl.def("record", (struct genesis::population::Variant & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::record, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::record() --> struct genesis::population::Variant &", pybind11::return_value_policy::reference_internal);
		cl.def("arrow", (struct genesis::population::Variant * (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator->, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator->() --> struct genesis::population::Variant *", pybind11::return_value_policy::reference_internal);
		cl.def("dereference", (struct genesis::population::Variant & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator*, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator*() --> struct genesis::population::Variant &", pybind11::return_value_policy::reference_internal);
		cl.def("pre_increment", (class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator++, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator++() --> class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &", pybind11::return_value_policy::reference_internal);
		cl.def("post_increment", (class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> & (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)(int)) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator++, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator++(int) --> class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("increment", (void (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)()) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::increment, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::increment() --> void");
		cl.def("__eq__", (bool (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &) const) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator==, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator==(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &) const --> bool", pybind11::arg("it"));
		cl.def("__ne__", (bool (genesis::population::SimplePileupInputIterator<genesis::population::Variant>::*)(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &) const) &genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator!=, "C++: genesis::population::SimplePileupInputIterator<genesis::population::Variant>::operator!=(const class genesis::population::SimplePileupInputIterator<struct genesis::population::Variant> &) const --> bool", pybind11::arg("it"));
	}
	{ // genesis::population::FrequencyTableInputIterator file:genesis/population/formats/frequency_table_input_iterator.hpp line:79
		pybind11::class_<genesis::population::FrequencyTableInputIterator, std::shared_ptr<genesis::population::FrequencyTableInputIterator>> cl(M("genesis::population"), "FrequencyTableInputIterator", "Iterate an input source and parse it as a table of allele frequencies or counts.\n\n The expected table has to be in what R calls the \"wide\" format, that is, samples are in separate\n columns. This is because otherwise, the amount of data duplication for the fixed columns\n such as chromosome name and position would just be too much waste.\n\n The parser will automatically try to determine which samples contain which types of data\n (reference and alternative counts, frequencies, coverage), and compute whatever needed from that.\n\n Some formats do not contain information on the reference and/or alternative base, such as the\n HAF-pipe frequency tables. For these cases, a reference_genome() can be provided, which will\n at least set the reference base of the Variant correctly. The alternative base will then be\n set to the transition base of the reference (A <-> G and C <-> T), which might be wrong, but is\n the most likely that we can do in the absence of further information. We might add using a\n reference panel VCF in the future to solve this problem, but as most of our downstream algorithms\n do not really care about which base is ref and alt, we don't support this as of now.\n\n If there is no ref base column (or if it is `N`) or ref genome given, we cannot know to which\n bases the counts correspond to. In that case, we assign the ref count to `A`, and the alt count\n to `G`, respectively. If only the ref base is given, but no alt base, we again use the transition\n base, as explained above.");
		cl.def( pybind11::init( [](){ return new genesis::population::FrequencyTableInputIterator(); } ) );
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>>(), pybind11::arg("input_source") );

		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0, const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > & a1){ return new genesis::population::FrequencyTableInputIterator(a0, a1); } ), "doc" , pybind11::arg("input_source"), pybind11::arg("sample_names_filter"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > &, bool>(), pybind11::arg("input_source"), pybind11::arg("sample_names_filter"), pybind11::arg("inverse_sample_names_filter") );

		cl.def( pybind11::init( [](genesis::population::FrequencyTableInputIterator const &o){ return new genesis::population::FrequencyTableInputIterator(o); } ) );
		cl.def("assign", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const class genesis::population::FrequencyTableInputIterator &)) &genesis::population::FrequencyTableInputIterator::operator=, "C++: genesis::population::FrequencyTableInputIterator::operator=(const class genesis::population::FrequencyTableInputIterator &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("begin", (class genesis::population::FrequencyTableInputIterator::Iterator (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::begin, "C++: genesis::population::FrequencyTableInputIterator::begin() const --> class genesis::population::FrequencyTableInputIterator::Iterator");
		cl.def("end", (class genesis::population::FrequencyTableInputIterator::Iterator (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::end, "C++: genesis::population::FrequencyTableInputIterator::end() const --> class genesis::population::FrequencyTableInputIterator::Iterator");
		cl.def("input_source", (class std::shared_ptr<class genesis::utils::BaseInputSource> (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::input_source, "C++: genesis::population::FrequencyTableInputIterator::input_source() const --> class std::shared_ptr<class genesis::utils::BaseInputSource>");
		cl.def("input_source", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(class std::shared_ptr<class genesis::utils::BaseInputSource>)) &genesis::population::FrequencyTableInputIterator::input_source, "Set the input source.\n\n This overwrites the source if it was already given in the constructor.\n Shall not be called after iteration has been started.\n\nC++: genesis::population::FrequencyTableInputIterator::input_source(class std::shared_ptr<class genesis::utils::BaseInputSource>) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("sample_names_filter", (const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::sample_names_filter, "C++: genesis::population::FrequencyTableInputIterator::sample_names_filter() const --> const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > &", pybind11::return_value_policy::reference_internal);
		cl.def("sample_names_filter", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > &)) &genesis::population::FrequencyTableInputIterator::sample_names_filter, "Set the sample names to filter for.\n\n This overwrites the sample names if the were already given in the constructor.\n We internally sort them, for faster access.\n Shall not be called after iteration has been started.\n\nC++: genesis::population::FrequencyTableInputIterator::sample_names_filter(const class std::unordered_set<std::string, struct std::hash<std::string>, struct std::equal_to<std::string >, class std::allocator<std::string > > &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("inverse_sample_names_filter", (bool (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::inverse_sample_names_filter, "C++: genesis::population::FrequencyTableInputIterator::inverse_sample_names_filter() const --> bool");
		cl.def("inverse_sample_names_filter", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(bool)) &genesis::population::FrequencyTableInputIterator::inverse_sample_names_filter, "Set whether to reverse the sample names to filter for.\n\n This overwrites the sample names reverse setting if the were already given in the constructor.\n Shall not be called after iteration has been started.\n\nC++: genesis::population::FrequencyTableInputIterator::inverse_sample_names_filter(bool) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("header_chromosome_string", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_chromosome_string, "Specify a string that marks the chromosome column in the header.\n\n By default, this string is empty, and instead we search for the chromosome column\n in the header by matching with a list of commonly used strings, such as\n `chromosome`, `chr`, or `contig`.\n\n However, if set to a non-empty string, this string is searched instead in the header, and\n the respective column is used for the chromosome information when parsing the table.\n\nC++: genesis::population::FrequencyTableInputIterator::header_chromosome_string(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_chromosome_string", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_chromosome_string, "Return the currently set string that marks the chromosome columnn in the header.\n\n See the setter header_chromosome_string( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_chromosome_string() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_position_string", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_position_string, "Specify a string that marks the position column in the header.\n\n See the setter header_chromosome_string( std::string const& ) for details;\n this setter here however specifies the column for the position within a given chromosome.\n\nC++: genesis::population::FrequencyTableInputIterator::header_position_string(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_position_string", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_position_string, "Return the currently set string that marks the position columnn in the header.\n\n See the setter header_position_string( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_position_string() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_reference_base_string", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_reference_base_string, "Specify a string that marks the reference base column in the header.\n\n See the setter header_chromosome_string( std::string const& ) for details;\n this setter here however specifies the column for the reference base.\n\nC++: genesis::population::FrequencyTableInputIterator::header_reference_base_string(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_reference_base_string", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_reference_base_string, "Return the currently set string that marks the reference base columnn in the header.\n\n See the setter header_reference_base_string( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_reference_base_string() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_alternative_base_string", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_alternative_base_string, "Specify a string that marks the alternative base column in the header.\n\n See the setter header_chromosome_string( std::string const& ) for details;\n this setter here however specifies the column for the alternative base.\n\nC++: genesis::population::FrequencyTableInputIterator::header_alternative_base_string(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_alternative_base_string", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_alternative_base_string, "Return the currently set string that marks the alternative base columnn in the header.\n\n See the setter header_alternative_base_string( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_alternative_base_string() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_sample_reference_count_substring", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_sample_reference_count_substring, "Specify a (sub)string that is the prefix or suffix\n for header columns containing the reference base count of a sample.\n\n By default, this string is empty, and instead we search for the reference base count columns\n of samples in the header by matching with a list of commonly used prefixes and suffixes,\n such as `ref_cnt` or `reference-base-count`.\n\n However, if set to a non-empty string, this string is searched instead in the header\n as a prefix or suffix, and for every match, the respective column is used as the reference\n base count information of a sample when parsing the table. The sample name is then the\n remainder of the column name that is left without the prefix or suffix.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_reference_count_substring(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_sample_reference_count_substring", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_sample_reference_count_substring, "Return the currently set (sub)string that is the prefix or suffix\n for header columns containing the reference base count of a sample.\n\n See the setter header_sample_reference_count_substring( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_reference_count_substring() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_sample_alternative_count_substring", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_sample_alternative_count_substring, "Specify a (sub)string that is the prefix or suffix\n for header columns containing the alternative base count of a sample.\n\n See the setter header_sample_reference_count_substring( std::string const& ) for details;\n this setter here however specifies the prefix or suffix for columns containing\n the alternative base count of samples.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_alternative_count_substring(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_sample_alternative_count_substring", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_sample_alternative_count_substring, "Return the currently set (sub)string that is the prefix or suffix\n for header columns containing the alternative base count of a sample.\n\n See the setter header_sample_alternative_count_substring( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_alternative_count_substring() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_sample_frequency_substring", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_sample_frequency_substring, "Specify a (sub)string that is the prefix or suffix\n for header columns containing the frequency of a sample.\n\n See the setter header_sample_reference_count_substring( std::string const& ) for details;\n this setter here however specifies the prefix or suffix for columns containing\n the frequency of samples.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_frequency_substring(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_sample_frequency_substring", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_sample_frequency_substring, "Return the currently set (sub)string that is the prefix or suffix\n for header columns containing the frequency of a sample.\n\n See the setter header_sample_frequency_substring( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_frequency_substring() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("header_sample_coverage_substring", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(const std::string &)) &genesis::population::FrequencyTableInputIterator::header_sample_coverage_substring, "Specify a (sub)string that is the prefix or suffix\n for header columns containing the coverage of a sample (that is,\n the sum of reference and alternative base counts).\n\n See the setter header_sample_reference_count_substring( std::string const& ) for details;\n this setter here however specifies the prefix or suffix for columns containing\n the coverage of samples.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_coverage_substring(const std::string &) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("str"));
		cl.def("header_sample_coverage_substring", (const std::string & (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::header_sample_coverage_substring, "Return the currently set (sub)string that is the prefix or suffix\n for header columns containing the coverage of a sample.\n\n See the setter header_sample_coverage_substring( std::string const& ) for details.\n\nC++: genesis::population::FrequencyTableInputIterator::header_sample_coverage_substring() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("reference_genome", (class std::shared_ptr<class genesis::sequence::ReferenceGenome> (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::reference_genome, "C++: genesis::population::FrequencyTableInputIterator::reference_genome() const --> class std::shared_ptr<class genesis::sequence::ReferenceGenome>");
		cl.def("reference_genome", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(class std::shared_ptr<class genesis::sequence::ReferenceGenome>)) &genesis::population::FrequencyTableInputIterator::reference_genome, "Reference genome used to phase input data without reference bases.\n\n Some frequency table formats, such as the ones coming from HAF-pipe, do not contain\n information on the reference or alternative bases. In these cases, we could just assign\n the frequencies to random bases. However, when given the proper reference genome here\n that was used to infer the frequencies in the first place, we can at least assign\n the correct reference base.\n\n Note: While supplying the reference genome will correctly set the referen base,\n we might still not be able to obtain the alternative base that the frequency represents,\n if that information is simply not present in the input file. For instance, with the HAF-pipe\n output format, that is unknowable. In the future, we might add reading in a founder panel VCF,\n or something alike that would give that information.\n However, most of our downstream algorithms do not really need to know the exact alternative\n base anyway, so instead, in these cases, we simply assign the transition base of the\n reference base (A <-> G and C <-> T) instead, to keep it simple. That is the most likely\n we can do without further information.\n\nC++: genesis::population::FrequencyTableInputIterator::reference_genome(class std::shared_ptr<class genesis::sequence::ReferenceGenome>) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("separator_char", (char (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::separator_char, "C++: genesis::population::FrequencyTableInputIterator::separator_char() const --> char");
		cl.def("separator_char", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(char)) &genesis::population::FrequencyTableInputIterator::separator_char, "Set the separator char used for parsing the tabluar input data.\n\n By default, we use a tab `\\t`, but any other character, such as comma, can be used here.\n\nC++: genesis::population::FrequencyTableInputIterator::separator_char(char) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("int_factor", (double (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::int_factor, "C++: genesis::population::FrequencyTableInputIterator::int_factor() const --> double");
		cl.def("int_factor", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(double)) &genesis::population::FrequencyTableInputIterator::int_factor, "Set the factor by which frequencies are multiplied if no coverage information is\n present for a sample.\n\n We allow parsing information on allele counts (ref and alt counts), or frequencies and\n coverage. Howver, there are methods such as HAF-pipe that only output a final frequency,\n and (by default) do not offer any information on the (effective) coverage that a sample has.\n\n However, our internal data representation uses counts instead of frequencies, as we based\n our equations on existing pool-sequencing population genetic statistics, such as those\n developed by PoPoolation. Hence, we need to convert from frequencies to counts somehow.\n In the absence of any coverage information, we hence use a trick, by multiplying the\n frequency with a large number to obtain counts. In subsequent analyses, using a large number\n here will basically inactivate the Bessel's correction for coverage (or at least minimize its\n influence).\n\n By default, we use a factor that is the largest integer value that can be represented in\n double precision floating point numbers (i.e., 9007199254740992.0), which minimizes the above\n mentioned Bessel's correction influence. However, with this setting, a different factor can\n be used instead, which is useful when actual (effective) coverage information is available.\n\n We currently only allow to set this for the whole input, instead of on a per-sample basis.\n If needed, we might re-work this feature in the future to allow per-sample effctive coverage.\n\nC++: genesis::population::FrequencyTableInputIterator::int_factor(double) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("allowed_relative_frequency_error", (double (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::allowed_relative_frequency_error, "C++: genesis::population::FrequencyTableInputIterator::allowed_relative_frequency_error() const --> double");
		cl.def("allowed_relative_frequency_error", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(double)) &genesis::population::FrequencyTableInputIterator::allowed_relative_frequency_error, "Allowed error margin for frequencies.\n\n If an input table contains information on both the ref/alt counts (or only of of them, but\n also their coverage), as well as their frequency, we do a double check to make sure that\n everything is in order. This should be the case if the table was computed correctly.\n\n This setting here allows to set the threshold for what is considered correct. It is a\n relative measure, defaulting to 0.1%. That is, the default value is 0.001 of allowed\n relative error between the count-based frequency that we compute, and the frequency given\n in the table.\n\n Furthermore, we also use this threshold to check that frequencies as given in the input\n data fall within the range [0.0, 1.0]. Everything outside of that range that is not also\n within the allowed relative error (as provided here) will lead to an exception.\n Values thare are within that error, but still slightly outside of the range, will be set\n to be within range, to get proper frequencies.\n\nC++: genesis::population::FrequencyTableInputIterator::allowed_relative_frequency_error(double) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("frequency_is_ref", (bool (genesis::population::FrequencyTableInputIterator::*)() const) &genesis::population::FrequencyTableInputIterator::frequency_is_ref, "C++: genesis::population::FrequencyTableInputIterator::frequency_is_ref() const --> bool");
		cl.def("frequency_is_ref", (class genesis::population::FrequencyTableInputIterator & (genesis::population::FrequencyTableInputIterator::*)(bool)) &genesis::population::FrequencyTableInputIterator::frequency_is_ref, "Set whether frequencies are ref or alt frequencies.\n\n When the data table contains frequencies, it needs to be decided whether this frequency\n corresponds to the reference base (use `true` here, default), or to the alternative base\n (use `false` here).\n\nC++: genesis::population::FrequencyTableInputIterator::frequency_is_ref(bool) --> class genesis::population::FrequencyTableInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));

		{ // genesis::population::FrequencyTableInputIterator::Iterator file:genesis/population/formats/frequency_table_input_iterator.hpp line:107
			auto & enclosing_class = cl;
			pybind11::class_<genesis::population::FrequencyTableInputIterator::Iterator, std::shared_ptr<genesis::population::FrequencyTableInputIterator::Iterator>> cl(enclosing_class, "Iterator", "%Iterator over loci of the input sources.\n\n This is the class that does the actual work of turning the underlying file data into\n our Variant and BaseCounts samples. Use the dereference `operator*()`\n and `operator->()` to get the Variant at the current locus of the iteration.");
			cl.def( pybind11::init( [](genesis::population::FrequencyTableInputIterator::Iterator const &o){ return new genesis::population::FrequencyTableInputIterator::Iterator(o); } ) );
			cl.def("assign", (class genesis::population::FrequencyTableInputIterator::Iterator & (genesis::population::FrequencyTableInputIterator::Iterator::*)(const class genesis::population::FrequencyTableInputIterator::Iterator &)) &genesis::population::FrequencyTableInputIterator::Iterator::operator=, "C++: genesis::population::FrequencyTableInputIterator::Iterator::operator=(const class genesis::population::FrequencyTableInputIterator::Iterator &) --> class genesis::population::FrequencyTableInputIterator::Iterator &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
			cl.def("arrow", (const struct genesis::population::Variant * (genesis::population::FrequencyTableInputIterator::Iterator::*)() const) &genesis::population::FrequencyTableInputIterator::Iterator::operator->, "C++: genesis::population::FrequencyTableInputIterator::Iterator::operator->() const --> const struct genesis::population::Variant *", pybind11::return_value_policy::reference_internal);
			cl.def("dereference", (const struct genesis::population::Variant & (genesis::population::FrequencyTableInputIterator::Iterator::*)() const) &genesis::population::FrequencyTableInputIterator::Iterator::operator*, "C++: genesis::population::FrequencyTableInputIterator::Iterator::operator*() const --> const struct genesis::population::Variant &", pybind11::return_value_policy::reference_internal);
			cl.def("pre_increment", (class genesis::population::FrequencyTableInputIterator::Iterator & (genesis::population::FrequencyTableInputIterator::Iterator::*)()) &genesis::population::FrequencyTableInputIterator::Iterator::operator++, "C++: genesis::population::FrequencyTableInputIterator::Iterator::operator++() --> class genesis::population::FrequencyTableInputIterator::Iterator &", pybind11::return_value_policy::reference_internal);
			cl.def("__eq__", (bool (genesis::population::FrequencyTableInputIterator::Iterator::*)(const class genesis::population::FrequencyTableInputIterator::Iterator &) const) &genesis::population::FrequencyTableInputIterator::Iterator::operator==, "Compare two iterators for equality.\n\n Any two iterators that are created by calling begin() on the same\n FrequencyTableInputIterator instance will compare equal, as long as neither of them is\n past-the-end. A valid (not past-the-end) iterator and an end() iterator will not compare\n equal; all past-the-end iterators compare equal, independently from which parent they\n were created.\n\nC++: genesis::population::FrequencyTableInputIterator::Iterator::operator==(const class genesis::population::FrequencyTableInputIterator::Iterator &) const --> bool", pybind11::arg("it"));
			cl.def("__ne__", (bool (genesis::population::FrequencyTableInputIterator::Iterator::*)(const class genesis::population::FrequencyTableInputIterator::Iterator &) const) &genesis::population::FrequencyTableInputIterator::Iterator::operator!=, "C++: genesis::population::FrequencyTableInputIterator::Iterator::operator!=(const class genesis::population::FrequencyTableInputIterator::Iterator &) const --> bool", pybind11::arg("it"));
			cl.def("sample_names", (class std::vector<std::string, class std::allocator<std::string > > (genesis::population::FrequencyTableInputIterator::Iterator::*)() const) &genesis::population::FrequencyTableInputIterator::Iterator::sample_names, "Return the sample names found in the header,\n in the order in which they are in the Variant of each iteration.\n\nC++: genesis::population::FrequencyTableInputIterator::Iterator::sample_names() const --> class std::vector<std::string, class std::allocator<std::string > >");
		}

	}
}
