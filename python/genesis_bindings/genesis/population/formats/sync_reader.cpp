#include <functional>
#include <genesis/population/formats/sync_input_iterator.hpp>
#include <genesis/population/formats/sync_reader.hpp>
#include <genesis/population/formats/variant_input_iterator.hpp>
#include <genesis/population/variant.hpp>
#include <genesis/utils/io/base_input_source.hpp>
#include <genesis/utils/io/input_stream.hpp>
#include <iterator>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <utility>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/bitvector.hpp>
#include <../python/custom_bindings/extensions/range.hpp>
#include <../python/custom_bindings/extensions/quality.hpp>
#include <../python/custom_bindings/extensions/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/fasta_output_iterator.hpp>
#include <../python/custom_bindings/extensions/taxopath.hpp>
#include <../python/custom_bindings/extensions/functions_taxonomy.hpp>
#include <../python/custom_bindings/extensions/tree.hpp>
#include <../python/custom_bindings/extensions/functions_tree.hpp>
#include <genesis/population/genome_region_list.hpp>
#include <../python/custom_bindings/extensions/chromosome_iterator.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_population_formats_sync_reader(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	{ // genesis::population::SyncReader file:genesis/population/formats/sync_reader.hpp line:82
		pybind11::class_<genesis::population::SyncReader, std::shared_ptr<genesis::population::SyncReader>> cl(M("genesis::population"), "SyncReader", "Reader for PoPoolation2's \"synchronized\" files.\n\n These files are a simple tally of the counts at each position and sample in a (m)pileup file.\n Sync files are structured as follows. Each line represents a position on a chromosome:\n\n     2R  2302    T   0:7:0:0:0:0 0:7:0:0:0:0\n     2R  2303    T   0:8:0:0:0:0 0:8:0:0:0:0\n     2R  2304    C   0:0:9:0:0:0 0:0:9:0:0:0\n     2R  2305    C   1:0:9:0:0:0 0:0:9:1:0:0\n\n where:\n\n   - col1: reference contig/chromosome\n   - col2: position within the reference contig/chromosome\n   - col3: reference character (base)\n   - col4: allele frequencies of population number 1\n   - col5: allele frequencies of population number 2\n   - coln: allele frequencies of population number n\n\n The allele frequencies are in the format `A:T:C:G:N:D`, i.e: count of bases `A`,\n count of bases `T`, etc, and deletion count in the end (character '*' in the mpileup).\n\n See https://sourceforge.net/p/popoolation2/wiki/Tutorial/ for the original format description.\n Unfortunately, the file format does not support sample names.\n\n We furthermore allow a custom extension of the format, where `.:.:.:.:.:.` represents missing data.\n See allow_missing() and https://github.com/lczech/grenedalf/issues/4 for details.\n\n Note on our internal data representation: The reader returns a Variant per line, where most of\n the data is set based on the sync input content. However, the sync format does not have\n alternative bases. By default, we leave it hence as 'N'. See however the guess_alt_base() setting\n to instead estimate the alternative base from the data.");
		cl.def( pybind11::init( [](){ return new genesis::population::SyncReader(); } ) );
		cl.def( pybind11::init( [](genesis::population::SyncReader const &o){ return new genesis::population::SyncReader(o); } ) );
		cl.def("assign", (class genesis::population::SyncReader & (genesis::population::SyncReader::*)(const class genesis::population::SyncReader &)) &genesis::population::SyncReader::operator=, "C++: genesis::population::SyncReader::operator=(const class genesis::population::SyncReader &) --> class genesis::population::SyncReader &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("read_header", (class std::vector<std::string, class std::allocator<std::string > > (genesis::population::SyncReader::*)(class genesis::utils::InputStream &) const) &genesis::population::SyncReader::read_header, "Read the header line, if there is one. Do nothing if there is not.\n\n Has to be called at the start of reading a  file, as otherwise the reading will\n have already moved on from the header line.\n\n This is support for an ad-hoc extension of the `sync` format that offers a header line\n to store sample names, which are usually not available in the `sync` format. We currently\n expect a fixed format:\n\n     #chr	pos	ref	S1 S2...\n\n starting with a number sign (hashtag) `#` symbol, optionally followed by a tab character,\n and then listing the fixed columns `chr`, `pos`, and `ref`, followed by the sample name\n columns, all tab-delimited.\n\n The return value of the function are the values of the sample name columns, i.e., the\n sample names.\n\nC++: genesis::population::SyncReader::read_header(class genesis::utils::InputStream &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("input_stream"));
		cl.def("read_header", (class std::vector<std::string, class std::allocator<std::string > > (genesis::population::SyncReader::*)(class genesis::utils::InputStream &, const class std::vector<bool, class std::allocator<bool> > &) const) &genesis::population::SyncReader::read_header, "Read the header line, if there is one, only reading specific columns.\n Do nothing if there is not.\n\n This overload of the function additionally takes a vector indicating which sample names\n to read and return (where  is `true`), and ignores the rest (where\n  is `false`). The size of  has to match the number of\n sample name columns; an exception is thrown otherwise.\n\n This function hence is meant to match the read() and parse_line() overloads that also\n take this type of filter.\n\nC++: genesis::population::SyncReader::read_header(class genesis::utils::InputStream &, const class std::vector<bool, class std::allocator<bool> > &) const --> class std::vector<std::string, class std::allocator<std::string > >", pybind11::arg("input_stream"), pybind11::arg("sample_filter"));
		cl.def("read", (class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> > (genesis::population::SyncReader::*)(class std::shared_ptr<class genesis::utils::BaseInputSource>) const) &genesis::population::SyncReader::read, "Read the whole input into a vector of Variant%s.\n\nC++: genesis::population::SyncReader::read(class std::shared_ptr<class genesis::utils::BaseInputSource>) const --> class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> >", pybind11::arg("source"));
		cl.def("read", (class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> > (genesis::population::SyncReader::*)(class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::vector<bool, class std::allocator<bool> > &) const) &genesis::population::SyncReader::read, "brief Read the whole input into a vector of Variant%s, using a subset of the sample columns.\n\n The overload expects a vector indicating which columns to read and which to skip.\n The Variant%s produced for each line of input only contain as many entries as there are\n `true` values in the provided  If the size of the  does\n not match the number of sample columns, an exception is thrown.\n\nC++: genesis::population::SyncReader::read(class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::vector<bool, class std::allocator<bool> > &) const --> class std::vector<struct genesis::population::Variant, class std::allocator<struct genesis::population::Variant> >", pybind11::arg("source"), pybind11::arg("sample_filter"));
		cl.def("parse_line", (bool (genesis::population::SyncReader::*)(class genesis::utils::InputStream &, struct genesis::population::Variant &) const) &genesis::population::SyncReader::parse_line, "Read a single line into the provided \n\n Returns wheather the reading was successful, or not, i.e., wheather the input is at its end.\n\nC++: genesis::population::SyncReader::parse_line(class genesis::utils::InputStream &, struct genesis::population::Variant &) const --> bool", pybind11::arg("input_stream"), pybind11::arg("sample_set"));
		cl.def("parse_line", (bool (genesis::population::SyncReader::*)(class genesis::utils::InputStream &, struct genesis::population::Variant &, const class std::vector<bool, class std::allocator<bool> > &) const) &genesis::population::SyncReader::parse_line, "Read a single line into the provided  using a subset of the sample columns.\n\n This is an equivalent overload as described in the read() functions. See there for details.\n\nC++: genesis::population::SyncReader::parse_line(class genesis::utils::InputStream &, struct genesis::population::Variant &, const class std::vector<bool, class std::allocator<bool> > &) const --> bool", pybind11::arg("input_stream"), pybind11::arg("sample_set"), pybind11::arg("sample_filter"));
		cl.def("guess_alt_base", (bool (genesis::population::SyncReader::*)() const) &genesis::population::SyncReader::guess_alt_base, "C++: genesis::population::SyncReader::guess_alt_base() const --> bool");
		cl.def("guess_alt_base", (class genesis::population::SyncReader & (genesis::population::SyncReader::*)(bool)) &genesis::population::SyncReader::guess_alt_base, "Set to guess the alternative base of the Variant, instead of leaving it at 'N'.\n\n Excluding the reference base, we use the base of the remaining three that has the highest\n total count across all samples, unless all of them are zero, in which case we do not set\n the altnative base. We also skip cases where the ref is not in `ACGT`, as then the\n alternative base is also meaningless. In these cases, the alternative will be `N`.\n\n Note though that this can lead to conflicts between different files, if the second most\n abundant nucleotide differs between them, e.g., in non-biallelic positions. Usually we can\n deal with this, see for example VariantParallelInputIterator::Iterator::joined_variant().\n Still, it is important to keep this in mind.\n\nC++: genesis::population::SyncReader::guess_alt_base(bool) --> class genesis::population::SyncReader &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("allow_missing", (bool (genesis::population::SyncReader::*)() const) &genesis::population::SyncReader::allow_missing, "C++: genesis::population::SyncReader::allow_missing() const --> bool");
		cl.def("allow_missing", (class genesis::population::SyncReader & (genesis::population::SyncReader::*)(bool)) &genesis::population::SyncReader::allow_missing, "Set whether to allow missing data in the format suggested by Kapun et al.\n\n In order to distinguish missing/masked data from true zero-coverage positions, Kapun suggested\n to use the notation `.:.:.:.:.:.` for masked sites. When this is activate (default), we\n allow to read these, but still (as of now) produce zero-coverage sites, as we currently\n do not have an internal representation for denoting that.\n See https://github.com/lczech/grenedalf/issues/4 for details.\n\nC++: genesis::population::SyncReader::allow_missing(bool) --> class genesis::population::SyncReader &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
	}
	{ // genesis::population::SyncInputIterator file:genesis/population/formats/sync_input_iterator.hpp line:74
		pybind11::class_<genesis::population::SyncInputIterator, std::shared_ptr<genesis::population::SyncInputIterator>> cl(M("genesis::population"), "SyncInputIterator", "Iterate an input source and parse it as a sync file.\n\n This simple wrapper allows easy iteration through the records/lines of an sync file\n as defined by PoPoolation2, line by line. See SyncReader for details.\n\n Basic usage:\n\n     auto it = SyncInputIterator( utils::from_file( infile ));\n     while( it ) {\n         // work with it->...\n         ++it;\n     }\n\n or\n\n     for( auto it = SyncInputIterator( utils::from_file( infile )); it; ++it ) {\n         // work with it->...\n     }\n\n both allow to iterate each line in the file.\n\n Additionally, filtering of which samples (by index) to include can be provided, as a bool vector\n that is `true` at the indices to consider. The filter does not need to contain the same number\n of values as the Variant/line has samples. If it is shorter, all samples after its last index\n will be ignored. If it is longer, the remaining entries are not used as a filter.");
		cl.def( pybind11::init( [](){ return new genesis::population::SyncInputIterator(); } ) );
		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0){ return new genesis::population::SyncInputIterator(a0); } ), "doc" , pybind11::arg("source"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class genesis::population::SyncReader &>(), pybind11::arg("source"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](class std::shared_ptr<class genesis::utils::BaseInputSource> const & a0, const class std::vector<bool, class std::allocator<bool> > & a1){ return new genesis::population::SyncInputIterator(a0, a1); } ), "doc" , pybind11::arg("source"), pybind11::arg("sample_filter"));
		cl.def( pybind11::init<class std::shared_ptr<class genesis::utils::BaseInputSource>, const class std::vector<bool, class std::allocator<bool> > &, const class genesis::population::SyncReader &>(), pybind11::arg("source"), pybind11::arg("sample_filter"), pybind11::arg("reader") );

		cl.def( pybind11::init( [](genesis::population::SyncInputIterator const &o){ return new genesis::population::SyncInputIterator(o); } ) );
		cl.def("assign", (class genesis::population::SyncInputIterator & (genesis::population::SyncInputIterator::*)(const class genesis::population::SyncInputIterator &)) &genesis::population::SyncInputIterator::operator=, "C++: genesis::population::SyncInputIterator::operator=(const class genesis::population::SyncInputIterator &) --> class genesis::population::SyncInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("good", (bool (genesis::population::SyncInputIterator::*)() const) &genesis::population::SyncInputIterator::good, "C++: genesis::population::SyncInputIterator::good() const --> bool");
		cl.def("get_sample_names", (const class std::vector<std::string, class std::allocator<std::string > > & (genesis::population::SyncInputIterator::*)() const) &genesis::population::SyncInputIterator::get_sample_names, "C++: genesis::population::SyncInputIterator::get_sample_names() const --> const class std::vector<std::string, class std::allocator<std::string > > &", pybind11::return_value_policy::reference_internal);
		cl.def("variant", (struct genesis::population::Variant & (genesis::population::SyncInputIterator::*)()) &genesis::population::SyncInputIterator::variant, "C++: genesis::population::SyncInputIterator::variant() --> struct genesis::population::Variant &", pybind11::return_value_policy::reference_internal);
		cl.def("arrow", (struct genesis::population::Variant * (genesis::population::SyncInputIterator::*)()) &genesis::population::SyncInputIterator::operator->, "C++: genesis::population::SyncInputIterator::operator->() --> struct genesis::population::Variant *", pybind11::return_value_policy::reference_internal);
		cl.def("dereference", (struct genesis::population::Variant & (genesis::population::SyncInputIterator::*)()) &genesis::population::SyncInputIterator::operator*, "C++: genesis::population::SyncInputIterator::operator*() --> struct genesis::population::Variant &", pybind11::return_value_policy::reference_internal);
		cl.def("pre_increment", (class genesis::population::SyncInputIterator & (genesis::population::SyncInputIterator::*)()) &genesis::population::SyncInputIterator::operator++, "C++: genesis::population::SyncInputIterator::operator++() --> class genesis::population::SyncInputIterator &", pybind11::return_value_policy::reference_internal);
		cl.def("post_increment", (class genesis::population::SyncInputIterator & (genesis::population::SyncInputIterator::*)(int)) &genesis::population::SyncInputIterator::operator++, "C++: genesis::population::SyncInputIterator::operator++(int) --> class genesis::population::SyncInputIterator &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("increment", (void (genesis::population::SyncInputIterator::*)()) &genesis::population::SyncInputIterator::increment, "C++: genesis::population::SyncInputIterator::increment() --> void");
		cl.def("__eq__", (bool (genesis::population::SyncInputIterator::*)(const class genesis::population::SyncInputIterator &) const) &genesis::population::SyncInputIterator::operator==, "C++: genesis::population::SyncInputIterator::operator==(const class genesis::population::SyncInputIterator &) const --> bool", pybind11::arg("it"));
		cl.def("__ne__", (bool (genesis::population::SyncInputIterator::*)(const class genesis::population::SyncInputIterator &) const) &genesis::population::SyncInputIterator::operator!=, "C++: genesis::population::SyncInputIterator::operator!=(const class genesis::population::SyncInputIterator &) const --> bool", pybind11::arg("it"));
	}
	{ // genesis::population::VariantInputIteratorData file:genesis/population/formats/variant_input_iterator.hpp line:81
		pybind11::class_<genesis::population::VariantInputIteratorData, std::shared_ptr<genesis::population::VariantInputIteratorData>> cl(M("genesis::population"), "VariantInputIteratorData", "Data storage for input-specific information when traversing a variant file.\n\n This is used by VariantInputIterator, see there for details.\n\n The utils::LambdaIterator allows us to store some extra data. When traversing a file as a\n list of Variant%s, one per genomic position, we can use this extra field to store information\n such as the file name and the individual sample names.\n\n In the future, we might even want to store pointers to the underlying iterators and readers\n (useful for VCF for example), so that users can work with them when iterating. For now however,\n we just store some basic information.");
		cl.def( pybind11::init( [](genesis::population::VariantInputIteratorData const &o){ return new genesis::population::VariantInputIteratorData(o); } ) );
		cl.def( pybind11::init( [](){ return new genesis::population::VariantInputIteratorData(); } ) );
		cl.def_readwrite("file_path", &genesis::population::VariantInputIteratorData::file_path);
		cl.def_readwrite("source_name", &genesis::population::VariantInputIteratorData::source_name);
		cl.def_readwrite("sample_names", &genesis::population::VariantInputIteratorData::sample_names);
		cl.def("assign", (struct genesis::population::VariantInputIteratorData & (genesis::population::VariantInputIteratorData::*)(const struct genesis::population::VariantInputIteratorData &)) &genesis::population::VariantInputIteratorData::operator=, "C++: genesis::population::VariantInputIteratorData::operator=(const struct genesis::population::VariantInputIteratorData &) --> struct genesis::population::VariantInputIteratorData &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
	}
}
