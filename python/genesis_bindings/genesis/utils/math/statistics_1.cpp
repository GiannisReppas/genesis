#include <genesis/utils/containers/matrix.hpp>
#include <genesis/utils/math/matrix.hpp>
#include <genesis/utils/math/statistics.hpp>
#include <iterator>
#include <memory>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/utils/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/utils/bitvector.hpp>
#include <../python/custom_bindings/extensions/utils/range.hpp>
#include <../python/custom_bindings/extensions/string_target.hpp>
#include <../python/custom_bindings/extensions/sequence/quality.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/reference_genome.hpp>
#include <../python/custom_bindings/extensions/taxonomy/taxopath.hpp>
#include <../python/custom_bindings/extensions/taxonomy/iterator.hpp>
#include <../python/custom_bindings/extensions/tree/tree.hpp>
#include <../python/custom_bindings/extensions/tree/functions_tree.hpp>
#include <../python/custom_bindings/extensions/placement/helper.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_utils_math_statistics_1(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// genesis::utils::weighted_harmonic_mean(const class std::vector<double, class std::allocator<double> > &, const class std::vector<double, class std::allocator<double> > &, enum genesis::utils::HarmonicMeanZeroPolicy) file:genesis/utils/math/statistics.hpp line:988
	M("genesis::utils").def("weighted_harmonic_mean", [](const class std::vector<double, class std::allocator<double> > & a0, const class std::vector<double, class std::allocator<double> > & a1) -> double { return genesis::utils::weighted_harmonic_mean(a0, a1); }, "", pybind11::arg("values"), pybind11::arg("weights"));
	M("genesis::utils").def("weighted_harmonic_mean", (double (*)(const class std::vector<double, class std::allocator<double> > &, const class std::vector<double, class std::allocator<double> > &, enum genesis::utils::HarmonicMeanZeroPolicy)) &genesis::utils::weighted_harmonic_mean, "Calculate the weighted harmonic mean of a `std::vector` of `double` elements.\n\n \n weighted_harmonic_mean( ForwardIterator first, ForwardIterator last ) for details.\n \n\n harmonic_mean() for the unweighted version.\n \n\n arithmetic_mean() for a function that calculates the arithmetic mean, and\n \n\n geometric_mean() for a function that calculates the geometric mean.\n \n\n weighted_arithmetic_mean() for a function that calculates the weighted arithmetic mean, and\n \n\n weighted_geometric_mean() for a function that calculates the weighted geometric mean.\n\nC++: genesis::utils::weighted_harmonic_mean(const class std::vector<double, class std::allocator<double> > &, const class std::vector<double, class std::allocator<double> > &, enum genesis::utils::HarmonicMeanZeroPolicy) --> double", pybind11::arg("values"), pybind11::arg("weights"), pybind11::arg("zero_policy"));

	// genesis::utils::median(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >) file:genesis/utils/math/statistics.hpp line:1014
	M("genesis::utils").def("median", (double (*)(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >)) &genesis::utils::median<__gnu_cxx::__normal_iterator<const double *, std::vector<double, std::allocator<double> > >>, "C++: genesis::utils::median(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >) --> double", pybind11::arg("first"), pybind11::arg("last"));

	// genesis::utils::median(const class std::vector<double, class std::allocator<double> > &) file:genesis/utils/math/statistics.hpp line:1050
	M("genesis::utils").def("median", (double (*)(const class std::vector<double, class std::allocator<double> > &)) &genesis::utils::median, "Calculate the median value of a `vector` of `double`.\n\n The vector has to be sorted.\n\nC++: genesis::utils::median(const class std::vector<double, class std::allocator<double> > &) --> double", pybind11::arg("vec"));

	// genesis::utils::quartiles(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >) file:genesis/utils/math/statistics.hpp line:1066
	M("genesis::utils").def("quartiles", (struct genesis::utils::Quartiles (*)(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >)) &genesis::utils::quartiles<__gnu_cxx::__normal_iterator<const double *, std::vector<double, std::allocator<double> > >>, "C++: genesis::utils::quartiles(class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >, class __gnu_cxx::__normal_iterator<const double *, class std::vector<double, class std::allocator<double> > >) --> struct genesis::utils::Quartiles", pybind11::arg("first"), pybind11::arg("last"));

	// genesis::utils::quartiles(const class std::vector<double, class std::allocator<double> > &) file:genesis/utils/math/statistics.hpp line:1108
	M("genesis::utils").def("quartiles", (struct genesis::utils::Quartiles (*)(const class std::vector<double, class std::allocator<double> > &)) &genesis::utils::quartiles, "Calculate the Quartiles of a `vector` of `double`.\n\n The vector has to be sorted.\n\nC++: genesis::utils::quartiles(const class std::vector<double, class std::allocator<double> > &) --> struct genesis::utils::Quartiles", pybind11::arg("vec"));

	// genesis::utils::coefficient_of_variation(const struct genesis::utils::MeanStddevPair &) file:genesis/utils/math/statistics.hpp line:1125
	M("genesis::utils").def("coefficient_of_variation", (double (*)(const struct genesis::utils::MeanStddevPair &)) &genesis::utils::coefficient_of_variation, "Calculate the index of dispersion.\n\n The coefficient of variation (CV), also known as the relative standard deviation (RSD),\n is defined as the ratio of the standard deviation to the mean.\n See mean_stddev() to calculate those values.\n See https://en.wikipedia.org/wiki/Coefficient_of_variation for details.\n\nC++: genesis::utils::coefficient_of_variation(const struct genesis::utils::MeanStddevPair &) --> double", pybind11::arg("ms"));

	// genesis::utils::coefficient_of_variation(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &) file:genesis/utils/math/statistics.hpp line:1133
	M("genesis::utils").def("coefficient_of_variation", (class std::vector<double, class std::allocator<double> > (*)(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &)) &genesis::utils::coefficient_of_variation, "coefficient_of_variation( MeanStddevPair const& ms )\n\nC++: genesis::utils::coefficient_of_variation(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &) --> class std::vector<double, class std::allocator<double> >", pybind11::arg("ms"));

	// genesis::utils::index_of_dispersion(const struct genesis::utils::MeanStddevPair &) file:genesis/utils/math/statistics.hpp line:1151
	M("genesis::utils").def("index_of_dispersion", (double (*)(const struct genesis::utils::MeanStddevPair &)) &genesis::utils::index_of_dispersion, "Calculate the index of dispersion.\n\n The index of dispersion, also known as the dispersion index, coefficient of dispersion,\n relative variance, variance-to-mean ratio (VMR) or Fano factor, is defined as the ratio of the\n variance to the mean. Variance is the square of the standard deviation.\n See mean_stddev() to calculate those values.\n See https://en.wikipedia.org/wiki/Index_of_dispersion for details.\n\nC++: genesis::utils::index_of_dispersion(const struct genesis::utils::MeanStddevPair &) --> double", pybind11::arg("ms"));

	// genesis::utils::index_of_dispersion(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &) file:genesis/utils/math/statistics.hpp line:1159
	M("genesis::utils").def("index_of_dispersion", (class std::vector<double, class std::allocator<double> > (*)(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &)) &genesis::utils::index_of_dispersion, "index_of_dispersion( MeanStddevPair const& ms )\n\nC++: genesis::utils::index_of_dispersion(const class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > &) --> class std::vector<double, class std::allocator<double> >", pybind11::arg("ms"));

	// genesis::utils::quartile_coefficient_of_dispersion(const struct genesis::utils::Quartiles &) file:genesis/utils/math/statistics.hpp line:1175
	M("genesis::utils").def("quartile_coefficient_of_dispersion", (double (*)(const struct genesis::utils::Quartiles &)) &genesis::utils::quartile_coefficient_of_dispersion, "Calculate the quartile_coefficient_of_dispersion.\n\n The quartile coefficient of dispersion is defined as `( Q3 - Q1 ) / ( Q3 + Q1 )`.\n See quartiles() to caculate those values.\n See https://en.wikipedia.org/wiki/Quartile_coefficient_of_dispersion for details.\n\nC++: genesis::utils::quartile_coefficient_of_dispersion(const struct genesis::utils::Quartiles &) --> double", pybind11::arg("q"));

	// genesis::utils::quartile_coefficient_of_dispersion(const class std::vector<struct genesis::utils::Quartiles, class std::allocator<struct genesis::utils::Quartiles> > &) file:genesis/utils/math/statistics.hpp line:1183
	M("genesis::utils").def("quartile_coefficient_of_dispersion", (class std::vector<double, class std::allocator<double> > (*)(const class std::vector<struct genesis::utils::Quartiles, class std::allocator<struct genesis::utils::Quartiles> > &)) &genesis::utils::quartile_coefficient_of_dispersion, "quartile_coefficient_of_dispersion( Quartiles const& ms )\n\nC++: genesis::utils::quartile_coefficient_of_dispersion(const class std::vector<struct genesis::utils::Quartiles, class std::allocator<struct genesis::utils::Quartiles> > &) --> class std::vector<double, class std::allocator<double> >", pybind11::arg("q"));

	// genesis::utils::normalize_cols(class genesis::utils::Matrix<double> &) file:genesis/utils/math/matrix.hpp line:262
	M("genesis::utils").def("normalize_cols", (class std::vector<struct genesis::utils::MinMaxPair<double>, class std::allocator<struct genesis::utils::MinMaxPair<double> > > (*)(class genesis::utils::Matrix<double> &)) &genesis::utils::normalize_cols, "Normalize the columns of a Matrix so that all values are in the range `[ 0.0, 1.0 ]`.\n\n The Matrix is manipulated inline. For each column, the new values of the Matrix are calculated\n as \n\n.\n\n The function returns a vector containing the `min` and `max` values of the columns\n before normalization, see matrix_col_minmax().\n\n \n        Input data Matrix; normalization is done inline.\n \n\n            Vector containing the min and max values for each column before normalization.\n\nC++: genesis::utils::normalize_cols(class genesis::utils::Matrix<double> &) --> class std::vector<struct genesis::utils::MinMaxPair<double>, class std::allocator<struct genesis::utils::MinMaxPair<double> > >", pybind11::arg("data"));

	// genesis::utils::normalize_rows(class genesis::utils::Matrix<double> &) file:genesis/utils/math/matrix.hpp line:276
	M("genesis::utils").def("normalize_rows", (class std::vector<struct genesis::utils::MinMaxPair<double>, class std::allocator<struct genesis::utils::MinMaxPair<double> > > (*)(class genesis::utils::Matrix<double> &)) &genesis::utils::normalize_rows, "Normalize the rows of a Matrix so that all values are in the range `[ 0.0, 1.0 ]`.\n\n The Matrix is manipulated inline. For each row, the new values of the Matrix are calculated\n as \n\n.\n\n The function returns a vector containing the `min` and `max` values of the rows\n before normalization, see matrix_row_minmax().\n\n \n        Input data Matrix; normalization is done inline.\n \n\n            Vector containing the min and max values for each row before normalization.\n\nC++: genesis::utils::normalize_rows(class genesis::utils::Matrix<double> &) --> class std::vector<struct genesis::utils::MinMaxPair<double>, class std::allocator<struct genesis::utils::MinMaxPair<double> > >", pybind11::arg("data"));

	// genesis::utils::standardize_cols(class genesis::utils::Matrix<double> &, bool, bool) file:genesis/utils/math/matrix.hpp line:295
	M("genesis::utils").def("standardize_cols", [](class genesis::utils::Matrix<double> & a0) -> std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > { return genesis::utils::standardize_cols(a0); }, "", pybind11::arg("data"));
	M("genesis::utils").def("standardize_cols", [](class genesis::utils::Matrix<double> & a0, bool const & a1) -> std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > { return genesis::utils::standardize_cols(a0, a1); }, "", pybind11::arg("data"), pybind11::arg("scale_means"));
	M("genesis::utils").def("standardize_cols", (class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > (*)(class genesis::utils::Matrix<double> &, bool, bool)) &genesis::utils::standardize_cols, "Standardize the columns of a Matrix by subtracting the mean and scaling to unit variance.\n\n The function performs a column-wise z-transformation on the given data.\n\n The function returns a vector containing the mean and standard deviation of the columns\n before standardization, see MeanStddevPair. If both `scale_means` and `scale_std` are\n set to `false`, the original data is not manipulated, while the returned vector still contains\n the means and standard deviations. See also matrix_col_mean_stddev().\n\n \n        Input data Matrix; standardizing is done inline.\n \n\n If `true` (default), center the data by subtracting the mean per column.\n \n\n   If `true` (default), scale the data to unit variance (or equivalently,\n                    unit standard deviation) per column.\n \n\n            Vector containing the mean and standard deviation for each column before\n                    standardization.\n\nC++: genesis::utils::standardize_cols(class genesis::utils::Matrix<double> &, bool, bool) --> class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> >", pybind11::arg("data"), pybind11::arg("scale_means"), pybind11::arg("scale_std"));

	// genesis::utils::standardize_rows(class genesis::utils::Matrix<double> &, bool, bool) file:genesis/utils/math/matrix.hpp line:318
	M("genesis::utils").def("standardize_rows", [](class genesis::utils::Matrix<double> & a0) -> std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > { return genesis::utils::standardize_rows(a0); }, "", pybind11::arg("data"));
	M("genesis::utils").def("standardize_rows", [](class genesis::utils::Matrix<double> & a0, bool const & a1) -> std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > { return genesis::utils::standardize_rows(a0, a1); }, "", pybind11::arg("data"), pybind11::arg("scale_means"));
	M("genesis::utils").def("standardize_rows", (class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> > (*)(class genesis::utils::Matrix<double> &, bool, bool)) &genesis::utils::standardize_rows, "Standardize the rows of a Matrix by subtracting the mean and scaling to unit variance.\n\n The function performs a row-wise z-transformation on the given data.\n\n The function returns a vector containing the mean and standard deviation of the rows\n before standardization, see MeanStddevPair. If both `scale_means` and `scale_std` are\n set to `false`, the original data is not manipulated, while the returned vector still contains\n the means and standard deviations. See also matrix_row_mean_stddev().\n\n \n        Input data Matrix; standardizing is done inline.\n \n\n If `true` (default), center the data by subtracting the mean per column.\n \n\n   If `true` (default), scale the data to unit variance (or equivalently,\n                    unit standard deviation) per column.\n \n\n            Vector containing the mean and standard deviation for each column before\n                    standardization.\n\nC++: genesis::utils::standardize_rows(class genesis::utils::Matrix<double> &, bool, bool) --> class std::vector<struct genesis::utils::MeanStddevPair, class std::allocator<struct genesis::utils::MeanStddevPair> >", pybind11::arg("data"), pybind11::arg("scale_means"), pybind11::arg("scale_std"));

	// genesis::utils::filter_constant_columns(class genesis::utils::Matrix<double> &, double) file:genesis/utils/math/matrix.hpp line:338
	M("genesis::utils").def("filter_constant_columns", [](class genesis::utils::Matrix<double> & a0) -> std::vector<unsigned long, class std::allocator<unsigned long> > { return genesis::utils::filter_constant_columns(a0); }, "", pybind11::arg("data"));
	M("genesis::utils").def("filter_constant_columns", (class std::vector<unsigned long, class std::allocator<unsigned long> > (*)(class genesis::utils::Matrix<double> &, double)) &genesis::utils::filter_constant_columns, "Filter out columns that have nearly constant values, measured using an \n\n The \n\n\n\n\n\n\n\n\n\n\n\nC++: genesis::utils::filter_constant_columns(class genesis::utils::Matrix<double> &, double) --> class std::vector<unsigned long, class std::allocator<unsigned long> >", pybind11::arg("data"), pybind11::arg("epsilon"));

}
