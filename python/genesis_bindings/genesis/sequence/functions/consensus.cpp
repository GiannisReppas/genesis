#include <genesis/sequence/counts.hpp>
#include <genesis/sequence/functions/consensus.hpp>
#include <genesis/sequence/sequence.hpp>
#include <genesis/sequence/sequence_set.hpp>
#include <iterator>
#include <memory>
#include <string>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/utils/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/utils/bitvector.hpp>
#include <../python/custom_bindings/extensions/utils/range.hpp>
#include <../python/custom_bindings/extensions/string_target.hpp>
#include <../python/custom_bindings/extensions/sequence/quality.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/reference_genome.hpp>
#include <../python/custom_bindings/extensions/taxonomy/taxopath.hpp>
#include <../python/custom_bindings/extensions/taxonomy/iterator.hpp>
#include <../python/custom_bindings/extensions/tree/tree.hpp>
#include <../python/custom_bindings/extensions/tree/functions_tree.hpp>
#include <../python/custom_bindings/extensions/placement/helper.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_sequence_functions_consensus(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// genesis::sequence::consensus_sequence_with_majorities(const class genesis::sequence::SequenceSet &, const std::string &, bool, char) file:genesis/sequence/functions/consensus.hpp line:104
	M("genesis::sequence").def("consensus_sequence_with_majorities", [](const class genesis::sequence::SequenceSet & a0, const std::string & a1) -> std::string { return genesis::sequence::consensus_sequence_with_majorities(a0, a1); }, "", pybind11::arg("sequences"), pybind11::arg("characters"));
	M("genesis::sequence").def("consensus_sequence_with_majorities", [](const class genesis::sequence::SequenceSet & a0, const std::string & a1, bool const & a2) -> std::string { return genesis::sequence::consensus_sequence_with_majorities(a0, a1, a2); }, "", pybind11::arg("sequences"), pybind11::arg("characters"), pybind11::arg("allow_gaps"));
	M("genesis::sequence").def("consensus_sequence_with_majorities", (std::string (*)(const class genesis::sequence::SequenceSet &, const std::string &, bool, char)) &genesis::sequence::consensus_sequence_with_majorities, "Calculate the majority rule consensus sequence by using the most frequent character at\n each site.\n\n See \n\n\n\n\n\n\n\n\n\n\nC++: genesis::sequence::consensus_sequence_with_majorities(const class genesis::sequence::SequenceSet &, const std::string &, bool, char) --> std::string", pybind11::arg("sequences"), pybind11::arg("characters"), pybind11::arg("allow_gaps"), pybind11::arg("gap_char"));

	// genesis::sequence::consensus_sequence_with_majorities(const class genesis::sequence::SequenceSet &, bool) file:genesis/sequence/functions/consensus.hpp line:121
	M("genesis::sequence").def("consensus_sequence_with_majorities", [](const class genesis::sequence::SequenceSet & a0) -> std::string { return genesis::sequence::consensus_sequence_with_majorities(a0); }, "", pybind11::arg("sequences"));
	M("genesis::sequence").def("consensus_sequence_with_majorities", (std::string (*)(const class genesis::sequence::SequenceSet &, bool)) &genesis::sequence::consensus_sequence_with_majorities, "Calculate the majority rule consensus sequence by using the most frequent character at\n each site for nucleic acid codes `ACGT`.\n\n See \n\n\n\n\n\n\nC++: genesis::sequence::consensus_sequence_with_majorities(const class genesis::sequence::SequenceSet &, bool) --> std::string", pybind11::arg("sequences"), pybind11::arg("allow_gaps"));

	// genesis::sequence::consensus_sequence_with_ambiguities(const class genesis::sequence::SiteCounts &, double, bool) file:genesis/sequence/functions/consensus.hpp line:172
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", [](const class genesis::sequence::SiteCounts & a0) -> std::string { return genesis::sequence::consensus_sequence_with_ambiguities(a0); }, "", pybind11::arg("counts"));
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", [](const class genesis::sequence::SiteCounts & a0, double const & a1) -> std::string { return genesis::sequence::consensus_sequence_with_ambiguities(a0, a1); }, "", pybind11::arg("counts"), pybind11::arg("similarity_factor"));
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", (std::string (*)(const class genesis::sequence::SiteCounts &, double, bool)) &genesis::sequence::consensus_sequence_with_ambiguities, "Calculate a consensus sequence by using the most frequent characters at each site,\n for nucleic acid codes `ACGT` and their ambiguities.\n\n The function calculates a consensus sequence for nucleic acid codes (`ACGT`), using their\n ambiguity codes (e.g., `W` for \"weak\" == `AT`) if the counts (i.e., character frequencies) are\n similar at a site. It uses `similarity_factor` to decide which counts are close enough to each\n other in order to be considered ambiguous.\n\n For example, with `similarity_factor == 1.0`, only exact matches are used, that is, if two\n counts are exactly the same. Let count('A') == 42 and count('T') == 42,\n and both other counts (`C` and `G`) be `0`, this results in the code `W` at that site. If however\n count('T') == 41, only `A` is used for the site.\n Thus, with `similarity_factor == 1.0`, this function behaves very similar to\n consensus_sequence_with_majorities(), except in cases were two counts are exaclty the same.\n\n On the other hand, with `similarity_factor == 0.0`, all codes that are present at a site are\n considered to be ambiguous. That is, if a site contains `counts > 0` for `A`, `G` and `T`, the\n resulting site gets the code `D` (\"not C\").\n\n For intermediate values, e.g., the default `0.9`, the value is used as a threshold to decide\n the ambiguities. For example, let count('A') == 42 and count('T') == 38,\n and both other counts be `0`. Then, the allowed deviation from the maximum `42` is\n `0.9 * 42 = 37.8`. Thus, as the count for `T` is above this value, those two codes are\n considered ambiguous, resulting in a `W` at that site.\n\n The optional parameter `allow_gaps` (default is `true`) behaves similar to its counterpart in\n consensus_sequence_with_majorities(). If set to `true`, the count of the gap character is also\n considered. As the ambiguity for a gap combined with any other character is still a gap,\n sites where gap is the most frequent charater or is within the deviation get a gap as result.\n\n If `allow_gaps` is set to `false` instead, gaps are not considered. That means, the ambiguities\n are calculated as if there were no gaps. So even if a site contains mostly gaps, but only a few\n other characters, those will be used. Solely all-gap sites result in a gap at that site.\n\n Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here.\n The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more\n information on the used codes.\n\n If the provided SiteCounts object does not use nucleic acid codes, or if the\n `similarity_factor` is not within the range `[ 0.0, 1.0 ]`, an exception is thrown.\n\nC++: genesis::sequence::consensus_sequence_with_ambiguities(const class genesis::sequence::SiteCounts &, double, bool) --> std::string", pybind11::arg("counts"), pybind11::arg("similarity_factor"), pybind11::arg("allow_gaps"));

	// genesis::sequence::consensus_sequence_with_ambiguities(const class genesis::sequence::SequenceSet &, double, bool) file:genesis/sequence/functions/consensus.hpp line:186
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", [](const class genesis::sequence::SequenceSet & a0) -> std::string { return genesis::sequence::consensus_sequence_with_ambiguities(a0); }, "", pybind11::arg("sequences"));
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", [](const class genesis::sequence::SequenceSet & a0, double const & a1) -> std::string { return genesis::sequence::consensus_sequence_with_ambiguities(a0, a1); }, "", pybind11::arg("sequences"), pybind11::arg("similarity_factor"));
	M("genesis::sequence").def("consensus_sequence_with_ambiguities", (std::string (*)(const class genesis::sequence::SequenceSet &, double, bool)) &genesis::sequence::consensus_sequence_with_ambiguities, "Calculate a consensus sequence by using the most frequent characters at each site,\n for nucleic acid codes `ACGT` and their ambiguities.\n\n See \n\n\n\n\nC++: genesis::sequence::consensus_sequence_with_ambiguities(const class genesis::sequence::SequenceSet &, double, bool) --> std::string", pybind11::arg("sequences"), pybind11::arg("similarity_factor"), pybind11::arg("allow_gaps"));

	// genesis::sequence::consensus_sequence_with_threshold(const class genesis::sequence::SiteCounts &, double, bool, bool) file:genesis/sequence/functions/consensus.hpp line:248
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SiteCounts & a0) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0); }, "", pybind11::arg("counts"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SiteCounts & a0, double const & a1) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0, a1); }, "", pybind11::arg("counts"), pybind11::arg("frequency_threshold"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SiteCounts & a0, double const & a1, bool const & a2) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0, a1, a2); }, "", pybind11::arg("counts"), pybind11::arg("frequency_threshold"), pybind11::arg("allow_gaps"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", (std::string (*)(const class genesis::sequence::SiteCounts &, double, bool, bool)) &genesis::sequence::consensus_sequence_with_threshold, "Calculate a consensus sequence where the character frequency needs to be above a given\n threshold, for nucleic acid codes `ACGT`.\n\n The function calculates a consensus sequence for nucleic acid codes (`ACGT`). It uses the\n frequency of characters at each site to determine the consensus. The frequency is relative to the\n total number of counts at that site, thus, it is a value in the range `[ 0.0, 1.0 ]`.\n\n If the frequency of a character at a site is above the given `frequency_threshold`, it is used\n for the consensus. If not, the resulting character depends on `use_ambiguities`.\n If `use_ambiguities` is set to `true` (default), the sorted frequencies of the characters are\n added until the threshold is reached, and the ambiguity code for those characters is used.\n For example, let `frequency_threshold == 0.9`, count('A') == 42 and\n count('T') == 42, and both other counts (`C` and `G`) be 0.\n Then, neither `A` nor `T` have counts above the threshold, but combined they do, so the result is\n code `W == AT` at that site. If however `use_ambiguities` is `false`, the mask character `X` is\n used for sites that are below the threshold.\n\n Furthermore, if `allow_gaps` is set to `true` (default), gaps are counted when determining the\n threshold and checking whether the frequency is above it. That is, gaps are then treated as just\n another character at the site. For sites where the gap frequency is needed to reach the\n threshold, a gap is used as consensus.\n If `allow_gaps` is `false`, however, gaps are not counted for determining the frequency of the\n other characters. This is similar to the counterpart in consensus_sequence_with_majorities().\n Solely sites that are gaps-only result in a gap char for the consensus then.\n\n For `frequency_threshold < 0.5`, it may happen that more than one character has a frequency\n above the threshold. In such cases, the most frequent character is used (or, if they have exaclty\n the same counts, they are used in the order `ACGT`).\n This is in line with the behaviour of consensus_sequence_with_majorities(). Usually, however,\n the threshold is above 0.5 anyway, as this gives more meaningful results. If you want to use\n ambiguity characters for low frequency characters, you can use\n consensus_sequence_with_ambiguities() instead.\n\n An extreme case is a `frequency_threshold` of 1.0. In this case, for sites which only have one\n character, this one is directly used in the consensus. Sites with multiple different characters\n result in the ambiguity code of all occuring characters at that site. Thus, the function then\n behaves similar to consensus_sequence_with_ambiguities() with a `similarity_factor` of 0.0.\n\n The other extrem case is a `frequency_threshold` of 0.0. In this case, the function simply uses\n the most frequent character per site, as it always fulfills the threshold. As said above, if then\n more than one character has exactly the same frequency, they are used in the order `ACGT`, thus\n the function then behaves similar to consensus_sequence_with_majorities().\n\n Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here,\n and the mask character to 'X'.\n The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more\n information on the used codes.\n\n If the provided SiteCounts object does not use nucleic acid codes, or if the\n `frequency_threshold` is not within the range `[ 0.0, 1.0 ]`, an exception is thrown.\n\nC++: genesis::sequence::consensus_sequence_with_threshold(const class genesis::sequence::SiteCounts &, double, bool, bool) --> std::string", pybind11::arg("counts"), pybind11::arg("frequency_threshold"), pybind11::arg("allow_gaps"), pybind11::arg("use_ambiguities"));

	// genesis::sequence::consensus_sequence_with_threshold(const class genesis::sequence::SequenceSet &, double, bool, bool) file:genesis/sequence/functions/consensus.hpp line:263
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SequenceSet & a0) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0); }, "", pybind11::arg("sequences"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SequenceSet & a0, double const & a1) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0, a1); }, "", pybind11::arg("sequences"), pybind11::arg("frequency_threshold"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", [](const class genesis::sequence::SequenceSet & a0, double const & a1, bool const & a2) -> std::string { return genesis::sequence::consensus_sequence_with_threshold(a0, a1, a2); }, "", pybind11::arg("sequences"), pybind11::arg("frequency_threshold"), pybind11::arg("allow_gaps"));
	M("genesis::sequence").def("consensus_sequence_with_threshold", (std::string (*)(const class genesis::sequence::SequenceSet &, double, bool, bool)) &genesis::sequence::consensus_sequence_with_threshold, "Calculate a consensus sequence where the character frequency needs to be above a given\n threshold, for nucleic acid codes `ACGT`.\n\n See \n\n\n\n\nC++: genesis::sequence::consensus_sequence_with_threshold(const class genesis::sequence::SequenceSet &, double, bool, bool) --> std::string", pybind11::arg("sequences"), pybind11::arg("frequency_threshold"), pybind11::arg("allow_gaps"), pybind11::arg("use_ambiguities"));

	// genesis::sequence::consensus_sequence_cavener(const class genesis::sequence::SiteCounts &, bool) file:genesis/sequence/functions/consensus.hpp line:306
	M("genesis::sequence").def("consensus_sequence_cavener", [](const class genesis::sequence::SiteCounts & a0) -> std::string { return genesis::sequence::consensus_sequence_cavener(a0); }, "", pybind11::arg("counts"));
	M("genesis::sequence").def("consensus_sequence_cavener", (std::string (*)(const class genesis::sequence::SiteCounts &, bool)) &genesis::sequence::consensus_sequence_cavener, "Calculate a consensus sequence using the method by Cavener\n for nucleic acid codes `ACGT` and their ambiguities.\n\n For every site, the nucleotides are sorted by frequency. Then, the following checks are performed:\n\n  1. A single nucleotide is used if its frequency is at least 50% and more than twice as high\n     as the second most frequent nucleotide.\n  2. If two nucleotides occur in at leat 75% of the sequences, and rule 1 does not apply,\n     their ambiguity code is used (double-degenerate code).\n  3. If none of the above applies, but one of the nucleotides has a count of zero,\n     the (triple-degenerate) code of the other three nucleotides is used.\n  4. In all other cases, the code 'N' is used.\n\n The method is meant for finding a consensus sequence in sets of sequences without gaps.\n This implementation however also allows gaps, which are just treated as a normal character\n if  is `true` (default). In this case, if any of rules 1-3 applies to a gap\n character, the result is simply reduced to a gap. That is, whenever a gap is used to form\n a degenerate code according to the rules, the whole code is reduced to a gap.\n\n If however  is `false`, gap characters are completely ignored from the counting.\n\n The method was described in:\n\n > D. R. Cavener, \"Comparison of the consensus sequence flanking translational start sites in\n > Drosophila and vertebrates\", Nucleic Acids Res., vol. 15, no. 4, 1987.\n\n The method is also used by the Transfac Project:\n\n > V. Matys et al., \"TRANSFAC: Transcriptional regulation, from patterns to profiles\",\n > Nucleic Acids Res., vol. 31, no. 1, pp. 374â€“378, 2003.\n\nC++: genesis::sequence::consensus_sequence_cavener(const class genesis::sequence::SiteCounts &, bool) --> std::string", pybind11::arg("counts"), pybind11::arg("allow_gaps"));

}
