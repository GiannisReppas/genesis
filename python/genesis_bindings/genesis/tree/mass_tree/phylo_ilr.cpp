#include <genesis/placement/placement_tree.hpp>
#include <genesis/tree/common_tree/newick_writer.hpp>
#include <genesis/tree/common_tree/tree.hpp>
#include <genesis/tree/formats/newick/broker.hpp>
#include <genesis/tree/formats/newick/element.hpp>
#include <genesis/tree/formats/newick/simple_tree.hpp>
#include <genesis/tree/formats/newick/writer.hpp>
#include <genesis/tree/mass_tree/balances.hpp>
#include <genesis/tree/mass_tree/phylo_ilr.hpp>
#include <genesis/tree/tree.hpp>
#include <genesis/tree/tree/edge.hpp>
#include <genesis/tree/tree/edge_data.hpp>
#include <genesis/tree/tree/link.hpp>
#include <genesis/tree/tree/node.hpp>
#include <genesis/tree/tree/node_data.hpp>
#include <genesis/tree/tree_set.hpp>
#include <genesis/utils/containers/deref_iterator.hpp>
#include <genesis/utils/containers/matrix.hpp>
#include <genesis/utils/containers/range.hpp>
#include <genesis/utils/io/base_output_target.hpp>
#include <iterator>
#include <memory>
#include <sstream> // __str__
#include <string>
#include <vector>

#include <functional>
#include <pybind11/pybind11.h>
#include <string>
#include <pybind11/functional.h>
#include <../python/custom_bindings/extensions/utils/matrix.hpp>
#include <genesis/utils/color/functions.hpp>
#include <../python/custom_bindings/extensions/utils/bitvector.hpp>
#include <../python/custom_bindings/extensions/utils/range.hpp>
#include <../python/custom_bindings/extensions/string_target.hpp>
#include <../python/custom_bindings/extensions/sequence/quality.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_set.hpp>
#include <../python/custom_bindings/extensions/sequence/sequence_dict.hpp>
#include <../python/custom_bindings/extensions/sequence/fasta_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/fastq_input_iterator.hpp>
#include <../python/custom_bindings/extensions/sequence/reference_genome.hpp>
#include <../python/custom_bindings/extensions/taxonomy/taxopath.hpp>
#include <../python/custom_bindings/extensions/taxonomy/iterator.hpp>
#include <../python/custom_bindings/extensions/tree/tree.hpp>
#include <../python/custom_bindings/extensions/tree/functions_tree.hpp>
#include <genesis/population/genome_region_list.hpp>
#include <../python/custom_bindings/extensions/population/chromosome_iterator.hpp>
#include <pybind11/stl.h>


#ifndef BINDER_PYBIND11_TYPE_CASTER
	#define BINDER_PYBIND11_TYPE_CASTER
	PYBIND11_DECLARE_HOLDER_TYPE(T, std::shared_ptr<T>)
	PYBIND11_DECLARE_HOLDER_TYPE(T, T*)
	PYBIND11_MAKE_OPAQUE(std::shared_ptr<void>)
#endif

void bind_genesis_tree_mass_tree_phylo_ilr(std::function< pybind11::module &(std::string const &namespace_) > &M)
{
	// genesis::tree::edge_balances(const struct genesis::tree::BalanceData &, bool) file:genesis/tree/mass_tree/phylo_ilr.hpp line:87
	M("genesis::tree").def("edge_balances", [](const struct genesis::tree::BalanceData & a0) -> genesis::utils::Matrix<double> { return genesis::tree::edge_balances(a0); }, "", pybind11::arg("data"));
	M("genesis::tree").def("edge_balances", (class genesis::utils::Matrix<double> (*)(const struct genesis::tree::BalanceData &, bool)) &genesis::tree::edge_balances, "Calculate edge balances using the Isometric Log Ratio transformation.\n\n This is a hybrid method between the phylogenetic_ilr_transform() and\n \n\n\n\n\n\n\nC++: genesis::tree::edge_balances(const struct genesis::tree::BalanceData &, bool) --> class genesis::utils::Matrix<double>", pybind11::arg("data"), pybind11::arg("reverse_signs"));

	{ // genesis::tree::NewickWriter file:genesis/tree/formats/newick/writer.hpp line:102
		pybind11::class_<genesis::tree::NewickWriter, std::shared_ptr<genesis::tree::NewickWriter>> cl(M("genesis::tree"), "NewickWriter", "Write a Tree to Newick format.\n\n This class supports to write a Tree into a Newick format representation, for example\n\n     Tree tree;\n     CommonTreeNewickWriter().write( tree, utils::to_file( \"path/to/file.newick\" ));\n\n It understands the Newick format, but is agnostic of the actual data representation of\n TreeNode and TreeEdge data. This approach allows to store data in any wanted format.\n For example, bootstrap values could be stored as either Newick comments (`[0.4]`) or as a second\n \"branch length\"-like value (`:0.4`), depending on the user's needs.\n\n In order to translate data from the Tree into a Newick format representation, a set of plugin\n functions is used, that need to be set before writing a Tree. Those functions are a form of\n intermediaries, which take tree data and turn them into the wanted Newick representation.\n It is possible to use lambdas for this, or any other function that can be stored in a\n `std::function`.\n\n The following plugin points are provided:\n\n   * #prepare_writing_plugins\n   * #node_to_element_plugins\n   * #edge_to_element_plugins\n   * #finish_writing_plugins\n\n For example, the CommonTreeNewickWriterPlugin is a convenience class that provides such plugin\n functions. It translates from a #CommonTree with TreeNode%s that contain names and TreeEdge%s\n that contain branch lengths into the standard Newick format. Using plugin classes like this\n additionally allows to use state for the plugin functions - that is, to use some settings for\n how to write data.\n\n Furthermore, as we use vectors of plugin functions, it is possible (and often necessary) to\n register multiple such functions, which are then called one after another. This allows to e.g.,\n first translate a branch length for an edge in one plugin function, and then translating\n a bootstrap value or edge color in another plugin function.\n\n This whole approach is a bit tedious, but unfortunately the price for the flexibility of this\n class. In order to keep the standard use cases simple, we also provide classes like\n CommonTreeNewickWriter, which hides the whole plugin system and allows simple writing\n of default trees to standard Newick.");
		cl.def( pybind11::init( [](){ return new genesis::tree::NewickWriter(); } ) );
		cl.def( pybind11::init( [](genesis::tree::NewickWriter const &o){ return new genesis::tree::NewickWriter(o); } ) );
		cl.def_readwrite("prepare_writing_plugins", &genesis::tree::NewickWriter::prepare_writing_plugins);
		cl.def_readwrite("finish_writing_plugins", &genesis::tree::NewickWriter::finish_writing_plugins);
		cl.def_readwrite("node_to_element_plugins", &genesis::tree::NewickWriter::node_to_element_plugins);
		cl.def_readwrite("edge_to_element_plugins", &genesis::tree::NewickWriter::edge_to_element_plugins);
		cl.def("assign", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(const class genesis::tree::NewickWriter &)) &genesis::tree::NewickWriter::operator=, "C++: genesis::tree::NewickWriter::operator=(const class genesis::tree::NewickWriter &) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("write", (void (genesis::tree::NewickWriter::*)(const class genesis::tree::Tree &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>) const) &genesis::tree::NewickWriter::write, "Write a Tree to an output target, using the Newick format.\n\n See the output target convenience functions utils::to_file(), utils::to_stream(), and\n utils::to_string() for examples of how to obtain a suitable output target.\n\nC++: genesis::tree::NewickWriter::write(const class genesis::tree::Tree &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>) const --> void", pybind11::arg("tree"), pybind11::arg("target"));
		cl.def("write", [](genesis::tree::NewickWriter const &o, const class genesis::tree::TreeSet & a0, class std::shared_ptr<class genesis::utils::BaseOutputTarget> const & a1) -> void { return o.write(a0, a1); }, "", pybind11::arg("tree_set"), pybind11::arg("target"));
		cl.def("write", (void (genesis::tree::NewickWriter::*)(const class genesis::tree::TreeSet &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>, bool) const) &genesis::tree::NewickWriter::write, "Write all Tree%s in a TreeSet to an output target, using the Newick format.\n\n Trees are separated from each other by semicolons and new line characters. If \n is set to `true`, each tree is preprended by its name as stored in the TreeSet, in the format\n\n     name = (<newick tree>);\n\n See the output target convenience functions utils::to_file(), utils::to_stream(), and\n utils::to_string() for examples of how to obtain a suitable output target.\n\nC++: genesis::tree::NewickWriter::write(const class genesis::tree::TreeSet &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>, bool) const --> void", pybind11::arg("tree_set"), pybind11::arg("target"), pybind11::arg("with_names"));
		cl.def("to_string", (std::string (genesis::tree::NewickWriter::*)(const class genesis::tree::Tree &) const) &genesis::tree::NewickWriter::to_string, "Shorthand to write a Tree to Newick format and return it is a string.\n\nC++: genesis::tree::NewickWriter::to_string(const class genesis::tree::Tree &) const --> std::string", pybind11::arg("tree"));
		cl.def("quotation_mark", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(char)) &genesis::tree::NewickWriter::quotation_mark, "Set the type of quotation marks used for node names that contain special characters.\n\n According to [http://evolution.genetics.washington.edu/phylip/newicktree.html]\n (http://evolution.genetics.washington.edu/phylip/newicktree.html),\n\n  > \"A name can be any string of printable characters except blanks, colons, semicolons,\n  > parentheses, and square brackets.\"\n\n They forgot to mention commas in that list. One more reason to be suspicious of the Newick\n format.\n Anyway, whenever one of these characters (including commas) occurs in the name of a node\n (see NewickBrokerElement::name), the writer wraps the whole name in quotation markes.\n This is not officially in the standard, but common practice.\n\n Remark: When using a CommonTreeNewickWriterPlugin (or a CommonTreeNewickWriter, as it\n internally uses the plugin), you can use its setting\n \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nC++: genesis::tree::NewickWriter::quotation_mark(char) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("quotation_mark", (char (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::quotation_mark, "Get the currently set type of quotation marks used for node names.\n\n See quotation_mark( char ) for details.\n\nC++: genesis::tree::NewickWriter::quotation_mark() const --> char");
		cl.def("force_quotation_marks", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::force_quotation_marks, "If set to `true`, all names are wrapped in quotation marks, regardless of whether\n the name contains any characters that need to be wrapped\n\n Default is `false`. This setting can be used to ensure that all names have quotation marks,\n which is a requirement for certain other parsers. See also quotation_mark( char ) to set\n the type of quotation mark.\n\nC++: genesis::tree::NewickWriter::force_quotation_marks(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("force_quotation_marks", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::force_quotation_marks, "Get whether all names are wrapped in quotation marks.\n\n \n force_quotation_marks( bool )\n\nC++: genesis::tree::NewickWriter::force_quotation_marks() const --> bool");
		cl.def("line_length", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(unsigned long)) &genesis::tree::NewickWriter::line_length, "Set the approximate maximal line length to use when writing Newick trees.\n\n Some large trees become hard to inspect in the resulting Newick file if the whole tree is\n written in just one long line. Also, some tools might not be able to handle such long lines\n properly. Hence, setting this option to a value other than 0 (default, which means, all\n is written in one line) leads to the writer inserting line breaks at the next possible\n character after the  line length has been reached. Hence, lines can be longer than\n the given value. Also, be aware that some other tools might not be able to read trees\n that are spread across several lines. Newick is messy.\n\nC++: genesis::tree::NewickWriter::line_length(unsigned long) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("line_length", (unsigned long (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::line_length, "Get the currently set approximate maximal line length.\n\n Default is 0, which means, all is written in one long line.\n\n \n line_length( size_t )\n\nC++: genesis::tree::NewickWriter::line_length() const --> unsigned long");
		cl.def("trailing_new_line", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::trailing_new_line, "Set whether to write a new line char `` at the end of each tree.\n\n By default, this is set to `true`, meaning that each tree is finished with a `` char,\n which is usually desirable when writing to Newick files or the like. However, in cases\n where the Newick string itself is used in some other format (e.g., jplace or nexus), this\n might not be wanted. Hence, we allow to disable the new line.\n\nC++: genesis::tree::NewickWriter::trailing_new_line(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("trailing_new_line", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::trailing_new_line, "Get the current setting for whether a new line char `` is written to the end\n of each tree.\n\n \n trailing_new_line( bool )\n\nC++: genesis::tree::NewickWriter::trailing_new_line() const --> bool");
		cl.def("write_names", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::write_names, "Set whether to write Newick node names.\n\n Default is `true`. This setting can be used to override any names that might be set by a\n plugin.\n\nC++: genesis::tree::NewickWriter::write_names(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("write_names", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::write_names, "Get whether Newick node names are written.\n\n \n write_names( bool )\n\nC++: genesis::tree::NewickWriter::write_names() const --> bool");
		cl.def("write_values", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::write_values, "Set whether to write Newick values (e.g., branch lengths).\n\n Default is `true`. This setting can be used to override any values that might be set by a\n plugin.\n\nC++: genesis::tree::NewickWriter::write_values(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("write_values", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::write_values, "Get whether Newick values (e.g., branch lengths) are written.\n\n \n write_values( bool )\n\nC++: genesis::tree::NewickWriter::write_values() const --> bool");
		cl.def("write_comments", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::write_comments, "Set whether to write Newick comments (e.g., some forms of bootstrap values).\n\n Default is `true`. This setting can be used to override any comments that might be set by a\n plugin.\n\nC++: genesis::tree::NewickWriter::write_comments(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("write_comments", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::write_comments, "Get whether Newick comments (e.g., some forms of bootstrap values) are written.\n\n \n write_comments( bool )\n\nC++: genesis::tree::NewickWriter::write_comments() const --> bool");
		cl.def("write_tags", (class genesis::tree::NewickWriter & (genesis::tree::NewickWriter::*)(bool)) &genesis::tree::NewickWriter::write_tags, "Set whether to write Newick tags (e.g., for `jplace` files).\n\n Default is `true`. This setting can be used to override any tags that might be set by a\n plugin. See NewickReader::enable_tags( bool ) for details on the inofficial Newick tags\n extension.\n\nC++: genesis::tree::NewickWriter::write_tags(bool) --> class genesis::tree::NewickWriter &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("write_tags", (bool (genesis::tree::NewickWriter::*)() const) &genesis::tree::NewickWriter::write_tags, "Get whether Newick tags (e.g., for `jplace` files) are written.\n\n \n write_tags( bool )\n\nC++: genesis::tree::NewickWriter::write_tags() const --> bool");
		cl.def("tree_to_broker", (class genesis::tree::NewickBroker (genesis::tree::NewickWriter::*)(const class genesis::tree::Tree &) const) &genesis::tree::NewickWriter::tree_to_broker, "Transform the information of the tree into a NewickBroker object.\n\nC++: genesis::tree::NewickWriter::tree_to_broker(const class genesis::tree::Tree &) const --> class genesis::tree::NewickBroker", pybind11::arg("tree"));
		cl.def("write", (void (genesis::tree::NewickWriter::*)(const class genesis::tree::NewickBroker &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>) const) &genesis::tree::NewickWriter::write, "Write a NewickBroker to an output target, in Newick format.\n\nC++: genesis::tree::NewickWriter::write(const class genesis::tree::NewickBroker &, class std::shared_ptr<class genesis::utils::BaseOutputTarget>) const --> void", pybind11::arg("broker"), pybind11::arg("target"));
	}
	{ // genesis::tree::CommonTreeNewickWriterPlugin file:genesis/tree/common_tree/newick_writer.hpp line:51
		pybind11::class_<genesis::tree::CommonTreeNewickWriterPlugin, std::shared_ptr<genesis::tree::CommonTreeNewickWriterPlugin>> cl(M("genesis::tree"), "CommonTreeNewickWriterPlugin", "Provide a set of plugin functions for NewickWriter to write a #CommonTree.");
		cl.def( pybind11::init( [](){ return new genesis::tree::CommonTreeNewickWriterPlugin(); } ) );
		cl.def( pybind11::init( [](genesis::tree::CommonTreeNewickWriterPlugin const &o){ return new genesis::tree::CommonTreeNewickWriterPlugin(o); } ) );
		cl.def("assign", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(const class genesis::tree::CommonTreeNewickWriterPlugin &)) &genesis::tree::CommonTreeNewickWriterPlugin::operator=, "C++: genesis::tree::CommonTreeNewickWriterPlugin::operator=(const class genesis::tree::CommonTreeNewickWriterPlugin &) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg(""));
		cl.def("default_leaf_name", (const std::string & (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name, "Get the named used to filter out a leaf node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("default_leaf_name", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(const std::string &)) &genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name, "Set the named used to filter out a leaf node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_leaf_name(const std::string &) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("default_inner_name", (const std::string & (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name, "Get the named used to filter out an inner node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("default_inner_name", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(const std::string &)) &genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name, "Set the named used to filter out an inner node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_inner_name(const std::string &) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("default_root_name", (const std::string & (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::default_root_name, "Get the named used to filter out the root node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_root_name() const --> const std::string &", pybind11::return_value_policy::reference_internal);
		cl.def("default_root_name", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(const std::string &)) &genesis::tree::CommonTreeNewickWriterPlugin::default_root_name, "Set the named used to filter out the root node name.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::default_root_name(const std::string &) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("set_default_names", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(const std::string &)) &genesis::tree::CommonTreeNewickWriterPlugin::set_default_names, "Shorthand to set the default names for leaf, inner and root node at once, to one\n value.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::set_default_names(const std::string &) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("use_default_names", (bool (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::use_default_names, "Return whether currently default names are activated in this plugin.\n\n See the setter use_default_names( bool ) for details.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::use_default_names() const --> bool");
		cl.def("use_default_names", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(bool)) &genesis::tree::CommonTreeNewickWriterPlugin::use_default_names, "Set whether to replace default named nodes with an empty string.\n\n This setting activates the \"reverse\" operation of\n CommonTreeNewickReaderPlugin::use_default_names( bool ).\n Thus, when the default names are set to the same values as in the reader plugin, reading a\n Newick tree and then writing it again should yield the same names in the Newick tree again.\n\n Common is `false`. In this case, all node names are written to the Newick tree, indepentenly\n of whether they match the default names.\n\n If set to `true`, a node that has one of the default names will result in an empty node\n name in the Newick tree:\n\n  * Leaf nodes with a name equal to default_leaf_name().\n  * Inner nodes with a name equal to default_inner_name().\n  * The root node with a name equal to default_root_name().\n\n These default names can be changed by using default_leaf_name( std::string const& ),\n default_inner_name( std::string const& ) and default_root_name( std::string const& ),\n or by using set_default_names( std::string const& ) to set all three at once.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::use_default_names(bool) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("replace_invalid_chars", (bool (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::replace_invalid_chars, "Return whether currently this plugin replaces characters that are invalid in the\n Newick file format with underscores.\n\n See the setter replace_invalid_chars( bool ) for details.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::replace_invalid_chars() const --> bool");
		cl.def("replace_invalid_chars", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(bool)) &genesis::tree::CommonTreeNewickWriterPlugin::replace_invalid_chars, "Set whether to replace all characters that are invalid in the\n Newick file format in names with underscores ('_').\n\n This is the reverse of CommonTreeNewickReaderPlugin::replace_name_underscores(),\n in that it replaces spaces with underscores,\n but also handles other invalid characters `:;()[],={}\"` that cannot be used in Newick labels,\n see http://evolution.genetics.washington.edu/phylip/newicktree.html.\n See also NewickWriter for similar options.\n\n It is activated by default, as this makes sure that other software can handle the names.\n However, as these characters cannot be part of names in Newick, if it is deactivated\n (set to `false`), all names that contain any of these characters are instead wrapped in\n quotation marks by the NewickWriter, see NewickWriter::quotation_marks( std::string const& )\n for details. This does not work well with many other tools which cannot read these quoted\n names; we hence recommend to keept it at default, and replace all invalid characters.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::replace_invalid_chars(bool) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("enable_names", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(bool)) &genesis::tree::CommonTreeNewickWriterPlugin::enable_names, "Set whether to write node names at all.\n\n If disabled, no names are written for any node.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::enable_names(bool) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("enable_names", (bool (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::enable_names, "Get whether currently any node names are written at all.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::enable_names() const --> bool");
		cl.def("enable_branch_lengths", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(bool)) &genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths, "Set whether to write branch lengths.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths(bool) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("enable_branch_lengths", (bool (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths, "Get whether currently any branch lengths are written.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::enable_branch_lengths() const --> bool");
		cl.def("branch_length_precision", (int (genesis::tree::CommonTreeNewickWriterPlugin::*)() const) &genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision, "Get the currently set maximum precision (in number of digits) used for printing the\n `branch_length` floating point numbers.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision() const --> int");
		cl.def("branch_length_precision", (class genesis::tree::CommonTreeNewickWriterPlugin & (genesis::tree::CommonTreeNewickWriterPlugin::*)(int)) &genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision, "Set the maximum precision (in number of digits) used for printing the `branch_length`\n floating point numbers.\n\n Common is 6.\n\nC++: genesis::tree::CommonTreeNewickWriterPlugin::branch_length_precision(int) --> class genesis::tree::CommonTreeNewickWriterPlugin &", pybind11::return_value_policy::reference_internal, pybind11::arg("value"));
		cl.def("node_to_element", (void (genesis::tree::CommonTreeNewickWriterPlugin::*)(const class genesis::tree::TreeNode &, struct genesis::tree::NewickBrokerElement &) const) &genesis::tree::CommonTreeNewickWriterPlugin::node_to_element, "C++: genesis::tree::CommonTreeNewickWriterPlugin::node_to_element(const class genesis::tree::TreeNode &, struct genesis::tree::NewickBrokerElement &) const --> void", pybind11::arg("node"), pybind11::arg("element"));
		cl.def("edge_to_element", (void (genesis::tree::CommonTreeNewickWriterPlugin::*)(const class genesis::tree::TreeEdge &, struct genesis::tree::NewickBrokerElement &) const) &genesis::tree::CommonTreeNewickWriterPlugin::edge_to_element, "C++: genesis::tree::CommonTreeNewickWriterPlugin::edge_to_element(const class genesis::tree::TreeEdge &, struct genesis::tree::NewickBrokerElement &) const --> void", pybind11::arg("edge"), pybind11::arg("element"));
		cl.def("register_with", (void (genesis::tree::CommonTreeNewickWriterPlugin::*)(class genesis::tree::NewickWriter &) const) &genesis::tree::CommonTreeNewickWriterPlugin::register_with, "C++: genesis::tree::CommonTreeNewickWriterPlugin::register_with(class genesis::tree::NewickWriter &) const --> void", pybind11::arg("writer"));
	}
}
