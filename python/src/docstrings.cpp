/**
* @brief Documentation strings for the Python module.
 *
 * @file
 * @ingroup python
 */

#include <src/common.hpp>

#include <map>
#include <string>

static std::map<std::string, std::string> doc_strings_ = {
    // Class JplaceReader
    {"static bool ::genesis::placement::JplaceReader::check_version (size_t version)", "Checks whether the version of the jplace format works with this parser.\n\nThis parser is intended for jplace versions 2 and 3. If while reading a different version tag is found, the reader will trigger a warning and try to continue anyway."},
    {"static bool ::genesis::placement::JplaceReader::check_version (std::string const & version)", "Checks whether the version of the jplace format works with this parser.\n\nThis parser is intended for jplace versions 2 and 3. If while reading a different version tag is found, the reader will trigger a warning and try to continue anyway."},
    {"Sample ::genesis::placement::JplaceReader::from_document (utils::JsonDocument & doc) const", "Take a JsonDocument and parse it as a Jplace document into a Sample."},
    {"Sample ::genesis::placement::JplaceReader::from_file (std::string const & fn) const", "Read a file and parse it as a Jplace document into a Sample."},
    {"SampleSet ::genesis::placement::JplaceReader::from_files (std::vector< std::string > const & fns) const", "Read a list of files and parse them as a Jplace document into a SampleSet."},
    {"void ::genesis::placement::JplaceReader::from_files (std::vector< std::string > const & fns, SampleSet & set) const", "Read a list of files and parse them as a Jplace document into a SampleSet.\n\nThe Samples are added to the SampleSet, so that existing Samples in the SampleSet are kept."},
    {"Sample ::genesis::placement::JplaceReader::from_stream (std::istream & is) const", "Read jplace data from a stream into a Sample."},
    {"Sample ::genesis::placement::JplaceReader::from_string (std::string const & jplace) const", "Parse a string as a Jplace document into a Sample."},
    {"SampleSet ::genesis::placement::JplaceReader::from_strings (std::vector< std::string > const & jps) const", "Parse a list of strings as a Jplace document into a SampleSet."},
    {"void ::genesis::placement::JplaceReader::from_strings (std::vector< std::string > const & jps, SampleSet & set) const", "Parse a list of strings as a Jplace document into a SampleSet.\n\nThe Samples are added to the SampleSet, so that existing Samples in the SampleSet are kept."},
    {"InvalidNumberBehaviour ::genesis::placement::JplaceReader::invalid_number_behaviour () const", "Return the currenlty set InvalidNumberBehaviour."},
    {"JplaceReader & ::genesis::placement::JplaceReader::invalid_number_behaviour (InvalidNumberBehaviour val)", "Set the InvalidNumberBehaviour.\n\nThis setter controls the InvalidNumberBehaviour of the JplaceReader. The default value is InvalidNumberBehaviour::kIgnore. See InvalidNumberBehaviour for the valid options.The function returns the JplaceReader object to allow for a fluent interface."},
    {"static std::string ::genesis::placement::JplaceReader::version ()", "Returns the version number that this class is written for. Currently, this is \"3\"."},

    // Class JplaceWriter
    {"size_t ::genesis::placement::JplaceWriter::branch_length_precision () const", "Get the precision used for printing the branch_length floating point numbers of the reference Tree of the Sample."},
    {"JplaceWriter & ::genesis::placement::JplaceWriter::branch_length_precision (size_t value)", "Set the precision used for printing the branch_length floating point numbers of the reference Tree of the Sample."},
    {"void ::genesis::placement::JplaceWriter::to_document (Sample const & smp, utils::JsonDocument & doc) const", "Store the data of a Sample in a JsonDocument object.\n\nThis method is not really useful anymore, as we can now directly write to files, strings and streams. It is however kept here for reference and in case someone wants to work with Json files directly."},
    {"void ::genesis::placement::JplaceWriter::to_file (Sample const & smp, std::string const & filename) const", "Write the data of a Sample to a file in Jplace format.\n\nIf the file already exists or cannot be written to, the function throws std::runtime_error."},
    {"void ::genesis::placement::JplaceWriter::to_stream (Sample const & smp, std::ostream & os) const", "Write a Sample to a stream, using the Jplace format."},
    {"void ::genesis::placement::JplaceWriter::to_string (Sample const & smp, std::string & output) const", "Store the data of a Sample in a string in Jplace format."},
    {"std::string ::genesis::placement::JplaceWriter::to_string (Sample const & smp) const", "Return the data of a Sample as a string in Jplace format."},

    // Class PlacementEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::placement::PlacementEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"int ::genesis::placement::PlacementEdgeData::edge_num () const", "Return the edge_num of this edge. This value is defined by the jplace standard."},
    {"void ::genesis::placement::PlacementEdgeData::reset_edge_num (int val)", "Force to set the edge_num to a certain value.\n\nThe edge_num is usually considered to be constant for the tree. It rarely needs to be set, except for when constructing the object. Use with care."},

    // Class PlacementNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::placement::PlacementNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class PlacementTreeNewickReaderMixin

    // Class PlacementTreeNewickWriterMixin

    // Class Pquery
    {"PqueryName & ::genesis::placement::Pquery::add_name (std::string name="", double multiplicity=1.0)", "Create a new PqueryName using the provided parameters, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryName & ::genesis::placement::Pquery::add_name (PqueryName const & other)", "Create a new PqueryName as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where names are stored, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it.\n\nThe values of the placement can then be adjusted using the returned object reference.It is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PqueryPlacement const & val)", "Create a new PqueryPlacement as a copy of the provided one, add it to the Pquery and return it.\n\nAs this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"PqueryPlacement & ::genesis::placement::Pquery::add_placement (PlacementTreeEdge & edge, PqueryPlacement const & val)", "Create a new PqueryPlacement at a given PlacementTreeEdge, add it to the Pquery and return it. The property values of the provided PqueryPlacement are copied.\n\nIt is important that the provided edge belongs to the same PlacementTree as the Pquery and its containing Sample do. This is up to the user and not checked.As this function might reallocate the memory where placements are stored, all iterators and pointer to PqueryPlacements are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::clear ()", "Clear all data stored in this Pquery, i.e., clear all PqueryNames and all PqueryPlacements."},
    {"void ::genesis::placement::Pquery::clear_names ()", "Delete all PqueryNames of this Pquery."},
    {"void ::genesis::placement::Pquery::clear_placements ()", "Delete all PqueryPlacements of this Pquery."},
    {"PqueryName & ::genesis::placement::Pquery::name_at (size_t index)", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"PqueryName const & ::genesis::placement::Pquery::name_at (size_t index) const", "Return the PqueryName at a certain index.\n\nThe index must be smaller than name_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::name_size () const", "Return the number of PqueryNames stored in this Pquery."},
    {"utils::Range< iterator_names > ::genesis::placement::Pquery::names ()", "Return a Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_names > ::genesis::placement::Pquery::names () const", "Return a const Range iterator to the PqueryNames.\n\nThis makes iterating placements via a range based for loop easy."},
    {"PqueryPlacement & ::genesis::placement::Pquery::placement_at (size_t index)", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"PqueryPlacement const & ::genesis::placement::Pquery::placement_at (size_t index) const", "Return the PqueryPlacement at a certain index.\n\nThe index must be smaller than placement_size(), otherwise this functions throws an exception."},
    {"size_t ::genesis::placement::Pquery::placement_size () const", "Return the number of PqueryPlacements stored in this Pquery."},
    {"utils::Range< iterator_placements > ::genesis::placement::Pquery::placements ()", "Return a Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"utils::Range< const_iterator_placements > ::genesis::placement::Pquery::placements () const", "Return a const Range iterator to the PqueryPlacements.\n\nThis makes iterating placements via a range based for loop easy."},
    {"void ::genesis::placement::Pquery::remove_name_at (size_t index)", "Remove the PqueryName at a certain index position within this Pquery.\n\nAs this function moves names in the container, all iterators and pointer to PqueryNamess are considered to be invalidated."},
    {"void ::genesis::placement::Pquery::remove_placement_at (size_t index)", "Remove the PqueryPlacement at a certain index position within this Pquery.\n\nAs this function moves placements in the container, all iterators and pointer to PqueryPlacements are considered to be invalidated."},

    // Class PqueryName

    // Class PqueryPlacement
    {"const PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge () const", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"PlacementTreeEdge & ::genesis::placement::PqueryPlacement::edge ()", "Get the PlacementTreeEdge where this PqueryPlacement is placed."},
    {"int ::genesis::placement::PqueryPlacement::edge_num () const", "Get the edge_num where this PqueryPlacement is placed.\n\nThis number corresponds to the edge_num property as described in the jplace standard. It is not to be confused with the index of the PlacementTreeEdge."},
    {"void ::genesis::placement::PqueryPlacement::reset_edge (PlacementTreeEdge & edge)", "Set the PlacementTreeEdge at which this PqueryPlacement is placed.\n\nThis should be rarely needed. It is mostly intended for the Readers that populate the data. When setting this value, the user is responsible to make sure that the new value is actually a PlacementTreeEdge of the PlacementTree that belongs to the Sample where the Pquery of this PqueryPlacement is stored."},

    // Class PqueryPlacementPlain

    // Class PqueryPlain

    // Class Sample
    {"Pquery & ::genesis::placement::Sample::add ()", "Create an empty Pquery, add it to the Sample and return it.\n\nThe returned reference can then be used to add PqueryPlacements and PqueryNames to the Pquery.As this function might reallocate the memory where Pqueries are stored, all iterators and pointers to the Pqueries of this Sample are invalidated."},
    {"Pquery & ::genesis::placement::Sample::add (Pquery const & other)", "Create a Pquery as a copy of the provided one, add it to the sample and return it.\n\nIt is possible to provide a Pquery from a different Sample, as long as the tree topology of both Samples is identical, including identical edge indices  and edge_nums. For that purpose, this function automatically adjusts the internal pointers of the Pquery and its PqueryPlacements accordingly. Furthermore, the proximal_length is also adjusted so that the relative position on the edge maintained.However, if the trees are incompatible (i.e., have a different topology, indices or edge nums), the PqueryPlacements will either point to different edges or the function might throw an exception, in cases where the tree does not have a corresponding edge at all. To further ensure correct behaviour, the function also checks whether the edge_num  is the same for the edge of the original PqueryPlacement and the new one, and throws an std::runtime_error if not.As this function might reallocate the memory where Pqueries are stored, all iterators and pointers to the Pqueries of this Sample are invalidated."},
    {"Pquery & ::genesis::placement::Sample::at (size_t index)", "Return the Pquery at a certain index."},
    {"Pquery const & ::genesis::placement::Sample::at (size_t index) const", "Return the Pquery at a certain index."},
    {"void ::genesis::placement::Sample::clear ()", "Clears all data of this object.\n\nThe Pqueries , the PlacementTree and the metadata are deleted."},
    {"void ::genesis::placement::Sample::clear_pqueries ()", "Clear all Pqueries  of this Sample.\n\nAll Pqueries are deleted. However, the PlacementTree and the metadata are left as they are. Thus this is a useful method for e.g., simulating placements: Take a copy of a given sample, clear its Pqueries, then generate new ones using the Simulator."},
    {"bool ::genesis::placement::Sample::empty () const", "Return whether the tree or the set of Pqueries is empty."},
    {"utils::Range< iterator_pqueries > ::genesis::placement::Sample::pqueries ()", "Return a Range iterator to the Pqueries .\n\nThis makes iterating Pqueries via a range based for loop easy."},
    {"utils::Range< const_iterator_pqueries > ::genesis::placement::Sample::pqueries () const", "Return a const Range iterator to the Pqueries .\n\nThis makes iterating Pqueries via a range based for loop easy."},
    {"void ::genesis::placement::Sample::remove (size_t index)", "Remove the Pquery at a given index from the Sample.\n\nAs this function might reallocate the memory where Pqueries are stored, all iterators and pointer to the Pqueries of this Sample are invalidated."},
    {"void ::genesis::placement::Sample::remove (size_t first_index, size_t last_index)", "Remove the Pqueries  between the first_index (inclusive) and the last_index (exclusive) from the Sample."},
    {"void ::genesis::placement::Sample::remove (iterator_pqueries position)", "Remove the Pquery at a given iterator position from the Sample."},
    {"void ::genesis::placement::Sample::remove (iterator_pqueries first, iterator_pqueries last)", "Remove the Pqueries  between the first (inclusive) and the last (exclusive) iterator position from the Sample."},
    {"size_t ::genesis::placement::Sample::size () const", "Return the number of Pqueries  that are stored in this Sample."},
    {"void ::genesis::placement::Sample::swap (Sample & other)", "Swap the contents of this Sample with the contents of another Sample."},
    {"PlacementTree & ::genesis::placement::Sample::tree ()", "Get the PlacementTree of this Sample."},
    {"PlacementTree const & ::genesis::placement::Sample::tree () const", "Get the PlacementTree of this Sample."},

    // Class SampleSerializer
    {"static Sample ::genesis::placement::SampleSerializer::load (std::string const & file_name)", "Loads a Sample from a binary file that was written by using save()."},
    {"static void ::genesis::placement::SampleSerializer::save (Sample const & map, std::string const & file_name)", "Saves the Sample to a binary file that can later be read by using load()."},

    // Class SampleSet
    {"void ::genesis::placement::SampleSet::add (Sample const & smp)", "Add a Sample to the SampleSet.\n\nThe Sample is copied. The name is set to empty string."},
    {"void ::genesis::placement::SampleSet::add (Sample const & smp, std::string const & name)", "Add a Sample with a name to the SampleSet.\n\nThe Sample is copied."},
    {"NamedSample & ::genesis::placement::SampleSet::at (size_t index)", "Get the NamedSample at a certain index position."},
    {"const NamedSample & ::genesis::placement::SampleSet::at (size_t index) const", "Get the NamedSample at a certain index position."},
    {"void ::genesis::placement::SampleSet::clear ()", "Delete all Samples in this SampleSet."},
    {"bool ::genesis::placement::SampleSet::empty () const", "Return whether the SampleSet is empty."},
    {"void ::genesis::placement::SampleSet::remove_at (size_t index)", "Remove the Sample at a certain index position.\n\nAs this function moves Samples in the container around, all iterators and pointers to the elements of this SampleSet are considered to be invalidated."},
    {"size_t ::genesis::placement::SampleSet::size () const", "Return the size of the SampleSet, i.e., the number of Samples."},

    // Class Simulator
    {"void ::genesis::placement::Simulator::generate (Sample & sample, size_t n)", "Generate n many Pqueries and place them in the Sample."},

    // Class SimulatorEdgeDistribution
    {"size_t ::genesis::placement::SimulatorEdgeDistribution::generate ()", "Return a randomly chosen edge index, according to the distribution."},
    {"void ::genesis::placement::SimulatorEdgeDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorExtraPlacementDistribution
    {"void ::genesis::placement::SimulatorExtraPlacementDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate().\n\nIt expects to be called with the Sample into which the generated (simulated) placements are inserted."},

    // Class SimulatorLikeWeightRatioDistribution
    {"double ::genesis::placement::SimulatorLikeWeightRatioDistribution::generate ()", "Return a randomly chosen like weight ratio."},
    {"void ::genesis::placement::SimulatorLikeWeightRatioDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorPendantLengthDistribution
    {"double ::genesis::placement::SimulatorPendantLengthDistribution::generate (PlacementTreeEdge const & edge)", "Return a randomly chosen position on an edge."},
    {"void ::genesis::placement::SimulatorPendantLengthDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class SimulatorProximalLengthDistribution
    {"double ::genesis::placement::SimulatorProximalLengthDistribution::generate (PlacementTreeEdge const & edge)", "Return a randomly chosen position on an edge."},
    {"void ::genesis::placement::SimulatorProximalLengthDistribution::prepare (Sample const & sample)", "Prepare the distribution for usage. Needs to be called before generate()."},

    // Class NamedSample

    // Class EdgeProximity

    // Class FastaInputIterator
    {"FastaReader & ::genesis::sequence::FastaInputIterator::reader ()", "Return the FastaReader used for this iterator.\n\nUse this to change the reading behaviour of the iterator. See FastaReader for details."},

    // Class FastaOutputIterator
    {"FastaWriter & ::genesis::sequence::FastaOutputIterator::writer ()", "Return the FastaWrtier used for this iterator.\n\nUse this to change the writing behaviour of the iterator. See FastaWriter for details."},

    // Class FastaReader
    {"void ::genesis::sequence::FastaReader::from_file (std::string const & file_name, SequenceSet & sequence_set) const", "Read all Sequences from a file in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_file (std::string const & file_name) const", "Read all Sequences from a file in Fasta format and return them as a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_stream (std::istream & input_stream, SequenceSet & sequence_set) const", "Read all Sequences from a std::istream in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_stream (std::istream & input_stream) const", "Read all Sequences from a std::istream in Fasta format and return them as a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::from_string (std::string const & input_string, SequenceSet & sequence_set) const", "Read all Sequences from a std::string in Fasta format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::FastaReader::from_string (std::string const & input_string) const", "Read all Sequences from a std::string in Fasta format and return them as a SequenceSet."},
    {"void ::genesis::sequence::FastaReader::parse_document (utils::InputStream & input_stream, SequenceSet & sequence_set) const", "Parse a whole fasta document into a SequenceSet.\n\nThis function is mainly used internally by the reading functions from_...(). It uses the currently set parsing_method() for parsing the data."},
    {"bool ::genesis::sequence::FastaReader::parse_sequence (utils::InputStream & input_stream, Sequence & sequence) const", "Parse a Sequence in Fasta format.\n\nThis function takes an InputStream and interprets it as a Fasta formatted sequence. It extracts the data and writes it into the given Sequence object. See the class description of FastaReader for the expected data format.The function stops after parsing one such sequence. It returns true if a sequence was extracted and false if the stream is empty. If the input is not in the correct format, an std::runtime_error exception is thrown indicating the malicious position in the input stream.This method has a maximum line length of utils::InputStream::BlockLength and reports errors only on the line where the sequence starts. If you have files with longer lines or want error reporting at the exact line and column where the error occurs, use ParsingMethod::kPedantic instead. See FastaReader::ParsingMethod for details."},
    {"bool ::genesis::sequence::FastaReader::parse_sequence_pedantic (utils::InputStream & input_stream, Sequence & sequence) const", "Parse a Sequence in Fasta format.\n\nThis function takes an InputStream and interprets it as a Fasta formatted sequence. It extracts the data and writes it into the given Sequence object. See the class description of FastaReader for the expected data format.The function stops after parsing one such sequence. It returns true if a sequence was extracted and false if the stream is empty. If the input is not in the correct format, an std::runtime_error exception is thrown indicating the malicious position in the input stream.Compared to parse_sequence(), this function allows for arbitrarily long lines and reports errors at the exact line and column where they occur. It is however slower. Apart from that, there are no differences. See FastaReader::ParsingMethod for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::parsing_method (ParsingMethod value)", "Set the parsing method.\n\nThe parsing method is used for all the reader functions and parse_document(). See the ParsingMethod enum for details."},
    {"ParsingMethod ::genesis::sequence::FastaReader::parsing_method () const", "Return the currently set parsing method.\n\nSee the ParsingMethod enum for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::to_upper (bool value)", "Set whether Sequence sites are automatically turned into upper case.\n\nIf set to true (default), all sites of the read Sequences are turned into upper case letters automatically. This is demanded by the Fasta standard. The function returns the FastaReader object to allow for fluent interfaces."},
    {"bool ::genesis::sequence::FastaReader::to_upper () const", "Return whether Sequence sites are automatically turned into upper case."},
    {"utils::CharLookup< bool > & ::genesis::sequence::FastaReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the valid_chars() function should suffice. See there for details."},
    {"FastaReader & ::genesis::sequence::FastaReader::valid_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. That is, only sequences consisting of the given chars are valid.If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that to_upper() is set to true: The validation is done after making the char upper case, so that only capital letters have to be provided for validation. In case that to_upper() is set to false: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::FastaReader::valid_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nAn empty string means that no validation is done."},

    // Class FastaWriter
    {"FastaWriter & ::genesis::sequence::FastaWriter::enable_metadata (bool value)", "Set whether metadata is written.\n\nIf set to true (default), the metadata of the Sequences is written after the label, separated by a space. This is also the format that FastaReader can read.The functions returns the FastaWriter object to allow fluent interfaces."},
    {"bool ::genesis::sequence::FastaWriter::enable_metadata ()", "Return whether currently the FastaWriter is set to write metadata.\n\nSee the setter enable_metadata( bool ) for details."},
    {"FastaWriter & ::genesis::sequence::FastaWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Fasta file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the FastaWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::FastaWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length() for details."},
    {"void ::genesis::sequence::FastaWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file in Fasta format."},
    {"void ::genesis::sequence::FastaWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream in Fasta format."},
    {"std::string ::genesis::sequence::FastaWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Fasta formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},
    {"void ::genesis::sequence::FastaWriter::write_sequence (Sequence const & seq, std::ostream & os) const", "Write a single Sequence to an output stream in Fasta format."},

    // Class PhylipReader
    {"void ::genesis::sequence::PhylipReader::from_file (std::string const & file_name, SequenceSet & sequence_set) const", "Read all Sequences from a file in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_file (std::string const & file_name) const", "Read all Sequences from a file in Phylip format and return them as a SequenceSet."},
    {"void ::genesis::sequence::PhylipReader::from_stream (std::istream & input_stream, SequenceSet & sequence_set) const", "Read all Sequences from a std::istream in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet.This function is only allowed for Mode::kSequential and Mode::kInterleaved. Automatic mode does not work, as the stream might need to be reset, which is not possible. See mode(Mode) for details."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_stream (std::istream & input_stream) const", "Read all Sequences from a std::istream in Phylip format and return them as a SequenceSet.\n\nThis function is only allowed for Mode::kSequential and Mode::kInterleaved. Automatic mode does not work, as the stream might need to be reset, which is not possible. See mode(Mode) for details."},
    {"void ::genesis::sequence::PhylipReader::from_string (std::string const & input_string, SequenceSet & sequence_set) const", "Read all Sequences from a std::string in Phylip format into a SequenceSet.\n\nThe Sequences are added to the SequenceSet, whose existing Sequences are kept. Thus, by repeatedly calling this or similar read functions, multiple input files can easily be read into one SequenceSet."},
    {"SequenceSet ::genesis::sequence::PhylipReader::from_string (std::string const & input_string) const", "Read all Sequences from a std::string in Phylip format and return them as a SequenceSet."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to a value greater than 0, exaclty this many characters are read as label. Thus, they can also contain spaces. Spaces at the beginning or end of a label are stripped. The length that is dictated by the Phylip standard is 10, but any other length can also be used.If set to 0 (default), a relaxed version of Phylip is used instead, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. However, in this case, there has to be at least one space or tab character between the label and the sequence. After the whitespace(s), the rest of the line is then treated as sequence data.The function returns the PhylipReader object to allow for fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipReader::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::mode (Mode value)", "Set the mode for reading sequences.\n\nPhylip offers two variants for storing the sequences: sequential and interleaved. As there is no option or flag in the file itself, there is no chance of knowing the variant without trying to parse it. If one fails but not the other, it is proabably the latter variant. However, there are instances where both variants are valid at the same time, but yield different sequences. So, in general detecting the correct variant is undecidable, making Phylip a non-well-defined format.In order to avoid those problems, this function explicitly sets the variant being used for parsing. By default, it is set to Mode::kSequential. Use Mode::kInterleaved for the other variant.We also offer a Mode::kAutomatic. It first tries to parse in sequential mode, and, if this fails, in interleaved mode. However, as this might involve starting from the beginning of the data, this is only possible with the from_file() and from_string() readers and does not work when using the from_stream() reader. Also, be aware that using automatic mode is slower because of implementation details induced by those limitations. Try to avoid automatic mode. If possible, try to avoid Phylip at all."},
    {"Mode ::genesis::sequence::PhylipReader::mode () const", "Return the currently set mode for parsing Phylip.See the setter mode( Mode ) for details."},
    {"Header ::genesis::sequence::PhylipReader::parse_phylip_header (utils::InputStream & it) const", "Parse a Phylip header and return the contained sequence count and length.\n\nThis helper function expects to find a Phylip header line in the form x y, which describes the number of sequences x in the Phylip data and their length y. The remainder of the header line is interpreted as Phylip options. See Header struct for more information.The function then advances the stream and skips potential empty lines after the header. It thus leaves the stream at the beginning of the first sequence line."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_interleaved (utils::InputStream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the sequential variant (Mode::kSequential)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_label (utils::InputStream & it) const", "Parse and return a Phylip label.\n\nThis helper functions either takes the first label_length chars as a label or, if label_length == 0 takes all chars until the first blank as label. It returns the trimmed label and leaves the stream at the next char after the label (and after subsequent blanks)."},
    {"std::string ::genesis::sequence::PhylipReader::parse_phylip_sequence_line (utils::InputStream & it) const", "Parse one sequence line.\n\nThe line (which can also start after a label) is parsed until the first '\\n' char. While parsing, the options to_upper() and valid_chars() are applied according to their settings. The stream is left at the beginning of the next line."},
    {"void ::genesis::sequence::PhylipReader::parse_phylip_sequential (utils::InputStream & it, SequenceSet & sset) const", "Parse a whole Phylip file using the interleaved variant (Mode::kInterleaved)."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::to_upper (bool value)", "Set whether Sequence sites are automatically turned into upper case.\n\nIf set to true (default), all sites of the read Sequences are turned into upper case letters automatically. This is demanded by the Phylip standard.The function returns the PhylipReader object to allow for fluent interfaces."},
    {"bool ::genesis::sequence::PhylipReader::to_upper () const", "Return whether Sequence sites are automatically turned into upper case."},
    {"utils::CharLookup< bool > & ::genesis::sequence::PhylipReader::valid_char_lookup ()", "Return the internal CharLookup that is used for validating the Sequence sites.\n\nThis function is provided in case direct access to the lookup is needed. Usually, the valid_chars() function should suffice. See there for details."},
    {"PhylipReader & ::genesis::sequence::PhylipReader::valid_chars (std::string const & chars)", "Set the chars that are used for validating Sequence sites when reading them.\n\nWhen this function is called with a string of chars, those chars are used to validate the sites when reading them. That is, only sequences consisting of the given chars are valid.If set to an empty string, this check is deactivated. This is also the default, meaning that no checking is done.In case that to_upper() is set to true: The validation is done after making the char upper case, so that only capital letters have to be provided for validation. In case that to_upper() is set to false: All chars that are to be considered valid have to be provided for validation.See nucleic_acid_codes...() and amino_acid_codes...() functions for presettings of chars that can be used for validation here."},
    {"std::string ::genesis::sequence::PhylipReader::valid_chars () const", "Return the currently set chars used for validating Sequence sites.\n\nAn empty string means that no validation is done."},

    // Class PhylipWriter
    {"PhylipWriter & ::genesis::sequence::PhylipWriter::label_length (size_t value)", "Set the length of the label in front of the sequences.\n\nPhylip has the weird property that labels are written in front of sequences and do not need to have a delimiter, but instead are simply the first n characters of the string. This value determines after how many chars the label ends and the actual sequence begins.If set to 0 (default), a relaxed version of Phylip is used, where the sequence begin is automatically detected. Labels can then be of arbitrary lengths, as long as they do not contain white spaces. After the label, a space is appended.If set to a value greater than 0, the label will be cut off after that many chars. For shorter labels, the remaining number is filled with spaces. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::label_length () const", "Return the currently set label length.\n\nSee the setter label_length( size_t ) for details."},
    {"PhylipWriter & ::genesis::sequence::PhylipWriter::line_length (size_t value)", "Set the line length, which determines after how many chars (Sequence sites) lines breaks are inserted when writing the Phylip file.\n\nDefault is 80. If set to 0, no breaks are inserted. The functions returns the PhylipWriter object to allow fluent interfaces."},
    {"size_t ::genesis::sequence::PhylipWriter::line_length () const", "Get the current line length.\n\nSee the setter line_length( size_t ) for details."},
    {"void ::genesis::sequence::PhylipWriter::to_file (SequenceSet const & sset, std::string const & fn) const", "Write Sequences of a SequenceSet to a file in Phylip format."},
    {"void ::genesis::sequence::PhylipWriter::to_stream (SequenceSet const & sset, std::ostream & os) const", "Write Sequences of a SequenceSet to a stream in Phylip format."},
    {"std::string ::genesis::sequence::PhylipWriter::to_string (SequenceSet const & sset) const", "Return Sequences of a SequenceSet in form of a Phylip formatted string.\n\nCaveat: This might be a long string! If you simply want to examine a Sequence or SequenceSet, have a look at the print() and print_color() functions."},

    // Class PrinterBitmap
    {"PrinterBitmap & ::genesis::sequence::PrinterBitmap::color_map (std::map< char, utils::Color > value)", "Set the list of Colors to use for the Sequence charaters.\n\nThe provided map sets the colors for each Sequence character. The presettings nucleic_acid_colors() and amino_acid_colors() for default sequence types can be used as input for this parameter. If the colors map does not contain a key for one of the chars in the sequence, the char is printed in black."},
    {"std::map< char, utils::Color > const & ::genesis::sequence::PrinterBitmap::color_map () const", "Get the currently set list of Colors for each Sequence character.\n\nSee the setter for details."},

    // Class PrinterSimple
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::color_map (std::map< char, std::string > value)", "Set the list of colors to use for the Sequence charaters.\n\nThe provided map sets the color name for each Sequence character. The presettings nucleic_acid_text_colors() and amino_acid_text_colors() for default sequence types can be used as input for this parameter. If the colors map does not contain a key for one of the chars in the sequence, the char is printed without color.See color_mode() for more details. See utils::Style for details and for a list of the available color names."},
    {"std::map< char, std::string > ::genesis::sequence::PrinterSimple::color_map () const", "Get the currently set list of colors for each Sequence character.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::color_mode (ColorMode value)", "Set whether to use color in the background, foreground, or not at all.\n\nSee ColorMode for details."},
    {"ColorMode ::genesis::sequence::PrinterSimple::color_mode () const", "Get the currently set color mode.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::label_mode (LabelMode value)", "Set the currently set LabelMode.\n\nSee LabelMode for more information."},
    {"LabelMode ::genesis::sequence::PrinterSimple::label_mode () const", "Get the currently set LabelMode.\n\nSee the setter and LabelMode for more information."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::length_limit (size_t value)", "Set the length limit for printing Sequences.\n\nThis parameter limits the output length to the give number of chars. If set to 0, the whole Sequence is printed (default). If the limit is lower than the acutal number of sites in the Sequence, ellipsis \" ...\" are appended."},
    {"size_t ::genesis::sequence::PrinterSimple::length_limit () const", "Get the currently set length limit.\n\nSee the setter for details."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::line_length (size_t value)", "Set the length of each link, i.e., when to wrap.\n\nIf this parameter is set to a value other than 0, the Sequence is wrapped at this line length. This also works in combination with length_limit()."},
    {"size_t ::genesis::sequence::PrinterSimple::line_length () const", "Get the currently set line length, i.e., when to wrap.\n\nSee the setter for details."},
    {"void ::genesis::sequence::PrinterSimple::print (std::ostream & out, Sequence const & seq) const", "Print a single Sequence to a stream."},
    {"void ::genesis::sequence::PrinterSimple::print (std::ostream & out, SequenceSet const & set) const", "Print a SequenceSet to a stream."},
    {"std::string ::genesis::sequence::PrinterSimple::print (Sequence const & seq) const", "Return a string representing the print of a single Sequence."},
    {"std::string ::genesis::sequence::PrinterSimple::print (SequenceSet const & set) const", "Return a string representing the print of a SequenceSet."},
    {"PrinterSimple & ::genesis::sequence::PrinterSimple::sequence_limit (size_t value)", "Set the limit for how many Sequences to print.\n\nIf this parameter is set to a value other than 0, only this number of Sequences are printed. Default is 0, thus, all Sequences are printed. If the given limit is lower than the acutal number of Sequences in the SequenceSet, ellipsis \" ...\" are appended."},
    {"size_t ::genesis::sequence::PrinterSimple::sequence_limit () const", "Get the currently set limit for how many Sequences to print.\n\nSee the setter for details."},

    // Class Sequence
    {"size_t ::genesis::sequence::Sequence::length () const", "Return the length (number of sites) of this sequence."},
    {"size_t ::genesis::sequence::Sequence::size () const", "Alias for length()."},

    // Class SequenceCounts
    {"CountsIntType ::genesis::sequence::SequenceCounts::added_sequences_count () const", "Return the number of processed Sequences."},
    {"std::string ::genesis::sequence::SequenceCounts::characters () const", "Return the character set that is used for counting."},
    {"void ::genesis::sequence::SequenceCounts::clear ()", "Clear the object, that is, delete everything.\n\nThis function sets the object status to the same that the default constructor gives. Thus, it is not usable any more. It is mainly intended to save memory when many objects are needed.For an alternative function that simply resets the counts to zero, see clear_counts()."},
    {"void ::genesis::sequence::SequenceCounts::clear_counts ()", "Reset all counts to 0."},
    {"CountsIntType ::genesis::sequence::SequenceCounts::count_at (size_t site_index, char character) const", "Return the count for a specific character at a given site.\n\nIf the charater is not part of the set of used characters, the function throws an exception. See characters() to retrieve that set."},
    {"CountsIntType ::genesis::sequence::SequenceCounts::count_at (size_t site_index, size_t character_index) const", "Return the count for a character and a site, given their indices."},
    {"size_t ::genesis::sequence::SequenceCounts::length () const", "Return the number of sites used for counting.\n\nThis has to match the Sequence::length() property of the Sequences to be added for counting."},

    // Class SequenceSet
    {"reference ::genesis::sequence::SequenceSet::add (Sequence const & s)", "Add a Sequence to the SequenceSet by copying it, and return a reference to it."},
    {"reference ::genesis::sequence::SequenceSet::add (Sequence && s)", "Add a Sequence to the SequenceSet by moving it, and return a reference to it."},
    {"void ::genesis::sequence::SequenceSet::clear ()", "Remove all Sequences from the SequenceSet, leaving it with a size() of 0."},
    {"bool ::genesis::sequence::SequenceSet::empty () const", "Return whether the SequenceSet is empty, i.e. whether its size() is 0."},
    {"void ::genesis::sequence::SequenceSet::remove (size_t index)", "Remove the Sequence at a given index from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (size_t first_index, size_t last_index)", "Remove the Sequences between the first_index (inclusive) and the last_index (exclusive) from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (iterator position)", "Remove the Sequence at a given iterator position from the SequenceSet."},
    {"void ::genesis::sequence::SequenceSet::remove (iterator first, iterator last)", "Remove the Sequences between the first (inclusive) and the last (exclusive) iterator position from the SequenceSet."},
    {"size_t ::genesis::sequence::SequenceSet::size () const", "Return the number of Sequences in the SequenceSet."},

    // Class Header

    // Class BaseTaxonData
    {"std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::BaseTaxonData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::BaseTaxonData::create ()", "Create a new instance of this class. Use instead of default constructor."},

    // Class EntropyTaxonData
    {"std::unique_ptr< BaseTaxonData > ::genesis::taxonomy::EntropyTaxonData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class IteratorPreorder

    // Class PrinterNested

    // Class PruneByEntropySettings

    // Class Taxon
    {"BaseTaxonData * ::genesis::taxonomy::Taxon::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseTaxonData const * ::genesis::taxonomy::Taxon::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"bool ::genesis::taxonomy::Taxon::has_data () const", "Return true if the Taxon has a data object assigned to it."},
    {"std::string const & ::genesis::taxonomy::Taxon::name () const", "Return the name of this taxon."},
    {"void ::genesis::taxonomy::Taxon::name (std::string const & value)", "Set the name of this taxon."},
    {"Taxon const * ::genesis::taxonomy::Taxon::parent () const", "Return a pointer to the parent of this taxon, or a nullptr if this is the top level taxon."},
    {"Taxon * ::genesis::taxonomy::Taxon::parent ()", "Return a pointer to the parent of this taxon, or a nullptr if this is the top level taxon."},
    {"std::string const & ::genesis::taxonomy::Taxon::rank () const", "Return the rank of this taxon."},
    {"void ::genesis::taxonomy::Taxon::rank (std::string const & value)", "Set the rank of this taxon."},
    {"Taxon & ::genesis::taxonomy::Taxon::reset_data (std::unique_ptr< BaseTaxonData > data)", "Reset the data pointer of this Taxon.\n\nUsing this function, a Taxon can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseTaxonData). Be however aware that many functions that work with a Taxonomy expect a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},

    // Class Taxonomy
    {"Taxon & ::genesis::taxonomy::Taxonomy::add_child (Taxon const & child)", "Add a child Taxon as a copy of a given Taxon and return it.\n\nIf a child Taxon with the same name already exists, it is recursively merged with the given Taxon."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::add_child (std::string const & name)", "Add a child Taxon by creating a new one with the given name and return it.\n\nIf a child Taxon with the same name already exists, nothing happens."},
    {"Taxon const & ::genesis::taxonomy::Taxonomy::at (size_t index) const", "Return the child Taxon at the given index.\n\nThe function throws an exception if the index in invalid, i.e., >= size()."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::at (size_t index)", "Return the child Taxon at the given index.\n\nThe function throws an exception if the index in invalid, i.e., >= size()."},
    {"const_iterator ::genesis::taxonomy::Taxonomy::cbegin () const", "Return a const iterator to the beginning of the child taxa."},
    {"const_iterator ::genesis::taxonomy::Taxonomy::cend () const", "Return a const iterator to the end of the child taxa."},
    {"void ::genesis::taxonomy::Taxonomy::clear_children ()", "Remove all children."},
    {"Taxon const & ::genesis::taxonomy::Taxonomy::get_child (std::string name) const", "Return the child Taxon with a given name if it exists, or throw otherwise."},
    {"Taxon & ::genesis::taxonomy::Taxonomy::get_child (std::string name)", "Return the child Taxon with a given name if it exists, or throw otherwise."},
    {"bool ::genesis::taxonomy::Taxonomy::has_child (std::string name) const", "Return whether an immediate child Taxon with the given name exists."},
    {"void ::genesis::taxonomy::Taxonomy::remove_child (std::string const & name)", "Remove a child Taxon with a certain name.\n\nThe Taxon (and all its sub-taxa) are destroyed. Throws an std::runtime_error if there is no Taxon with the given name."},
    {"size_t ::genesis::taxonomy::Taxonomy::size () const", "Return the number of immediate child Taxa.\n\nSee total_taxa_count() for counting all Taxa, including all nested ones."},

    // Class TaxonomyReader
    {"utils::CsvReader & ::genesis::taxonomy::TaxonomyReader::csv_reader ()", "Get the CsvReader used for reading a taxonomy file.\n\nThis can be used to modify the reading behaviour, particularly values like the separator chars within the lines of the file. By default, the TaxonomyReader uses a tab \\t char to separate fields, which is different from the comma ',' that is used as default by the CsvReader.It is also possible to change other properties of the CsvReader, for example escaping behaviour, if the input data needs special treatment in those regards.See CsvReader for details about those properties."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::expect_strict_order (bool value)", "Set whether the reader expects a strict order of taxa.\n\nIn a strictly ordered taxonomy file, the super-groups have to be listed before any sub-groups.For example, the list Archaea;\nArchaea;Aenigmarchaeota;\nArchaea;Crenarchaeota;\nArchaea;Crenarchaeota;Thermoprotei;\nis in strict order.If this property is set to true, the reader expects this ordering and throws an exception if there is a violation, that is, if there is a sub-group in the list without a previous entry of its super-group (recursively). This is useful to check a file for consistency, e.g., it might happen that some super-group is misspelled by accident.If set to false (default), the order is ignored and all super-groups are created if necessary."},
    {"bool ::genesis::taxonomy::TaxonomyReader::expect_strict_order () const", "Return whether currently the reader expects a strict order of taxa.\n\nSee the setter for more information."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_file (std::string const & fn, Taxonomy & tax) const", "Read a taxonomy file and add its contents to a Taxonomy."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_stream (std::istream & is, Taxonomy & tax) const", "Read taxonomy data until the end of the stream is reached, and add the contents to a Taxonomy."},
    {"void ::genesis::taxonomy::TaxonomyReader::from_string (std::string const & is, Taxonomy & tax) const", "Read a string with taxonomy data and add its contents to a Taxonomy."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::name_field_position (int value)", "Set the position of the field in each line where the taxon name (Taxopath) is located.\n\nThis value determines at with position (zero based) the field for the taxon name is located.For example, in a taxonomy file with entries like Archaea;Crenarchaeota;Thermoprotei; 7   class   119\nthis value would have to be set to 0, as this is where the taxon name is found. This reader expects the taxon name to be a Taxopath. This is what we call a string of taxonomic hierarchy elements, usually separated by semicola. See Taxopath for details.By default, this value is set to 0, that is, the first field. As it does not make sense to skip this value, it cannot be set to values below zero - which is different from rank_field_position. An exception is thrown should this be attempted."},
    {"int ::genesis::taxonomy::TaxonomyReader::name_field_position () const", "Get the currently set position of the field in each line where the taxon name is located.\n\nSee the setter of this function for details."},
    {"void ::genesis::taxonomy::TaxonomyReader::parse_document (utils::InputStream & it, Taxonomy & tax) const", "Parse all data from an InputStream into a Taxonomy object."},
    {"Line ::genesis::taxonomy::TaxonomyReader::parse_line (utils::InputStream & it) const", "Read a single line of a taxonomy file and return the contained name and rank.\n\nThe name is expected to be a taxonomic path string. See Taxopath for details on that format."},
    {"TaxonomyReader & ::genesis::taxonomy::TaxonomyReader::rank_field_position (int value)", "Set the position of the field in each line where the rank name is located.\n\nThis value determines at with position (zero based) the field for the rank name is located.For example, in a taxonomy file with entries like Archaea;Crenarchaeota;Thermoprotei; 7   class   119\nthis value would have to be set to 2, as this is where the rank name \"class\" is found.If the file does not contain any rank names, or if this field should be skipped, set it to a value of -1. This is also the default."},
    {"int ::genesis::taxonomy::TaxonomyReader::rank_field_position () const", "@ briefGet the currently set position of the field in each line where the rank name is located.See the setter of this function for details."},
    {"TaxopathParser & ::genesis::taxonomy::TaxonomyReader::taxopath_parser ()", "Get the TaxopathParser used for parsing taxonomic path strings.\n\nThe name field is expected to be a taxonomic path string. It is turned into a Taxon using the settings of the TaxopathParser. See there for details. See Taxopath for a path of the expected string format."},

    // Class Taxopath
    {"void ::genesis::taxonomy::Taxopath::assign (std::vector< std::string > const & from)", "Replace the current elements of the Taxopath by a list of strings.\n\nThe strings are copied and used as Taxopath elements in the order in which they are stored in the vector."},
    {"std::string const & ::genesis::taxonomy::Taxopath::at (size_t index) const", "Return the taxonomic element at a certain position.\n\nThe function throws if the given index is not within the size of the taxonomic elements."},
    {"std::string & ::genesis::taxonomy::Taxopath::at (size_t index)", "Return the taxonomic element at a certain position.\n\nThe function throws if the given index is not within the size of the taxonomic elements."},
    {"void ::genesis::taxonomy::Taxopath::clear ()", "Clear all taxonomic elements. This results in an empty Taxopath."},
    {"std::vector< std::string > const & ::genesis::taxonomy::Taxopath::elements () const", "Return the elements of the Taxopath as a vector of strings."},
    {"std::vector< std::string > & ::genesis::taxonomy::Taxopath::elements ()", "Return the elements of the Taxopath as a vector of strings."},
    {"bool ::genesis::taxonomy::Taxopath::empty () const", "Return whether the Taxopath is empty, i.e., does not contain any elements."},
    {"std::string ::genesis::taxonomy::Taxopath::pop_back ()", "Remove the last element of the Taxopath and return its value.\n\nThe returned value is obtained as a copy of the last element before it is removed."},
    {"void ::genesis::taxonomy::Taxopath::push_back (std::string const & value)", "Add an element to the end of the Taxopath by copying it."},
    {"void ::genesis::taxonomy::Taxopath::push_back (std::string && value)", "Add an element to the end of the Taxopath by moving it."},
    {"reverse_iterator ::genesis::taxonomy::Taxopath::rbegin ()", "Return a reverse iterator to the reverse beginning of the taxonomic elements."},
    {"const_reverse_iterator ::genesis::taxonomy::Taxopath::rbegin () const", "Return a const reverse iterator to the reverse beginning of the taxonomic elements."},
    {"reverse_iterator ::genesis::taxonomy::Taxopath::rend ()", "Return a reverse iterator to the reverse end of the taxonomic elements."},
    {"const_reverse_iterator ::genesis::taxonomy::Taxopath::rend () const", "Return a const reverse iterator to the reverse end of the taxonomic elements."},
    {"size_t ::genesis::taxonomy::Taxopath::size () const", "Return the number of elements of this Taxopath."},
    {"void ::genesis::taxonomy::Taxopath::swap (Taxopath & other)", "Swap the elements of two Taxopaths."},

    // Class TaxopathGenerator
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::append_delimiter (bool value)", "Set whether to append the delimiter string to the generated string.\n\nIn many taxonomic databases, the string representation ends with the delimiter char, for example Animalia;Vertebrata;Mammalia;Carnivora;\nThis setting determines whether this last delimiter is appended or not."},
    {"bool ::genesis::taxonomy::TaxopathGenerator::append_delimiter () const", "Return whether currently a delimiter is appended to the taxonomic path string.\n\nSee the setter for details."},
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::delimiter (std::string const & value)", "Set the string used to join the taxonomic path string elements.\n\nThis value is used in between the elements of the taxonomic path string. Default is ';', as this is the usual value in many databases. See Taxopath for details."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::delimiter () const", "Return the currelty set value used to join the taxonomic path string elements.\n\nSee the setter for details."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::to_string (Taxopath const & taxopath) const", "Return a string representation of a Taxopath.\n\nThis generator function uses the settings of this class to generate the string."},
    {"std::string ::genesis::taxonomy::TaxopathGenerator::to_string (Taxon const & taxon) const", "Return a string representation of a Taxon.\n\nThis generator function uses the settings of this class to generate the string."},
    {"TaxopathGenerator & ::genesis::taxonomy::TaxopathGenerator::trim_nested_duplicates (bool value)", "Set whether lower level taxa are omitted if they are the same as the next higher level one.\n\nIf set to true, lower level names are set to empty if they are the same as higher level names. Default is false, that is, nothing is trimmed.Example: For a Taxopath [ \"Tax_1\", \"Tax_1\", \"Tax_2\" ]\nthe generator function returns Tax_1;Tax_1;Tax_2, and respectively Tax_1;;Tax_2 with trimming nested duplicates."},
    {"bool ::genesis::taxonomy::TaxopathGenerator::trim_nested_duplicates () const", "Return the currently set value whether to trim nested duplicates of taxa names.\n\nSee the setter for details."},

    // Class TaxopathParser
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::delimiters (std::string const & value)", "Set the chars used to split the taxonomic path string.\n\nThose chars are used to split the taxon name into its hierarchical parts. Default is ';', as this is the usual value in many databases. See Taxopath for details.If this value is set to multiple chars (string longer than 1), any of them is used for splitting.Example: The taxonomic path string Archaea;Euryarchaeota;Halobacteria;\nis split into \"Archaea\", \"Euryarchaeota\" and \"Halobacteria\"."},
    {"std::string ::genesis::taxonomy::TaxopathParser::delimiters () const", "Return the currelty set delimiter chars used to split the taxonomic path string.\n\nSee the setter for details."},
    {"Taxopath ::genesis::taxonomy::TaxopathParser::from_string (std::string const & taxopath) const", "Parse a taxonomic path string into a Taxopath object and return it.\n\nSee the class description for details on what this parser does."},
    {"Taxopath ::genesis::taxonomy::TaxopathParser::from_taxon (Taxon const & taxon) const", "Helper function to turn a Taxon into a Taxopath.\n\nThis function is probably not need often, as the Taxopath is a helper object from a taxonomic path string towards a Taxon object, but not the other way round. In order to get the string from a Taxon, see the TaxopathGenerator class instead.However, this function might still be useful in some cases. You never know."},
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::remove_trailing_delimiter (bool value)", "Set whether to remove an empty taxonomic element at the end, if it occurs.\n\nIn many taxonomic databases, the taxonomic string representation end with a ';' by default. When splitting such a string, this results in an empty last element. If this option is set to true (default), this element is removed from the Taxopath.If set to false, the element is not removed, but instead treated as a normal \"empty\" element, which means, it is replaced by the value of the preceeding element. See the class description for details on that."},
    {"bool ::genesis::taxonomy::TaxopathParser::remove_trailing_delimiter () const", "Return whether currently trailing delimiters are removed from the taxonomic path string.\n\nSee the setter for details."},
    {"TaxopathParser & ::genesis::taxonomy::TaxopathParser::trim_whitespaces (bool value)", "Set whether to trim whitespaces around the taxonomic elements after splitting them.\n\nDefault is true. If set to true, the taxa given are trimmed off white spaces after splitting them. This is helpful if the input string is copied from some spreadsheet application or CSV file, where spaces between cells might be added.If set to false, all elements are left as they are.Example: The line Archaea; Aigarchaeota; Aigarchaeota Incertae Sedis; 11091   class   123\ncontains spaces both between the taxa names (separated by ;), as well as within the names. Only the former ones will be trimmed, while latter ones are left as they are."},
    {"bool ::genesis::taxonomy::TaxopathParser::trim_whitespaces () const", "Return the currently set value whether whitespaces are trimmed off the taxonomic elements.\n\nSee the setter for details."},

    // Class Line

    // Class BaseEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::BaseEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseEdgeData > ::genesis::tree::BaseEdgeData::create ()", "Create a new instance of this class. Use instead of default constructor."},

    // Class BaseNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::BaseNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},
    {"static std::unique_ptr< BaseNodeData > ::genesis::tree::BaseNodeData::create ()", "Create a new instance of this class. Use instead of default constructor."},

    // Class Bipartition

    // Class BipartitionSet
    {"Bipartition * ::genesis::tree::BipartitionSet::find_smallest_subtree (std::vector< TreeNode * > nodes)", "Finds the smallest subtree (measured in number of nodes) that contains all given nodes.\n\nA subtree is defined by one of the two parts of a tree that are splitted by one edge. Thus, this function tries all subtrees by leaving out each edge once.If no fitting subtree exists, the function returns a nullptr."},

    // Class CircularEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::CircularEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class CircularLayout

    // Class CircularNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::CircularNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class ColorWriterMixin
    {"void ::genesis::tree::ColorWriterMixin::edge_colors (std::vector< utils::Color > const & color_vector)", "Set the edge colors that shall be written to the output.\n\nIf this function is called with a vector of size > 0, the edges in the output will be colored according to the values given as a parameter. The vector then needs to contain as many elements as the tree has edges. The elements need to be indexed using the edge.index() value.If this function is called with an empty vector, the color printing is reset to not print the edge colors that might have been set before."},
    {"std::vector< utils::Color > ::genesis::tree::ColorWriterMixin::edge_colors ()", "Return the edge colors that are currently set."},
    {"void ::genesis::tree::ColorWriterMixin::enable_color (bool value)", "Set whether colors tags are written to the output."},
    {"bool ::genesis::tree::ColorWriterMixin::enable_color () const", "Returns whether colors tags are written to the output."},
    {"void ::genesis::tree::ColorWriterMixin::ignored_color (utils::Color value)", "Set a color that is used as marker for partially disabling the output of color tags.\n\nAll edges that have set a color equal to the ignored color will produce no color tag output. This is thus something like \"magic pink\", where all parts of an image are rendered transparent when originially colored in pink.By default, we do not use an ignored color. If this option is activated, also use_ignored_color() is set to true."},
    {"utils::Color ::genesis::tree::ColorWriterMixin::ignored_color () const", "Return the currently set ignored color. See the setter for more information."},
    {"void ::genesis::tree::ColorWriterMixin::use_ignored_color (bool value)", "Set whether to use the ignored_color().\n\nIf this option is set to true, the color that is set via ignored_color() is not written as a color attribute to the output format."},
    {"bool ::genesis::tree::ColorWriterMixin::use_ignored_color () const", "Return whether currently an ignored color is used."},

    // Class DefaultEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::DefaultEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class DefaultNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::DefaultNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class DefaultTreeNewickReaderMixin

    // Class DefaultTreeNewickWriterMixin

    // Class DefaultTreePhyloxmlWriterMixin

    // Class EmdEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::EmdEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class EmdNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::EmdNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class IteratorEulertour

    // Class IteratorLevelorder

    // Class IteratorNodeLinks

    // Class IteratorPath
    {"bool ::genesis::tree::IteratorPath::is_last_common_ancestor () const", "Return whether the current iterator position (node) is the last common ancestor of the two start and finish nodes.\n\nThis is useful in many cases:\nFind the LCA (obviously).Check when the path is moving away from the root again.Iterating edges instead of nodes.\nThe last bullet point may need some explanation:The iterator visits all nodes between the start and the finish (both included). On the path between them, there is however one edge fewer than the number of visited nodes. That means, if you want to visit each edge on the path between two nodes (instead of each node), you need a way to spot this superflous edge. This function indicates the edge that needs to be skipped in this case."},
    {"bool ::genesis::tree::IteratorPath::is_lca () const", "Alias for is_last_common_ancestor(). See there for more information."},

    // Class IteratorPathSet

    // Class IteratorPostorder

    // Class IteratorPreorder

    // Class LayoutEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::LayoutEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class LayoutNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::LayoutNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class NewickBroker
    {"void ::genesis::tree::NewickBroker::assign_ranks () const", "Iterate over the tree and assign ranks (= number of immediate children) to all nodes.\n\nThis function is for example needed to check whether it is a bifurcating/binary tree, or to check how many leaves and inner nodes the tree has. Thus, it is usually called after the broker is filled with data."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::at (std::size_t index)", "Provides index based array access to the nodes, doing a boundary check first.\n\nIn out of bounds cases, a nullptr is returned."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::bottom ()", "Returns a reference to the bottom node of the tree stack.\n\nCalling this function on an empty() broker causes undefined behavior."},
    {"const_iterator ::genesis::tree::NewickBroker::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::tree::NewickBroker::cend () const", "Const version of end()."},
    {"void ::genesis::tree::NewickBroker::clear ()", "Deletes all nodes from the broker."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crbegin ()", "Const version of rbegin()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::crend ()", "Const version of rend()."},
    {"std::string ::genesis::tree::NewickBroker::dump () const", "Return a readable string representation of the elements of the NewickBroker."},
    {"bool ::genesis::tree::NewickBroker::empty () const", "Returns whether the stack is empty."},
    {"int ::genesis::tree::NewickBroker::leaf_count () const", "Returns the number of leaf nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::max_rank () const", "Returns the highest rank of the nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::tree::NewickBroker::node_count () const", "Alias for size()."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rbegin ()", "Returns a reverse iterator to the nodes on the stack."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rbegin () const", "Returns a reverse iterator to the nodes on the stack for const objects."},
    {"reverse_iterator ::genesis::tree::NewickBroker::rend ()", "Reverse version of end()."},
    {"const_reverse_iterator ::genesis::tree::NewickBroker::rend () const", "Reverse version of end() for const objects."},
    {"size_t ::genesis::tree::NewickBroker::size () const", "Returns the size of the stack, i.e. the number of nodes stored in the broker."},
    {"NewickBrokerElement & ::genesis::tree::NewickBroker::top ()", "Returns a reference to the top node of the tree stack.\n\nUsually, the top element is the root of the tree (i.e., it has depth zero). Only when called during the broker is being filled with nodes (for example, while parsing a Newick tree), the top element is not the root.Calling this function on an empty() broker causes undefined behavior."},
    {"bool ::genesis::tree::NewickBroker::validate () const", "Returns true iff the tree is valid. assign_ranks() has to be called first.\n\nA valid tree in a NewickBroker has to fullfill those criteria:\nIt's rank has to match the property is_leaf: Leaves have rank 0; a node with a higher rank cannot be a leaf.Furthermore, rank 1 is not valid, as this represents a node that is not furcating in any way.The depth (nesting level) of the nodes cannot increase more than one level between nodes, as this would imply a non-existing node with a depth in between. However, it can arbitrarily decrease, as this simply means the end of a subtree. %"},

    // Class NewickBrokerElement
    {"int ::genesis::tree::NewickBrokerElement::rank () const", "Returns the rank (number of immediate children) of this node.\n\nNewickBroker::assign_ranks() has to be called before using this function. Otherwise, this function will throw an std::logic_error."},

    // Class NewickColorWriterMixin
    {"void ::genesis::tree::NewickColorWriterMixin::color_tag_prefix (std::string prefix)", "Set the prefix string that is used within the Newick comment before the actual color value.\n\nBy default, this string is set to &!color=, which is for example used by FigTree to mark color in trees. This will result in a Newick comment like [&!color=#c0ffee]."},
    {"std::string ::genesis::tree::NewickColorWriterMixin::color_tag_prefix ()", "Get the currently set prefix string. See the setter for more information."},
    {"void ::genesis::tree::NewickColorWriterMixin::color_tag_suffix (std::string suffix)", "Set the suffix string that is used within the Newick comment after the actual color value.\n\nBy default, this string is empty. See the setter color_tag_prefix() for more information."},
    {"std::string ::genesis::tree::NewickColorWriterMixin::color_tag_suffix ()", "Get the currently set suffix string. See the setter for more information."},

    // Class NewickLexer

    // Class NewickReader
    {"bool ::genesis::tree::NewickReader::from_file (const std::string & filename, Tree & tree)", "Create a Tree from a file containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_file (const std::string & filename, TreeSet & tree_set)", "Fill a TreeSet from a file containing a list of Newick trees.\n\nSee from_string() for information on the syntax of this file. The tree names are taken from the content if availabe. Unnamed trees will be prefixed by the file name.Returns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_files (const std::vector< std::string > & filenames, TreeSet & tree_set)", "Fill a TreeSet from a list of files containing Newick trees.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_string (const std::string & tree_string, Tree & tree)", "Create a Tree from a string containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_string (const std::string & tree_string, TreeSet & tree_set, const std::string & default_name="")", "Fill a TreeSet from a string containing a list of Newick trees.\n\nThese trees can either be named or unnamed, using this syntax: Tree_A = (...);\n'Tree B'=(...);\n(...);\nwhere the first two lines are named trees and the third line is an unnamed tree. The trees do not have to be on distinct lines of the input, as whitespaces are completely stripped during the lexing phase. However, they are required to end with a semicolon ;.In case of unnamed trees, a default_name can be provided, which will be appended by a counter that counts up all unnamed trees. If no default name is given, the trees will simpye be named using the counter itself.Returns true iff successful."},
    {"bool ::genesis::tree::NewickReader::from_strings (const std::vector< std::string > & tree_strings, TreeSet & tree_set, const std::string & default_name="")", "Fill a TreeSet from a list of strings containing Newick trees.\n\nReturns true iff successful."},

    // Class NewickWriter
    {"void ::genesis::tree::NewickWriter::to_file (const Tree & tree, const std::string filename)", "Writes the tree to a file in Newick format.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::tree::NewickWriter::to_string (const Tree & tree, std::string & ts)", "Gives a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},
    {"std::string ::genesis::tree::NewickWriter::to_string (const Tree & tree)", "Returns a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},

    // Class PhyloxmlColorWriterMixin

    // Class PhyloxmlWriter
    {"void ::genesis::tree::PhyloxmlWriter::to_document (const Tree & tree, utils::XmlDocument & xml)", "Stores the information of the tree into an Phyloxml-formatted XmlDocument."},
    {"void ::genesis::tree::PhyloxmlWriter::to_file (const Tree & tree, const std::string filename)", "Writes the tree to a file in Phyloxml format.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::tree::PhyloxmlWriter::to_string (const Tree & tree, std::string & ts)", "Gives a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},
    {"std::string ::genesis::tree::PhyloxmlWriter::to_string (const Tree & tree)", "Returns a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},

    // Class PrinterCompact
    {"void ::genesis::tree::PrinterCompact::print (std::ostream & out, Tree const & tree, std::function< std::string(TreeNode const &node, TreeEdge const &edge)> const print_line)", "TODO this method assumes that the tree node has a name. not good."},
    {"std::string ::genesis::tree::PrinterCompact::print (Tree const & tree)", "TODO this method assumes that the tree node has a name. not good."},

    // Class PrinterDetailed

    // Class PrinterTable

    // Class RectangularEdgeData
    {"std::unique_ptr< BaseEdgeData > ::genesis::tree::RectangularEdgeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class RectangularLayout

    // Class RectangularNodeData
    {"std::unique_ptr< BaseNodeData > ::genesis::tree::RectangularNodeData::clone () const", "Polymorphically copy an instance of this class. Use instead of copy constructor."},

    // Class Tree
    {"void ::genesis::tree::Tree::clear ()", "Deletes all data of the tree, including all links, nodes and edges.\n\nThis functions results in an empty tree."},
    {"Tree ::genesis::tree::Tree::clone_topology () const", "Return a Tree with the same topology, but without any data.\n\nAll data pointers of the nodes and edges of the returned tree are nullptr."},
    {"TreeEdge & ::genesis::tree::Tree::edge_at (size_t index)", "Return the TreeEdge at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeEdge const & ::genesis::tree::Tree::edge_at (size_t index) const", "Return the TreeEdge at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::edge_count () const", "Return the number of TreeEdges of the Tree."},
    {"bool ::genesis::tree::Tree::empty () const", "Return whether the Tree is empty (i.e., has no nodes, edges and links)."},
    {"EdgeContainerType & ::genesis::tree::Tree::expose_edge_container ()", "Get the container that stores all TreeEdges of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"LinkContainerType & ::genesis::tree::Tree::expose_link_container ()", "Get the container that stores all TreeLinks of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"NodeContainerType & ::genesis::tree::Tree::expose_node_container ()", "Get the container that stores all TreeNodes of the Tree.\n\nThis function gives direct access to the underlying container for the Links. It is meant to be used by external functions that need to manupulate the Tree, e.g., for reading or re-rooting the tree, or for adding elements to it. Use with care!"},
    {"TreeLink & ::genesis::tree::Tree::link_at (size_t index)", "Return the TreeLink at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeLink const & ::genesis::tree::Tree::link_at (size_t index) const", "Return the TreeLink at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::link_count () const", "Return the number of TreeLinks of the Tree."},
    {"TreeNode & ::genesis::tree::Tree::node_at (size_t index)", "Return the TreeNode at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"TreeNode const & ::genesis::tree::Tree::node_at (size_t index) const", "Return the TreeNode at a certain index.\n\nIf the index is invalid, the functions throws an std::out_of_range exception."},
    {"size_t ::genesis::tree::Tree::node_count () const", "Return the number of TreeNodes of the Tree."},
    {"Tree & ::genesis::tree::Tree::reset_root_link_index (size_t val)", "Reset the index of the link that is considered to be the root of the Tree.\n\nThis function is meant for tree manipulation functions. Use with care!Caveat: This function simply sets the index, but does not change any other properties of the tree. Particularly the correct primary/secondary order of TreeEdges and primary links of TreeNodes needs to be maintained manually when using this function! Otherwise, we end up with an invalid Tree that breaks its invariants!"},
    {"TreeLink & ::genesis::tree::Tree::root_link ()", "Return the TreeLink at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeLink const & ::genesis::tree::Tree::root_link () const", "Return the TreeLink at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeNode & ::genesis::tree::Tree::root_node ()", "Return the TreeNode at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"TreeNode const & ::genesis::tree::Tree::root_node () const", "Return the TreeNode at the current root of the Tree.\n\nIf the tree is empty(), the functions throws an std::out_of_range exception."},
    {"void ::genesis::tree::Tree::swap (Tree & other)", "Swap."},

    // Class TreeEdge
    {"BaseEdgeData * ::genesis::tree::TreeEdge::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseEdgeData const * ::genesis::tree::TreeEdge::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"std::string ::genesis::tree::TreeEdge::dump () const", "Returns a one-line dump summary of the data of this edge.\n\nTODO this method assumes that the tree node has a name. not good."},
    {"bool ::genesis::tree::TreeEdge::has_data () const", "Return true if the TreeEdge has a data object assigned to it."},
    {"size_t ::genesis::tree::TreeEdge::index () const", "Return the index of this Edge."},
    {"TreeLink & ::genesis::tree::TreeEdge::primary_link ()", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"TreeLink const & ::genesis::tree::TreeEdge::primary_link () const", "Return the TreeLink of this TreeEdge that points towards the root."},
    {"TreeNode & ::genesis::tree::TreeEdge::primary_node ()", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"TreeNode const & ::genesis::tree::TreeEdge::primary_node () const", "Return the TreeNode of this TreeEdge that points towards the root."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_data (std::unique_ptr< BaseEdgeData > data)", "Reset the data pointer of this TreeEdge.\n\nUsing this function, a TreeEdge can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseEdgeData). Be however aware that many functions that work with Trees expect a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_index (size_t val)", "Reset the internal index of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate. The index is an invariant that needs to be kept, as it needs to match the index in the Tree container.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_primary_link (TreeLink * val)", "Reset the internal pointer to the primary TreeLink of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeEdge & ::genesis::tree::TreeEdge::reset_secondary_link (TreeLink * val)", "Reset the internal pointer to the secondary TreeLink of this TreeEdge.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeLink & ::genesis::tree::TreeEdge::secondary_link ()", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"TreeLink const & ::genesis::tree::TreeEdge::secondary_link () const", "Return the TreeLink of this TreeEdge that points away from the root."},
    {"TreeNode & ::genesis::tree::TreeEdge::secondary_node ()", "Return the TreeNode of this TreeEdge that points away from the root."},
    {"TreeNode const & ::genesis::tree::TreeEdge::secondary_node () const", "Return the TreeNode of this TreeEdge that points away from the root."},

    // Class TreeLink
    {"std::string ::genesis::tree::TreeLink::dump () const", "Return a string containing dump information about this link.\n\nAt the moment, a link does not contain any information, so an empty string is returned. This might change in the future, in case links also contain data."},
    {"TreeEdge & ::genesis::tree::TreeLink::edge ()", "Return the TreeEdge of this TreeLink."},
    {"TreeEdge const & ::genesis::tree::TreeLink::edge () const", "Return the TreeEdge of this TreeLink."},
    {"size_t ::genesis::tree::TreeLink::index () const", "Return the index of this Link."},
    {"bool ::genesis::tree::TreeLink::is_inner () const", "Return true iff the node of this link is an inner node."},
    {"bool ::genesis::tree::TreeLink::is_leaf () const", "Return true iff the node of this link is a leaf node."},
    {"TreeLink & ::genesis::tree::TreeLink::next ()", "Return the next TreeLink within the TreeNode of this link."},
    {"TreeLink const & ::genesis::tree::TreeLink::next () const", "Return the next TreeLink within the TreeNode of this link."},
    {"TreeNode & ::genesis::tree::TreeLink::node ()", "Return the TreeNode of this TreeLink."},
    {"TreeNode const & ::genesis::tree::TreeLink::node () const", "Return the TreeNode of this TreeLink."},
    {"TreeLink & ::genesis::tree::TreeLink::outer ()", "Return the TreeLink of the adjacent TreeNode."},
    {"TreeLink const & ::genesis::tree::TreeLink::outer () const", "Return the TreeLink of the adjacent TreeNode."},
    {"TreeLink & ::genesis::tree::TreeLink::prev ()", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},
    {"TreeLink const & ::genesis::tree::TreeLink::prev () const", "Return the previous TreeLink within the TreeNode of this link.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},

    // Class TreeNode
    {"BaseNodeData * ::genesis::tree::TreeNode::data_ptr ()", "Return a pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"BaseNodeData const * ::genesis::tree::TreeNode::data_ptr () const", "Return a const pointer to the data.\n\nIn most cases, using data<>() is more convenient. However, in some cases, this function might be necessary."},
    {"std::string ::genesis::tree::TreeNode::dump () const", "Returns a one-line dump summary of the data of this node.\n\nTODO this method assumes that the tree node has a name. not good."},
    {"bool ::genesis::tree::TreeNode::has_data () const", "Return true if the TreeNode has a data object assigned to it."},
    {"size_t ::genesis::tree::TreeNode::index () const", "Return the index of this Node."},
    {"bool ::genesis::tree::TreeNode::is_inner () const", "True iff the node is an inner node."},
    {"bool ::genesis::tree::TreeNode::is_leaf () const", "True iff the node is a leaf/tip."},
    {"bool ::genesis::tree::TreeNode::is_root () const", "True iff the node is the root of its Tree."},
    {"TreeLink & ::genesis::tree::TreeNode::link ()", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"TreeLink const & ::genesis::tree::TreeNode::link () const", "Return the TreeLink that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"TreeLink & ::genesis::tree::TreeNode::primary_link ()", "Return the TreeLink that points towards the root."},
    {"TreeLink const & ::genesis::tree::TreeNode::primary_link () const", "Return the TreeLink that points towards the root."},
    {"size_t ::genesis::tree::TreeNode::rank () const", "Rank of the node, i.e. how many immediate children it has."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_data (std::unique_ptr< BaseNodeData > data)", "Reset the data pointer of this TreeNode.\n\nUsing this function, a TreeNode can be assigend new data. It is also possible to change the data type completely (as long as it derives from BaseNodeData). Be however aware that many functions that work with trees expcet a certain data type. Thus, changing it might break those functions and lead to exceptions and other errors."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_index (size_t val)", "Reset the internal index of this TreeNode.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate. The index is an invariant that needs to be kept, as it needs to match the index in the Tree container.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},
    {"TreeNode & ::genesis::tree::TreeNode::reset_primary_link (TreeLink * val)", "Reset the internal pointer to the TreeLink of this TreeNode.\n\nThis is a helper function that needs to be used with care and only in cases where appropriate.This function exists to allow building and modifying a Tree without the need for many friend declarations. However, the function should rarely be needed outside of this context."},

    // Class TreeSet
    {"void ::genesis::tree::TreeSet::add (std::string const & name, Tree const & tree)", "Add a Tree with a name to the TreeSet.\n\nThe Tree is copied."},
    {"void ::genesis::tree::TreeSet::clear ()", "Clear the TreeSet and destroy all contained Trees."},
    {"bool ::genesis::tree::TreeSet::empty () const", "Return whether the TreeSet is empty."},
    {"void ::genesis::tree::TreeSet::remove_at (size_t index)", "Remove the Tree at a certain index position.\n\nAs this function moves Trees in the container around, all iterators and pointers to the elements of this TreeSet are considered to be invalidated."},
    {"size_t ::genesis::tree::TreeSet::size () const", "Return the size of the TreeSet, i.e., the number of stored Trees."},

    // Class StackElement

    // Class NamedTree

    // Class BaseInputSource
    {"size_t ::genesis::utils::BaseInputSource::read (char * buffer, size_t size)", "Read size many bytes into the char buffer."},
    {"std::string ::genesis::utils::BaseInputSource::source_name () const", "Get a name of the input source. Mainly interesting for user output."},

    // Class Bitvector
    {"size_t ::genesis::utils::Bitvector::count () const", "Counts the number of set bits in the Bitvector."},
    {"void ::genesis::utils::Bitvector::flip (size_t index)", "Flips (inverts) the value of a single bit, with boundary check."},
    {"bool ::genesis::utils::Bitvector::get (size_t index) const", "Returns the value of a single bit, with boundary check."},
    {"size_t ::genesis::utils::Bitvector::hash () const", "Returns an std::hash value for the Bitvector."},
    {"void ::genesis::utils::Bitvector::invert ()", "Flip all bits."},
    {"void ::genesis::utils::Bitvector::normalize ()", "Brings the Bitvector in a normalized form, where the first bit is always zero.\n\nIf the first bit is zero, nothing happens. However, if is is one, the whole Bitvector is flipped using invert()."},
    {"void ::genesis::utils::Bitvector::reset (const bool value=false)", "Reset all the bits to false. If provided with parameter true, sets all bits to true."},
    {"void ::genesis::utils::Bitvector::set (size_t index)", "Sets the value of a single bit to true, with boundary check."},
    {"void ::genesis::utils::Bitvector::set (size_t index, bool value)", "Sets the value of a single bit to a given bool value, with boundary check."},
    {"size_t ::genesis::utils::Bitvector::size () const", "Returns the size (number of total bits) of this Bitvector."},
    {"void ::genesis::utils::Bitvector::unset (size_t index)", "Sets the value of a single bit to false, with boundary check."},
    {"IntType ::genesis::utils::Bitvector::x_hash () const", "Returns a hash value of type IntType, that is quicker to calculate than hash(), and thus can be used where the std::hash is not needed."},

    // Class BmpWriter
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< Color > const & image, std::string const & filename) const", "Write a full 24bit RGB Color image to a file."},
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< unsigned char > const & image, std::string const & filename) const", "Write an 8 bit grayscale image to a file.\n\nThe entries of the given Matrix are simply translated into a grayscale image, where 0 gives black and 255 gives white pixels."},
    {"void ::genesis::utils::BmpWriter::to_file (Matrix< unsigned char > const & image, std::vector< Color > palette, std::string const & filename) const", "Write an 8 bit image with a Color palette to a file.\n\nThe given palette needs to contain exaclty 256 Color entries. The values of the given image Matrix are then mapped to the palette entries, e.g., the value at image( 2, 3 ) == 5 maps to the Color palette[ 5 ]."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< Color > const & image, std::ostream & outstream) const", "Write a full 24bit RGB Color image to a stream."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< unsigned char > const & image, std::ostream & outstream) const", "Write an 8 bit grayscale image to a stream.\n\nThe entries of the given Matrix are simply translated into a grayscale image, where 0 gives black and 255 gives white pixels."},
    {"void ::genesis::utils::BmpWriter::to_stream (Matrix< unsigned char > const & image, std::vector< Color > palette, std::ostream & outstream) const", "Write an 8 bit image with a Color palette to a stream.\n\nThe given palette needs to contain exaclty 256 Color entries. The values of the given image Matrix are then mapped to the palette entries, e.g., the value at image( 2, 3 ) == 5 maps to the Color palette[ 5 ]."},

    // Class CharLookup
    {"bool ::genesis::utils::CharLookup::all_equal_to (T comp_value) const", "Return whether all chars compare equal to a given value."},
    {"T ::genesis::utils::CharLookup::get (char c) const", "Return the lookup status for a given char."},
    {"std::string ::genesis::utils::CharLookup::get_chars_equal_to (T comp_value) const", "Return a std::string containg all chars which have lookup status equal to a given value."},
    {"void ::genesis::utils::CharLookup::set_all (T value)", "Set the lookup status for all chars at once."},
    {"void ::genesis::utils::CharLookup::set_char (char c, T value)", "Set the lookup status for a given char."},
    {"void ::genesis::utils::CharLookup::set_char_upper_lower (char c, T value)", "Set the lookup status for both the upper and lower case of a given char."},
    {"void ::genesis::utils::CharLookup::set_if (std::function< bool(char)> predicate, T value)", "Set the lookup status for all chars that fulfill a given predicate."},
    {"void ::genesis::utils::CharLookup::set_range (char first, char last, T value)", "Set the lookup status for all chars in an inlcuding range between two chars."},
    {"void ::genesis::utils::CharLookup::set_selection (std::string const & chars, T value)", "Set the lookup status for all chars that are contained in a given std::string."},
    {"void ::genesis::utils::CharLookup::set_selection_upper_lower (std::string const & chars, T value)", "Set the lookup status for both the upper and lower case of all chars that are contained in a given std::string."},

    // Class Color

    // Class ColorNames

    // Class CsvReader
    {"CsvReader & ::genesis::utils::CsvReader::comment_chars (std::string const & chars)", "Set chars that are used to mark comment lines.\n\nBy default, no chars are used, that is, no line is interpreted as comment. Use this function to change that behaviour, e.g., use # as marker for comment lines. All lines starting with any of the set chars are then skipped while reading. The char has to be the first on the line, that is, no leading blanks are allowed.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::comment_chars () const", "Return the currently set chars that are used to mark comment lines.\n\nSee the setter  of this function for more details."},
    {"table ::genesis::utils::CsvReader::from_file (std::string const & fn) const", "Read a CSV file and return its contents."},
    {"table ::genesis::utils::CsvReader::from_stream (std::istream & is) const", "Read CSV data until the end of the stream is reached, and return it."},
    {"table ::genesis::utils::CsvReader::from_string (std::string const & fs) const", "Read a string in CSV format and return its contents."},
    {"CsvReader & ::genesis::utils::CsvReader::merge_separators (bool value)", "Set whether consecutive separater chars are merged or whether each of them creates a new field.\n\nDefault is false. Usually, CSV data has the same number of columns for the whole dataset. Thus, empty fields will result in consecutive separator chars. When this value is set to false, those fields are correctly parsed into empty fields.It might however be useful to not create separate empty fields when consecutive separator chars are encountered. This is particularly the case if spaces or tabs are used as separators. In this case it makes sense to have more than one of them consecutively in order to align the columns of the data. For such datasets, this value can be set to true.To put it in other words, this value determines whether empty strings resulting from adjacent separator chars are excluded from the output.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::merge_separators () const", "Return the current setting whether consecutive separators are merged or not.\n\nSee the setter  of this function for details."},
    {"table ::genesis::utils::CsvReader::parse_document (utils::InputStream & input_stream) const", "Parse a whole CSV document and return its contents."},
    {"std::string ::genesis::utils::CsvReader::parse_field (utils::InputStream & input_stream) const", "Parse one field (i.e., one column) of the CSV data and return it.\n\nThis function reads from a given input stream until the column separator or the end of the line or the end of the stream is found. It furthermore trims the necessary chars from the beginning and end of the field, and handles quoted strings according to the settings of the CsvReader.The stream is left at either the separator char, the new line char, or the end of the file, depending on which occurs first.See trim_chars(), quotation_chars(), separator_chars(), use_escapes()  and use_twin_quotes()  to change the behaviour of this function."},
    {"std::vector< std::string > ::genesis::utils::CsvReader::parse_line (utils::InputStream & input_stream) const", "Parse one line of the CSV data and return it.\n\nThis function parses a whole line using parse_field() until the new line char (or the end of the stream) is found. The fields are returned in a vector. The stream is left at either the next char after the new line char or the end of the file, if there is no new line.See merge_separators()  to change the behaviour of this function."},
    {"CsvReader & ::genesis::utils::CsvReader::quotation_chars (std::string const & chars)", "Set the chars that are used for quoting strings in fields.\n\nBy default, the double quotation mark char \" is used as quotation mark. Any other set of chars can be used instead, for example a combination of single and double quotation marks by providing `'\"` to this function.Within a quoted part, any char can appear, even new lines. However, in order to use the quotation mark itself, it has to be escaped. See use_escapes()  and use_twin_quotes()  for changing the behaviour of escaping with backslashes and with twin quotation marks.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::quotation_chars () const", "Return the currently set chars for quoting strings in fields.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::separator_chars (std::string const & chars)", "Set the chars used to separate fields of the CSV data.\n\nBy default, the comma char , is used. Any other set of chars can be used instead, for example a combination of tabs and bars by providing \\t| to this function.Caveat: If more than one char is used as separater, any of them separates fields. That is, the string provided to this function is not taken as a whole to separate fields, but its single chars are used.See merge_separators()  to set whether consecutive separator chars are merged.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::separator_chars () const", "Return the currently set chars used to separate fields of the CSV data.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::skip_empty_lines (bool value)", "Set whether to skip empty lines.\n\nDefault is false. If set to true, all lines that are empty (that is, no content, or just consisting of spaces and tabs) are skipped while reading.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::skip_empty_lines () const", "Return whether currently empty lines are skipped.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::trim_chars (std::string const & chars)", "Set chars that are trimmed from the start and end of each field.\n\nBy default, no chars are trimmed. Use this function to change that behaviour, e.g., to trim spaces and tabs. Be aware that according to some CSV definitions, blanks are considered to be part of the field and should not be trimmed.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"std::string const & ::genesis::utils::CsvReader::trim_chars () const", "Return the currently set chars that are trimmed from the start and end of each field.\n\nSee the setter  of this function for more details."},
    {"CsvReader & ::genesis::utils::CsvReader::use_escapes (bool value)", "Set whether to use backslash escape sequences.\n\nDefault is false. If set to true, character sequences of \\x (backslash and some other char) are turned into the respective string form, according to the rules of deescape(). Also, see parse_quoted_string() for more information on escaping.This works inside and outside of quoted strings. In order to create new lines within a field, either the sequence \\n (backslash n) can be used, or a backslash at the end of the line.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::use_escapes () const", "Return whether backslash escape sequences are used.\n\nSee the setter  of this function for details."},
    {"CsvReader & ::genesis::utils::CsvReader::use_twin_quotes (bool value)", "Set whether to interpret two consequtive quotation marks as a single (\"escaped\") one.\n\nDefault is true. Use this setting in order to be able to escape quotation marks by doubling them. This is a common variant in CSV data. It means, whenever two consecutive quotation marks are encountered, they are turned into one (thus, the first one \"escapes\" the second). This works both inside and outside of regularly quoted parts. That is, the following two fields are interpreted the same: \"My \"\"old\"\" friend\"\nMy \"\"old\"\" friend\nThis also works in addition to normal backslash escape sequences, see use_escapes()  for more on this.See quotation_chars()  to set which chars are interpreted as quotation marks.The function returns a reference to the CsvReader object in order to allow a fluent interface."},
    {"bool ::genesis::utils::CsvReader::use_twin_quotes () const", "Return whether to interpret two consequtive quotation marks as a single (\"escaped\") one.\n\nSee the setter  of this function for details."},

    // Class Deserializer
    {"T ::genesis::utils::Deserializer::get_float ()", "Read a floating point number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_float (T & res)", "Read an floating point number from the stream and store it in the result."},
    {"T ::genesis::utils::Deserializer::get_int ()", "Read an integer number from the stream and return it."},
    {"void ::genesis::utils::Deserializer::get_int (T & res)", "Read an integer number from the stream and store it in the result."},
    {"bool ::genesis::utils::Deserializer::get_null (size_t n)", "Reads n bytes from the stream and returns whether all of them are \\0 bytes."},
    {"T ::genesis::utils::Deserializer::get_plain ()", "Read as many bytes from the stream as the type T holds, and return them in form of a value of type T."},
    {"void ::genesis::utils::Deserializer::get_plain (T & res)", "Read as many bytes from the stream as the type T holds, and put them in the result value of type T."},
    {"void ::genesis::utils::Deserializer::get_raw (char * buffer, size_t n)", "Read n bytes from the stream and store them in the buffer.\n\nThe buffer needs to be big enough to hold n bytes."},
    {"std::string ::genesis::utils::Deserializer::get_raw_string (size_t n)", "Read n bytes from the stream and return them as a string."},
    {"std::string ::genesis::utils::Deserializer::get_string ()", "Read a string from the stream, provided that its length it written preceding it, as done by put_string()."},

    // Class FileInputSource
    {"void ::genesis::utils::FileInputSource::rewind ()", "Rewind the source to its start, so that it can be re-read."},

    // Class Histogram

    // Class HistogramAccumulator
    {"size_t ::genesis::utils::HistogramAccumulator::added_values () const", "Return the number of values that have been added to the Accumulator.\n\nThis is simply the number of function calls to increment() and accumulate(). The count is reset when calling clear()."},

    // Class IndexedList

    // Class IndexedListIterator

    // Class InputStream
    {"self_type & ::genesis::utils::InputStream::advance ()", "Move to the next char in the stream and advance the counters."},
    {"std::string ::genesis::utils::InputStream::at () const", "Return a textual representation of the current input position in the form \"line:column\"."},
    {"size_t ::genesis::utils::InputStream::column () const", "Return the current column of the input stream.\n\nThe counter starts with column 1 for each line of the input stream. New line characters \\n are included in counting and count as the last character of a line."},
    {"char ::genesis::utils::InputStream::current () const", "Return the current char, with some checks.\n\nThis function is similar to the dereference operator, but additionally performs two checks:\nEnd of input: If this function is called when there is no more data left in the input, it throws an runtime_error.Current char: This iterator is meant for ASCII (or similar) text format encodings with single bytes, and its output should be usable for lookup tables etc. Thus, this function ensures that the char is in the range [0, 127]. If not, an std::domain_error is thrown.\nUsually, those two conditions are checked in the parser anyway, so in most cases it is preferred to use the dereference operator instead."},
    {"bool ::genesis::utils::InputStream::eof () const", "Return true iff the input reached its end."},
    {"char ::genesis::utils::InputStream::get_char ()", "Extract a single char from the input.\n\nReturn the current char and move to the next one."},
    {"std::pair< char *, size_t > ::genesis::utils::InputStream::get_line ()", "Return the current line and move to the beginning of the next.\n\nThe function finds the end of the current line, starting from the current position. It returns a pointer to the current position and the length of the line. Furthermore, a null char is set at the end of the line, replacing the new line char. This allows downstream parses to directly use the returned pointer as a c-string.The stream is left at the first char of the next line."},
    {"bool ::genesis::utils::InputStream::good () const", "Return true iff the input is good (not end of data) and can be read from."},
    {"size_t ::genesis::utils::InputStream::line () const", "Return the current line of the input stream.\n\nThe counter starts with line 1 for input stream."},
    {"std::string ::genesis::utils::InputStream::source_name () const", "Get the input source name where this stream reads from.\n\nDepending on the type of input, this is either\n\"input string\",\"input stream\" or\"input file <filename>\"\nThis is mainly useful for user output like log and error messages."},

    // Class IteratorDeletions
    {"TwobitVector::WordType ::genesis::utils::IteratorDeletions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorDeletions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorDeletions::vector () const", "Get the current vector."},

    // Class IteratorInsertions
    {"TwobitVector::WordType ::genesis::utils::IteratorInsertions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorInsertions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorInsertions::vector () const", "Get the current vector."},

    // Class IteratorSubstitutions
    {"TwobitVector::WordType ::genesis::utils::IteratorSubstitutions::hash () const", "Get the hash value of the current vector."},
    {"size_t ::genesis::utils::IteratorSubstitutions::position () const", "Get the position that is currently deleted."},
    {"TwobitVector const & ::genesis::utils::IteratorSubstitutions::vector () const", "Get the current vector."},

    // Class JsonDocument
    {"static JsonDocument ::genesis::utils::JsonDocument::array (std::initializer_list< JsonDocument > init=std::initializer_list< )", "Explicitly create an array from an initializer list."},
    {"static JsonDocument ::genesis::utils::JsonDocument::boolean (BooleanType value)", "Explicitly create a boolean."},
    {"const_iterator ::genesis::utils::JsonDocument::cbegin () const", "Return a const iterator to the first element."},
    {"const_iterator ::genesis::utils::JsonDocument::cend () const", "Return a const iterator to one past the last element."},
    {"void ::genesis::utils::JsonDocument::clear ()", "Clears the content of a JSON value and resets it to the default value as if JsonDocument(ValueType) would have been called.\n\nThe values are cleared as follows:\nValue type initial value  \n\nnull null \n\nboolean false \n\nstring \"\" \n\nnumber 0 \n\nobject {} \n\narray [] \n\nIn order to complete eliminate a Json value, set it to nullptr instead."},
    {"size_type ::genesis::utils::JsonDocument::count (typename ObjectType::key_type key) const", "Return the number of occurrences of a key in a JSON object.\n\nAs we use a std::map for objects, this value is either 0 (key not found) or 1 (key found). For non-object types, the return value is always 0."},
    {"iterator ::genesis::utils::JsonDocument::find (typename ObjectType::key_type key)", "Find an element in a JSON object.\n\nFinds an element in a JSON object with key equivalent to key. If the element is not found or the JSON value is not an object, end() is returned."},
    {"const_iterator ::genesis::utils::JsonDocument::find (typename ObjectType::key_type key) const", "Find an element in a JSON object.\n\nFinds an element in a JSON object with key equivalent to key. If the element is not found or the JSON value is not an object, end() is returned."},
    {"bool ::genesis::utils::JsonDocument::is_array () const", "Return true iff the JSON value is an array."},
    {"bool ::genesis::utils::JsonDocument::is_boolean () const", "Return true iff the JSON value is a boolean."},
    {"bool ::genesis::utils::JsonDocument::is_null () const", "Return true iff the JSON value is null."},
    {"bool ::genesis::utils::JsonDocument::is_number () const", "Return true iff the JSON value is a number, i.e., a float or signed or unsigned integer."},
    {"bool ::genesis::utils::JsonDocument::is_number_float () const", "Return true iff the JSON value is a float number."},
    {"bool ::genesis::utils::JsonDocument::is_number_integer () const", "Return true iff the JSON value is a signed or unsigned integer number."},
    {"bool ::genesis::utils::JsonDocument::is_number_signed () const", "Return true iff the JSON value is a signed integer number."},
    {"bool ::genesis::utils::JsonDocument::is_number_unsigned () const", "Return true iff the JSON value is an unsigned integer number."},
    {"bool ::genesis::utils::JsonDocument::is_object () const", "Return true iff the JSON value is an object."},
    {"bool ::genesis::utils::JsonDocument::is_primitive () const", "Return true iff the JSON type is primitive (string, number, boolean, or null)."},
    {"bool ::genesis::utils::JsonDocument::is_string () const", "Return true iff the JSON value is a string."},
    {"bool ::genesis::utils::JsonDocument::is_structured () const", "Return true iff the JSON type is structured (array or object)."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_float (NumberFloatType value)", "Explicitly create a float number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_signed (NumberSignedType value)", "Explicitly create a signed number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::number_unsigned (NumberUnsignedType value)", "Explicitly create an unsigned number."},
    {"static JsonDocument ::genesis::utils::JsonDocument::object (std::initializer_list< JsonDocument > init=std::initializer_list< )", "Explicitly create an object from an initializer list."},
    {"void ::genesis::utils::JsonDocument::push_back (JsonDocument && val)", "Add a Json value to an array.\n\nAppends the given element val to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending val.void push_back( JsonDocument&& val );"},
    {"void ::genesis::utils::JsonDocument::push_back (JsonDocument const & val)", "Add a Json value to an array.\n\nAppends the given element val to the end of the JSON value. If the function is called on a JSON null value, an empty array is created before appending val.void push_back( JsonDocument&& val );"},
    {"void ::genesis::utils::JsonDocument::push_back (typename ObjectType::value_type const & val)", "Add an object to an object.\n\nInserts the given element val to the JSON object. If the function is called on a JSON null value, an empty object is created before inserting val."},
    {"static JsonDocument ::genesis::utils::JsonDocument::string (std::string const & init)", "Explicitly create a string."},
    {"ValueType ::genesis::utils::JsonDocument::type () const", "Return the type of the JSON value."},

    // Class JsonIterator
    {"JsonDocument::ObjectType::key_type ::genesis::utils::JsonIterator::key () const", "return the key of an object iterator\n\nThe iterator is initialized; i.e. object_ != nullptr."},
    {"reference ::genesis::utils::JsonIterator::value () const", "return the value of an iterator\n\nThe iterator is initialized; i.e. object_ != nullptr."},

    // Class JsonReader
    {"JsonDocument ::genesis::utils::JsonReader::from_file (const std::string & filename) const", "Take a JSON document file path and parse its contents into a JsonDocument.\n\nIf the file does not exists, the function throws."},
    {"JsonDocument ::genesis::utils::JsonReader::from_stream (std::istream & input_stream) const", "Read from a stream containing a JSON document and parse its contents into a JsonDocument."},
    {"JsonDocument ::genesis::utils::JsonReader::from_string (const std::string & json) const", "Take a string containing a JSON document and parse its contents into a JsonDocument."},

    // Class JsonWriter
    {"size_t ::genesis::utils::JsonWriter::indent () const", "Get the indent used for printing the elements of Json arrays and objects."},
    {"JsonWriter & ::genesis::utils::JsonWriter::indent (size_t value)", "Set the indent used for printing the elements of Json arrays and objects.\n\nThe function returns a reference to the JsoNWriter to allow for fluent interfaces."},
    {"size_t ::genesis::utils::JsonWriter::precision () const", "Get the precision used for printing floating point numbers."},
    {"JsonWriter & ::genesis::utils::JsonWriter::precision (size_t value)", "Set the precision used for printing floating point numbers.\n\nThe function returns a reference to the JsoNWriter to allow for fluent interfaces."},
    {"void ::genesis::utils::JsonWriter::to_file (JsonDocument const & document, std::string const & filename) const", "Write a JsonDocument to a file.\n\nIf the file already exists or cannot be written to, the function throws std::runtime_error."},
    {"void ::genesis::utils::JsonWriter::to_stream (JsonDocument const & document, std::ostream & out) const", "Write a JsonDocument to a stream."},
    {"void ::genesis::utils::JsonWriter::to_string (JsonDocument const & document, std::string & output) const", "Give the Json string representation of a JsonDocument."},
    {"std::string ::genesis::utils::JsonWriter::to_string (JsonDocument const & document) const", "Return the Json representation of a JsonDocument."},

    // Class Lexer
    {"LexerToken ::genesis::utils::Lexer::back () const", "Returns a reference to the last token.\n\nCalling this function on an empty() lexer causes undefined behavior."},
    {"void ::genesis::utils::Lexer::clear ()", "Clears all tokens, as if the object was newly created.\n\nThe options of the lexer are however not changed."},
    {"std::string ::genesis::utils::Lexer::dump () const", "Returns a listing of the parse result in readable form."},
    {"bool ::genesis::utils::Lexer::empty () const", "Returns whether the list of tokens is empty.\n\nThis is usually the case before ProcessString() was run."},
    {"bool ::genesis::utils::Lexer::from_string (const std::string & in)", "Shortcut function that reads the contents of a file and then calls from_string().\n\nIf the file does not exist, a warning is triggered and false returned. Otherwise, the result of from_string() is returned. Process a string and store the resulting tokens in this Lexer object.This process analyzes and splits the string into different tokens. For the types of tokens being extracted, see LexerToken; for accessing the results, see Lexer.Returns true iff successful. In case an error is encountered while analyzing the text, this functions returns false and the last token will be of type LexerTokenType::kError, with the value being an error message describing the type of error."},
    {"bool ::genesis::utils::Lexer::has_error () const", "Returns whether there appeared an error while lexing."},
    {"bool ::genesis::utils::Lexer::process_step ()", "Processes one step of the lexing.\n\nAs stated in the description of this Lexer class, the class is meant to be derived for concrete types of lexers. Thus, here are some comments about the working of this function:For most types of structured text, the first character of each token determines the type of the token (for example, a digit almost always leads to a number token). This is why we use a list telling us which char leads to which token type. This list is a speedup, because using it, we do not need to try every scanner (for numbers, symbols, strings, etc) at the beginning of each new token, but simply do a lookup to find out \"this char means we have to use\nthis scanner now\". (Also see get_char_type and SetCharType for this.)This does not mean that any char of a given type can only appear in tokens of that type. For example, typically a symbol can start with letters, but then contain numbers later, too. Thus, although a digit is of type kNumber, it can end up in a symbol token, depending on the context.Instead, the char type here is meant as a speedup for finding the right scanner when lexing the text: whenever one scanner finishes, the next char is inspected and depending on its type, a fitting scanner is activated (for digits the number scanner and so on).This technique will not work if finding the correct scanner depends on more than the first character of the token. For example, comments usually start with a more complex sequence (\"//\" or even \"<!--\"), which is why they are specially treaded in this function.So, in situations, where the type of the next token cannot be determined from its first character (except comments), this function has to be overridden in the derived class in order to do some other checking methods to determine the correct scanner."},
    {"size_t ::genesis::utils::Lexer::size () const", "Returns the number of tokens produced during the analysis process."},
    {"bool ::genesis::utils::Lexer::validate_brackets () const", "Checkes whether the bracket tokes are validly nested.\n\nIn order to be valid, every opening bracket must be matched with a corresponding closing bracket, and their order has to be correct.This function checks the following types of brackets: () [] {} <>\nIt is not particularly useful for xml, as there it is also important to use closing tags like <xml> ... </xml>."},

    // Class LexerIterator
    {"void ::genesis::utils::LexerIterator::consume_head ()", "Removes all tokens up to (but excluding) the current one.\n\nThis is a slow operation, thus should not be called in the inner parsing loop. It is meant to save memory when reading and parsing large files."},
    {"bool ::genesis::utils::LexerIterator::has_error () const", "Returns whether there appeared an error while lexing."},

    // Class LexerToken
    {"std::string ::genesis::utils::LexerToken::at () const", "Shortcut that returns \"line:column\" (e.g., for logging)."},
    {"size_t ::genesis::utils::LexerToken::column () const", "Getter for the column where this token occured."},
    {"size_t ::genesis::utils::LexerToken::has_new_lines () const", "Returns the number of new line characters, if this token is a whitespace."},
    {"bool ::genesis::utils::LexerToken::is_bracket () const", "Shortcut to check if this is a bracket token.\n\nThere is an overload of this function that also checks if the token is a specific type of bracket."},
    {"bool ::genesis::utils::LexerToken::is_bracket (const std::string & br) const", "Returns whether this token is a given type of bracket.\n\nUsage: token.is_bracket(\")\") will return true if this token is of LexerTokenType kBracket and if it is the closing parenthesis. This is a shortcut for testing type and value at the same time."},
    {"bool ::genesis::utils::LexerToken::is_comment () const", "Shortcut to check if this is a comment token."},
    {"bool ::genesis::utils::LexerToken::is_error () const", "Shortcut to check if this is an error token."},
    {"bool ::genesis::utils::LexerToken::is_number () const", "Shortcut to check if this is a number token."},
    {"bool ::genesis::utils::LexerToken::is_operator () const", "Shortcut to check if this is an operator token.\n\nThere is an overload of this function that also checks if the token is a specific type of operator."},
    {"bool ::genesis::utils::LexerToken::is_operator (const std::string & op) const", "Returns whether this token is a given type of operator.\n\nUsage: token.is_operator(\"%\") will return true if this token is of LexerTokenType kOperator and if it is the modulo operator. This is a shortcut for testing type and value at the same time."},
    {"bool ::genesis::utils::LexerToken::is_string () const", "Shortcut to check if this is a string token."},
    {"bool ::genesis::utils::LexerToken::is_symbol () const", "Shortcut to check if this is a symbol token."},
    {"bool ::genesis::utils::LexerToken::is_tag () const", "Shortcut to check if this is a tag token."},
    {"bool ::genesis::utils::LexerToken::is_unknown () const", "Shortcut to check if this is an unknown token."},
    {"bool ::genesis::utils::LexerToken::is_white () const", "Shortcut to check if this is a whitespace token."},
    {"size_t ::genesis::utils::LexerToken::line () const", "Getter for the line where this token occured."},
    {"LexerTokenType ::genesis::utils::LexerToken::type () const", "Getter for the LexerTokenType of this token."},
    {"std::string ::genesis::utils::LexerToken::type_to_string () const", "Returns the string representation for the LexerTokenType of this token."},
    {"std::string ::genesis::utils::LexerToken::value () const", "Getter for the string value of this token."},

    // Class Logging
    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level)", "Getter for the singleton instance of log, is called by the standard macros.\n\nIt returns the string stream buffer used to capture the log messages."},
    {"std::ostringstream & ::genesis::utils::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level, const LoggingDetails dets)", "Getter for the singleton instance of log, is called by special macros that change the details of the log message.\n\nIt stores some relevant information and returns the string stream buffer used to capture the log messages."},
    {"static std::string ::genesis::utils::Logging::level_to_string (const LoggingLevel level)", "Return a string representation of a log level."},
    {"static void ::genesis::utils::Logging::log_to_file (const std::string & fn)", "Add an output file to which log messages are written.\n\nThis creates a stream to the file."},
    {"static void ::genesis::utils::Logging::log_to_stdout ()", "Add stdout as output stream to which log messages are written."},
    {"static void ::genesis::utils::Logging::log_to_stream (std::ostream & os)", "Add an output stream to which log messages are written."},
    {"static LoggingLevel ::genesis::utils::Logging::max_level ()", "Get the highest log level that is reported."},
    {"static void ::genesis::utils::Logging::max_level (const LoggingLevel level)", "Set the highest log level that is reported.\n\nInvocations of log with higher levels will create no output. It creates a warning if the set level is higher than the static compile time level set by LOG_LEVEL_MAX."},
    {"static int ::genesis::utils::Logging::report_percentage ()", "Get the current percentage for reporting LOG_PROG messages."},
    {"static void ::genesis::utils::Logging::report_percentage (const int percentage)", "set the percentage for reporting LOG_PROG messages."},

    // Class LoggingDetails

    // Class LoggingScopeLevel

    // Class Matrix

    // Class MeanStddevPair

    // Class MinMaxPair

    // Class NexusBlock

    // Class NexusDocument

    // Class NexusTaxa

    // Class NexusTrees

    // Class NexusWriter

    // Class Options
    {"static std::string ::genesis::utils::Options::build_type ()", "Return the build type that was used to compile the binary, i.e., \"debug\" or \"release\"."},
    {"std::vector< std::string > ::genesis::utils::Options::command_line () const", "Returns an array of strings containing the program's command line arguments."},
    {"void ::genesis::utils::Options::command_line (int const argc, char const *const * argv)", "Set arguments to the program's command line options.\n\nIf the program is run from the command line, this method has to be used to properly propagate the command line options to this options class."},
    {"std::string ::genesis::utils::Options::command_line_string () const", "Returns a string containing the program's command line arguments."},
    {"static std::string ::genesis::utils::Options::compiler_family ()", "Return the compiler family (name) that was used to compile genesis.\n\nSee compiler_version() to get the version of the compiler."},
    {"static std::string ::genesis::utils::Options::compiler_version ()", "Return the compiler version that was used to compile genesis.\n\nSee compiler_family() to get the corresponding compiler name."},
    {"static std::string ::genesis::utils::Options::cpp_version ()", "Return the CPP version that was used to compile genesis."},
    {"static Options & ::genesis::utils::Options::get ()", "Returns a single instance of this class."},
    {"std::string ::genesis::utils::Options::info () const", "Return a list with compile time and run time options with their values."},
    {"static bool ::genesis::utils::Options::is_big_endian ()", "Return whether the system uses big endian memory."},
    {"static bool ::genesis::utils::Options::is_debug ()", "Return whether the binary was compiled with build type DEBUG."},
    {"static bool ::genesis::utils::Options::is_little_endian ()", "Return whether the system uses little endian memory."},
    {"static bool ::genesis::utils::Options::is_release ()", "Return whether the binary was compiled with build type RELEASE."},
    {"unsigned int ::genesis::utils::Options::number_of_threads () const", "Returns the number of threads."},
    {"void ::genesis::utils::Options::number_of_threads (const unsigned int number)", "Overwrite the system given number of threads.\n\nOn startup, the value is initialized with the actual number of cores available in the system using std::thread::hardware_concurrency(). This method overwrites this value."},
    {"static std::string ::genesis::utils::Options::platform ()", "Return the platform under which genesis was compiled.\n\nThis can be either \"Win32\", \"Linux\", \"Apple\", \"Unix\" or \"Unknown\"."},
    {"std::default_random_engine & ::genesis::utils::Options::random_engine ()", "Returns the default engine for random number generation.\n\nCaveat: This is not intended for the use in more than one thread. As the order of execution in threads is not deterministic, results would not be reproducible, even when using a fixed seed. Furthermore, it might be a speed bottleneck to add a mutex to this method.If in the future there is need for multi-threaded random engines, they needed to be outfitted with separate seeds each (otherwise they would all produce the same results). Thus, for now we simply assume single-threaded use."},
    {"unsigned ::genesis::utils::Options::random_seed () const", "Returns the random seed that was used to initialize the engine."},
    {"void ::genesis::utils::Options::random_seed (const unsigned seed)", "Set a specific seed for the random engine.\n\nOn startup, the random engine is initialized using the current system time. This value can be overwritten using this method."},
    {"bool ::genesis::utils::Options::using_openmp () const", "Return whether the binary was compiled using OpenMP."},
    {"bool ::genesis::utils::Options::using_pthreads () const", "Return whether the binary was compiled using Pthreads."},

    // Class PcaData

    // Class Range

    // Class RangeMinimumQuery
    {"size_t ::genesis::utils::RangeMinimumQuery::query (size_t i, size_t j) const", "Main function for the Range Minimum Query.\n\nThe function returns the index of the minimum element in the given vector of integers (see RangeMinimumQuery()) that lies between the indices i and j.Caveat: Both given indices are inclusive, i.e., the interval is [ i, j ]. If j < i, the function throws an std::invalid_argument."},

    // Class SHA1
    {"DigestType ::genesis::utils::SHA1::final_digest ()", "Finish the calculation, prepare the object for next use, and return the digest."},
    {"std::string ::genesis::utils::SHA1::final_hex ()", "Finish the calculation, prepare the object for next use, and return the hash."},
    {"static DigestType ::genesis::utils::SHA1::from_file_digest (std::string const & filename)", "Calculate the hash digest for the content of a file, given its path."},
    {"static std::string ::genesis::utils::SHA1::from_file_hex (std::string const & filename)", "Calculate the checksum for the content of a file, given its path."},
    {"static DigestType ::genesis::utils::SHA1::from_string_digest (std::string const & input)", "Calculate the hash digest for the content of a string."},
    {"static std::string ::genesis::utils::SHA1::from_string_hex (std::string const & input)", "Calculate the checksum for the content of a string."},
    {"void ::genesis::utils::SHA1::update (std::string const & s)", "Add the contents of a string to the hash digest."},
    {"void ::genesis::utils::SHA1::update (std::istream & is)", "Add the contents of a stream to the hash digest."},

    // Class Serializer
    {"void ::genesis::utils::Serializer::put_float (const T v)", "Write a floating point number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and convert it to some machine-independent format."},
    {"void ::genesis::utils::Serializer::put_int (const T v)", "Write an integer number to the stream.\n\nCurrently, this simply uses put_plain(), but future versions might change this behaviour and use specific conversions (litte/big endianness, signed/unsigned) before writing."},
    {"void ::genesis::utils::Serializer::put_null (const size_t n)", "Write n zero bytes (\\0) to the stream."},
    {"void ::genesis::utils::Serializer::put_plain (const T v)", "Write plain data to the stream, by casting it to a char array."},
    {"void ::genesis::utils::Serializer::put_raw (char * data, size_t n)", "Write raw data, provided as a char array of length n, to the stream."},
    {"void ::genesis::utils::Serializer::put_raw_string (const std::string & v)", "Write raw data, provided as a string, to the stream, without writing its length."},
    {"void ::genesis::utils::Serializer::put_string (const std::string & v)", "Write a string, preceded by its length, to the stream. Use get_string() to read it."},

    // Class SortedVector
    {"bool ::genesis::utils::SortedVector::contains (const_reference value) const", "Return whether a certain value is present in the container."},
    {"size_type ::genesis::utils::SortedVector::index_of (const_reference value) const", "Return the index at which a certain value is stored, or size(), if it is not present in the container."},
    {"void ::genesis::utils::SortedVector::insert (const_reference value)", "Insert a value into the container by copying it.\n\nIf a value comparing equal to the new one is already stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::insert (value_type && value)", "Insert a value into the container by moving it.\n\nIf a value comparing equal to the new one is already stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::insert (InputIterator first, InputIterator last)", "Insert values into the container by copying from an InputIterator range.\n\nThe function copies all values in the range [ first, last ) into the container."},
    {"void ::genesis::utils::SortedVector::remove (const_reference value)", "Remove a certain value from the container.\n\nIf the value is not stored in the container, nothing happens."},
    {"void ::genesis::utils::SortedVector::reserve (size_t n)", "Reserve space in the unterlying vector."},

    // Class StreamInputSource

    // Class StringInputSource
    {"void ::genesis::utils::StringInputSource::rewind ()", "Rewind the source to its start, so that it can be re-read."},

    // Class Style
    {"bool ::genesis::utils::Style::bold () const", "Return whether the Style uses bold."},
    {"Style & ::genesis::utils::Style::bold (bool value)", "Set whether the Style uses bold.\n\nThe function returns the Style object itself, in order to allow a fluent interface."},
    {"bool ::genesis::utils::Style::enabled () const", "Return whether the Style is currently enabled."},
    {"Style & ::genesis::utils::Style::enabled (bool value)", "Set whether the Style is enabled.\n\nIf set to false, no style attributes are outputted when the Style is applied to a text with operator()(). Default is true.The function returns the Style object itself, in order to allow a fluent interface."},
    {"static std::string ::genesis::utils::Style::get_background_color_value (std::string name)", "Return the color value string for a given background color name.\n\nSee Style::foreground_colors for background valid color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static std::string ::genesis::utils::Style::get_foreground_color_value (std::string name)", "Return the color value string for a given foreground color name.\n\nSee Style::foreground_colors for valid foreground color names. If the name is invalid, the function throws an std::out_of_range exception."},
    {"static bool ::genesis::utils::Style::is_background_color (std::string name)", "Return true iff the given name is a background color name."},
    {"static bool ::genesis::utils::Style::is_foreground_color (std::string name)", "Return true iff the given name is a foreground color name."},
    {"Style & ::genesis::utils::Style::reset ()", "Reset the Style to use not colors and not bold."},
    {"std::string ::genesis::utils::Style::to_bash_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\033 for the escape symbol, which is best interpreted by bash. Usually, there is no need to use this function. The operator() should just work fine."},
    {"std::string ::genesis::utils::Style::to_python_string (std::string const & text) const", "Additional output function with the same purpose as operator().\n\nIt uses the notation \\x1b for the escape symbol, which is best interpreted by python. Usually, there is no need to use this function. The operator() should just work fine."},

    // Class SvgBox

    // Class SvgCircle

    // Class SvgDefinitions

    // Class SvgDocument
    {"self_type & ::genesis::utils::SvgDocument::add (SvgObject const & object)", "Add an SvgObject to the document.\n\nReturns the SvgDocument in order to allow for a fluent interface."},
    {"void ::genesis::utils::SvgDocument::write (std::ostream & out) const", "Write the SvgDocument to an output stream."},

    // Class SvgDrawingOptions

    // Class SvgEllipse

    // Class SvgFill

    // Class SvgFont

    // Class SvgGradientLinear

    // Class SvgGradientStop

    // Class SvgGroup
    {"self_type & ::genesis::utils::SvgGroup::add (SvgObject const & object)", "Add an SvgObject to the document.\n\nReturns the SvgDocument in order to allow for a fluent interface."},

    // Class SvgLine

    // Class SvgMargin

    // Class SvgObject

    // Class SvgPath

    // Class SvgPoint

    // Class SvgPolygon

    // Class SvgPolyline

    // Class SvgRect

    // Class SvgSize

    // Class SvgStroke

    // Class SvgText

    // Class SvgTransform

    // Class SvgUse

    // Class SynchronousReader

    // Class Table
    {"Column & ::genesis::utils::Table::add_column (std::string label="")", "Add a column to the table.\n\nIf the table already contains columns with data, the new one is initialized with empty strings for the whole length of the table."},
    {"void ::genesis::utils::Table::clear ()", "Clears all columns and their data from the table."},
    {"void ::genesis::utils::Table::clear_content ()", "Clears the data contents of all columns. Their labels etc stay unchanged."},
    {"Table & ::genesis::utils::Table::line_break ()", "Finish the currently line and move to the next one.\n\nThis function fills the columns of the current line with empty strings, so that the next append() call will add content to the first column of the next line. If we are currently at the beginning of a line, this function results in an empty line (useful for grouping of lines)."},

    // Class TableLayout

    // Class Tickmarks
    {"std::vector< LabeledTick > ::genesis::utils::Tickmarks::linear_labels (double min, double max, size_t target_steps)", "Return a set of labels with relative positions between min and max, where the labels correspond to the linear_ticks() numbers.\n\nThis function is a convenience wrapper for linear_ticks(), that turns the tick positions into relative values, while keeping the actual tick value as a label. Relative position 0.0 corresponds to min, relative position 1.0 to max."},
    {"std::vector< double > ::genesis::utils::Tickmarks::linear_ticks (double min, double max, size_t target_steps)", "Calculate a set of ticks that linearily span from min to max in approximately target_steps many steps, where each tick sits on a \"nice\" number.\n\nSee step_size() for what is meant by nice numbers."},
    {"std::vector< LabeledTick > ::genesis::utils::Tickmarks::logarithmic_labels (double max)", "Return a set of labels with relative positions between min and max, where the labels correspond to logarithmic ticks.\n\nThis function is the equivalent of linear_labels(), but instead uses logarithmic scaling. Also, it always starts at a minimum of 1 and inserts as many ticks as are needed to go up to max in powers of ten.Example: Given max == 350, with overshoot_at_max == false and include_max == true, the resulting vector contains entries with labels 1, 10, 100, 350.Remark: There is no logarithmic equivalent for linear_ticks(), as those would simply be powers of 10 up to max."},
    {"static double ::genesis::utils::Tickmarks::step_size (double interval_size, size_t target_steps)", "Calculate a step size that fills the interval_size in approximately target_steps many steps.\n\nThe resulting step size is calculated to be a \"nice\" size, i.e. fits [ 1 | 2 | 5 ] * 10^n. Thus, exemplary nice step sizes are 0.01, 20 and 500."},

    // Class TridiagonalDecompositionData

    // Class TwobitVector
    {"void ::genesis::utils::TwobitVector::clear ()", "Clear the vector, so that it contains no data."},
    {"WordType const & ::genesis::utils::TwobitVector::data_at (size_t index) const", "Return a single word of the vector.\n\nThis is useful for external functions that want to directly work on the underlying bit representation."},
    {"WordType & ::genesis::utils::TwobitVector::data_at (size_t index)", "Return a single word of the vector.\n\nThis is useful for external functions that want to directly work on the underlying bit representation."},
    {"size_t ::genesis::utils::TwobitVector::data_size () const", "Return the number of words (of type WordType) that are used to store the values in the vector."},
    {"ValueType ::genesis::utils::TwobitVector::get (size_t index) const", "Get the value at a position in the vector."},
    {"WordType ::genesis::utils::TwobitVector::hash () const", "Calculate a hash value of the vector, based on its size() and the xor of all its words.\n\nThis is a simple function, but might just be enough for using it in a hashmap."},
    {"void ::genesis::utils::TwobitVector::insert_at (size_t index, ValueType value)", "Insert a value at a position.\n\nThe size() is increased by one."},
    {"void ::genesis::utils::TwobitVector::remove_at (size_t index)", "Remove the value at a position.\n\nThe size() is decreased by one."},
    {"void ::genesis::utils::TwobitVector::set (size_t index, ValueType value)", "Set a value at a position in the vector."},
    {"size_t ::genesis::utils::TwobitVector::size () const", "Return the size of the vector, that is, how many values (of type ValueType) it currently holds."},
    {"bool ::genesis::utils::TwobitVector::validate () const", "Validation function that checks some basic invariants.\n\nThis is mainly useful in testing. The function checks whether the vector is correctly sized and contains zero padding at its end."},

    // Class XmlComment

    // Class XmlDocument

    // Class XmlElement

    // Class XmlMarkup

    // Class XmlValue

    // Class XmlWriter
    {"void ::genesis::utils::XmlWriter::to_file (const XmlDocument & document, const std::string & filename)", "Write an XML file from an XmlDocument. Return true iff successful.\n\nIf the file already exists, the function throws std::runtime_error. The function uses utils::file_write. See there for other exceptions that can be thrown."},
    {"void ::genesis::utils::XmlWriter::to_string (const XmlDocument & document, std::string & output)", "Give the XML string representation of a XmlDocument."},
    {"std::string ::genesis::utils::XmlWriter::to_string (const XmlDocument & document)", "Return the XML representation of a XmlDocument."},

    // Class BitmapFileheader

    // Class BitmapInfo

    // Class BitmapInfoheader

    // Class RgbQuad

    // Class InternalIterator

    // Class PrimitiveIterator

    // Class Entry

    // Class Concept

    // Class Model

    // Class Concept

    // Class Model

    // Class Matrix

    // Class Rotate

    // Class Scale

    // Class Skew

    // Class Transformation

    // Class Translate

    // Class Concept

    // Class Model

    // Class Column
    {"void ::genesis::utils::Table::Column::shrink_width ()", "Shrinks the column width to the minmal width that suffices to fit in all values of the column (i.e., both data and label).\n\nThe column keeps track of its needed minimal width when just adding data. Thus, this function is only neccessary to call once the width was changed manually or if the label or a data value have been changed after being added."},
    {"void ::genesis::utils::Table::Column::width (size_t value)", "Set the width of this column.\n\nIf the new value is smaller than the current one, nothing happens. The width can only grow, or be set to the minimal possible value using shrink_width(). This ensures that all text fits within the column."},

    // Class Binder

    // Class Line

    // Class LabeledTick


    // Functions
    {"std::string ::genesis::utils::file_basename (std::string const & filename)", "Remove directory name from file name if present."},
    {"bool ::genesis::utils::file_exists (std::string const & filename)", "Return true iff the file exists."},
    {"std::string ::genesis::utils::file_extension (std::string const & filename)", "Return the extension name of a file.\n\nAlso see file_filename()."},
    {"std::string ::genesis::utils::file_filename (std::string const & filename)", "Remove extension if present.\n\nCaveat: Does not remove the path. So, if the filename itself does not contain an extension separator \".\", but the path does, this will yield an unwanted result. Call file_basename() first."},
    {"std::unordered_map< std::string, std::string > ::genesis::utils::file_info (std::string const & filename)", "Return information about a file."},
    {"std::string ::genesis::utils::file_path (std::string const & filename)", "Return the path leading to a file.\n\nDoes not resolve the path. Simply splits at the last directory separator."},
    {"std::string ::genesis::utils::file_read (std::string const & filename)", "Return the contents of a file as a string.\n\nIf the file is not readable, the function throws std::runtime_error."},
    {"size_t ::genesis::utils::file_size (std::string const & filename)", "Return the size of a file."},
    {"void ::genesis::utils::file_write (std::string const & content, std::string const & filename)", "Write the content of a string to a file.\n\nIf the file is not writable, the function throws std::runtime_error."},
    {"TwobitVector ::genesis::utils::from_nucleic_acids (std::string const & sequence)", "Turn a string of nucleic acids into a TwobitVector."},
    {"std::string ::genesis::utils::get_attribute_string (Style const & s)", "Internal helper function that returns the attribute string of a Style based on its properties."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_background_color_iterator (std::string name)", "Internal helper function that returns an iterator into the background color list."},
    {"static std::array< std::pair< std::string, std::string >, 17 >::const_iterator ::genesis::utils::get_foreground_color_iterator (std::string name)", "Internal helper function that returns an iterator into the foreground color list."},
    {"Color ::genesis::utils::get_named_color (std::string const & name)", "Retrieve a named color by name.\n\nNames are filtered so that spaces, underscores and the letter case are ignored. If the color name does not exist, an std::invalid_argument exception is thrown."},
    {"Color ::genesis::utils::get_named_color_at (size_t at)", "Retrieve a named color by its index in the list.\n\nThe index for a color can be obtained using get_named_color_index(). If the color name does not exist, an std::invalid_argument exception is thrown.This function is mainly useful for automatic picking of colors, e.g. when using some incrementing counter. However, a proper color scheme might be more usefule in most cases."},
    {"size_t ::genesis::utils::get_named_color_index (std::string const & name)", "Get the index of a named color in the list.\n\nThe colors are stored in alphabetical order. If the color name does not exist, an std::invalid_argument exception is thrown."},
    {"std::array< std::pair< std::string, Color >, 140 >::const_iterator ::genesis::utils::get_named_color_iterator (std::string name)", "Internal helper function.\n\nReturns an iterator into the array if the given name is a named color or an iterator to the end of the color map if it is not a named color."},
    {"Color ::genesis::utils::gradient (std::map< double, Color > const & ranges, double percentage)", "Returns a Color that is created using a color gradient.\n\nThe function takes a color gradient in form of a map from double to Color. The keys in the map are offset positions between 0.0 and 1.0. The keys 0.0 and 1.0 need to be the lowest and highest keys in the map, respectively. Otherwise, an std::invalid_argument is thrown. An arbitrary number of keys in between these boundaries is allowed.Each key is associated with a Color value, which indicates the color at that position.Example: // Prepare gradient ranges.\nauto ranges = std::map<double, Color>();\nranges[ 0.0 ] = Color(   0, 255, 0 );\nranges[ 0.5 ] = Color( 255, 255, 0 );\nranges[ 1.0 ] = Color( 255,   0, 0 );\n\n// Get color at 30% of the green-yellow-red gradient.\nColor c = gradient( ranges, 0.3 );\nThis map defines the same gradient that is used for heat_gradient.The second parameter of this function then takes the position (again, between 0.0 and 1.0) at which the gradient is evaluated. Values outside of the interval [0.0, 1.0] are set to the closest interval border value (so, either 0.0 or 1.0).For example, given the range map above, a percentage value of 0.0 gives green; 0.5 gives yellow; 1.0 gives red; values in between are interpolated accordingly."},
    {"std::string ::genesis::utils::head (std::string const & text, size_t lines)", "Return the first lines of the text."},
    {"Color ::genesis::utils::heat_gradient (double percentage)", "Returns a Color that represents a heat gradient for a percentage value.\n\nGiven a percentage value in the range of [0.0, 1.0], the functions represents the heat of that value. For 0.0, the heat gradient value is green, for 0.5 yellow and for 1.0 red. The values in between are interpolated accordingly."},
    {"std::string ::genesis::utils::indent (std::string const & text, std::string const & indentation)", "Indent each line of text with indentation and return the result.\n\nBy default, four spaces are used to indent. Whether the text ends with a new line or not is not changed. Any trailing indentation chars are trimmed, in order to not have trailing whitespaces in the result (except for the new line, if the text ends in one)."},
    {"unsigned char ::genesis::utils::interpolate (unsigned char d1, unsigned char d2, double fraction)", "Helper function that linearily interpolates between two char values."},
    {"Color ::genesis::utils::interpolate (Color color1, Color color2, double fraction)", "Helper function that linearily interpolates between two Colors."},
    {"bool ::genesis::utils::is_dir (std::string const & path)", "Return true iff the provided path is a directory.\n\nInternally, this function simply return the value of dir_exists(), as this already does the needed check. Thus, it is an alias."},
    {"bool ::genesis::utils::is_file (std::string const & path)", "Return true iff the provided path is a file.\n\nInternally, this function simply return the value of file_exists(), as this already does the needed check. Thus, it is an alias."},
    {"bool ::genesis::utils::is_named_color (std::string const & name)", "Return true iff the given name is a named color.\n\nNames are filtered so that spaces, underscores and the letter case are ignored."},
    {"bool ::genesis::utils::is_valid_filname (std::string const & filename)", "Check whether a file name is valid.\n\nValidating filenames depends on the operating system and file system of the disk. Thus, this is usually not an easy task. This function only checks some basics and is meant to catch the most common problems.The function is meant to be called on the file name itself, without the directory path leading to it. File extensions are allowed. Thus, you might need to call file_basename() before in order to get the file name without the path.Invalid filenames are:\nThose with spaces at the beginning or end, or only consisting of spaces (or empty).Those which contain any of the chars < > : \" \\ / | ? *.Those which contain any non-printable character, as determined via isprint().\nThis might be too converative for some system, or allow too much for others. It however should return true for filenames that work on most systems."},
    {"std::string ::genesis::utils::join (T const & v, std::string const & delimiter)", "Return a string where the elements of a container v are joined using the string delimiter in between them.\n\nThe container is iterated via its range based for loop, thus it needs to have begin() and end() functions.For turning the elements of the container into a string, their operator << is used. Thus, this function can used with all types that support this operator."},
    {"std::string ::genesis::utils::lexer_token_type_to_string (const LexerTokenType t)", "Converts a LexerTokenType into its string representation."},
    {"long ::genesis::utils::logging_progress_value (long value=-1)", "Hack function to make sure that the value arugment in LOG_PROG is only evaluated once.\n\nWithout this function, LOG_PROG would include two appearances of its variable value, which means that a statement like LOG_PROG(++i, n) << \"of progress.\";\nwould lead to a double evaluation of the increment statement ++i. That is not intended, thus we need this hack function."},
    {"std::unique_ptr< T > ::genesis::utils::make_unique (Args &&... args)", "Returns a std::unique_ptr for a given type.\n\nSince this is not available in C++11, we need our own implementation. It is following http://herbsutter.com/gotw/_102/"},
    {"std::vector< MeanStddevPair > ::genesis::utils::matrix_col_mean_stddev (Matrix< double > const & data)", "Calcualte the column-wise mean and standard deviation of a Matrix.\n\nSee also matrix_row_mean_stddev()."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::matrix_col_minmax (Matrix< double > const & data)", "Calculate the column-wise min and max values of a Matrix.\n\nSee also matrix_row_minmax()."},
    {"Matrix< double > ::genesis::utils::matrix_multiplication (Matrix< double > const & a, Matrix< double > const & b)", "Calculate the product of two Matrices.\n\nThe two matrices need to have fitting sized, i.e., a[ l, m ] x b[ m, n ]."},
    {"std::vector< MeanStddevPair > ::genesis::utils::matrix_row_mean_stddev (Matrix< double > const & data)", "Calcualte the row-wise mean and standard deviation of a Matrix.\n\nSee also matrix_col_mean_stddev()."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::matrix_row_minmax (Matrix< double > const & data)", "Calculate the row-wise min and max values of a Matrix.\n\nSee also matrix_col_minmax()."},
    {"double ::genesis::utils::mean (const Histogram & h)", "Compute the bin-weighted arithmetic mean.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::normalize_cols (Matrix< double > & data)", "Normalize the columns of a Matrix so that all values are in the range [ 0.0, 1.0 ].\n\nThe Matrix is manipulated inline. For each column, the new values of the Matrix are calculated as $ x_{new} = \\frac{ x - x_{min} }{ x_{max} - x_{min} } $.The function returns a vector containing the min and max values of the columns before normalization, see matrix_col_minmax().\n\ndata\n\n\nInput data Matrix; normalization is done inline. \n\n\nVector containing the min and max values for each column before normalization."},
    {"std::vector< MinMaxPair< double > > ::genesis::utils::normalize_rows (Matrix< double > & data)", "Normalize the rows of a Matrix so that all values are in the range [ 0.0, 1.0 ].\n\nThe Matrix is manipulated inline. For each row, the new values of the Matrix are calculated as $ x_{new} = \\frac{ x - x_{min} }{ x_{max} - x_{min} } $.The function returns a vector containing the min and max values of the rows before normalization, see matrix_row_minmax().\n\ndata\n\n\nInput data Matrix; normalization is done inline. \n\n\nVector containing the min and max values for each row before normalization."},
    {"bool ::genesis::utils::operator& (SkipWhitespace lhs, SkipWhitespace rhs)", "And-operator to check whether a SkipWhitespace is set.\n\nTypical usage: SkipWhitespace option;\nif( option & SkipWhitespace::kTrailing ) {\n    // Do stuff...\n}\nSee SkipWhitespace for more information."},
    {"Bitvector ::genesis::utils::operator- (Bitvector const & lhs, Bitvector const & rhs)", "Set-minus of two Bitvectors."},
    {"bool ::genesis::utils::operator< (JsonDocument::const_reference lhs, JsonDocument::const_reference rhs)", "Compares whether one JSON value lhs is less than another JSON value rhs according to the following rules:\nIf lhs and rhs have the same type, the values are compared using the default < operator.Integer and floating-point numbers are automatically converted before comparisonIn case lhs and rhs have different types, the values are ignored and the order of the types is considered, see operator<(const ValueType, const ValueType). %"},
    {"bool ::genesis::utils::operator< (const JsonDocument::ValueType lhs, const JsonDocument::ValueType rhs)", "Returns an ordering that is similar to Python:\norder: null < boolean < number < object < array < stringfurthermore, each type is not smaller than itself %"},
    {"std::ostream & ::genesis::utils::operator<< (std::ostream & os, const Color & color)", "Write a textual representation of the Color the a stream, in the format \"(r, g, b)\"."},
    {"std::ostream & ::genesis::utils::operator<< (std::ostream & out, Style const & style)", "Print the properties of a Style object to a stream.\n\nThe application of Styles is usually done by invoking its operator(). However, in order to be able to show its properties at a glance, this operator instead prints them: Style s( \"blue\" );\nstd::cout << s;\nwill print this information instead of a stylized text."},
    {"bool ::genesis::utils::operator== (JsonDocument::const_reference lhs, JsonDocument::const_reference rhs)", "Compares two JSON values for equality according to the following rules:\nTwo JSON values are equal if (1) they are from the same type and (2) their stored values are the same.Integer and floating-point numbers are automatically converted before comparison. Floating-point numbers are compared indirectly: two floating-point numbers f1 and f2 are considered equal if neither f1 > f2 nor f2 > f1 holds.Two JSON null values are equal. %"},
    {"T ::genesis::utils::parse_float (utils::InputStream & source)", "Read a floating point number from a stream and return it.\n\nThe number is expected to be in the following format: [+-][123][.456][eE[+-]789]\nThe function stops reading at the first non-fitting digit. It throws an std::overflow_error or underflow_error in case that the exponent (the part after the 'E') does not fit into integer value range."},
    {"T ::genesis::utils::parse_integer (utils::InputStream & source)", "Alias for parse_signed_integer()."},
    {"std::string ::genesis::utils::parse_number_string (utils::InputStream & source)", "Read a general number string from an input stream.\n\nThe function reads from the input as long as it is a valid number of the format [+-][123][.456][eE[+-]789]\nand returns this string. This is useful for intermediately parsing a number and then checking whether it is valid. Use parse_float() to turn such a number string into an actual float/double."},
    {"std::string ::genesis::utils::parse_quoted_string (utils::InputStream & source, bool use_escapes=true, bool use_twin_quotes=false, bool include_qmarks=false)", "Read a string in quotation marks from a stream and return it.\n\nThe first char of the stream is considered to be the opening quotation mark. Everything up until the closing quotation mark (the same char again, whatever it is) is then read. The stream is then pointing to the char right after the closing quotation mark.If the string ends prematurely, i.e., without the closing quotation mark, or right after a backslash if use_escapes is used, the function throws an std::runtime_error.\n\nsource\n\n\nStream to read from.\n\n\n\nuse_escapes\n\n\nIf this optional parameter is set to true, chars preceeded by a backslash \\ are considered to be \"escaped\". If the char following the backslash is any of r, n or t, it is turned into its respective white space equivalent, while all other chars are copied verbatim to the return string. Thus, by escaping it, a the string can also include the quotation mark itself. Default of this parameter is true.\n\n\n\nuse_twin_quotes\n\n\nIf this optional parameter is set to true, the quotation mark itself can be escaped using two consecutive quotation marks. This works in addition to escaping it with a backslash (when use_escapes is used).\n\n\n\ninclude_qmarks\n\n\nThe optional parameter include_qmarks demtermines whether the quotation marks are included in the output or not. Default is false."},
    {"T ::genesis::utils::parse_signed_integer (utils::InputStream & source)", "Read a signed integer from a stream and return it.\n\nThe function expects a sequence of digits, possibly with a leading + or -. The first char after that has to be a digit, otherwise the function throws std::runtime_error. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error, or underflow_error, respectively."},
    {"T ::genesis::utils::parse_unsigned_integer (utils::InputStream & source)", "Read an unsigned integer from a stream and return it.\n\nThe function expects a sequence of digits. The current char in the stream has to be a digit, otherwise the function throws std::runtime_error. It stops reading at the first non-digit. In case the value range is too small, the function throws std::overflow_error."},
    {"PcaData ::genesis::utils::principal_component_analysis (Matrix< double > const & data, size_t components=0, PcaStandardization standardization)", "Perfom a Principal Component Analysis on a given data Matrix.\n\nPrincipal Components Analysis or the Karhunen-Loeve expansion is a classical method for dimensionality reduction or exploratory data analysis. One reference among many is: F. Murtagh and A. Heck, Multivariate Data Analysis, Kluwer Academic, Dordrecht, 1987.\n\ndata\n\n\nMatrix with the data, samples in rows, features in columns. \n\n\n\ncomponents\n\n\nIntended number of PCA components to calculate. If 0 (default), all PCA components are calculated, i.e., as many components as data has columns. \n\n\n\nstandardization\n\n\nIndicate the standardization algorithm to perfom on the data before calculating the PCA components, see PcaStandardization. \n\n\nA struct that contains the eigenvalues and corresponding eigenvectors (i.e., the PCA components), and a Matrix with the projected data. See PcaData for details."},
    {"char ::genesis::utils::read_char_or_throw (InputStream & source, char criterion, SkipWhitespace skip_ws)", "Lexing function that reads a single char from the stream and checks whether it equals the provided one.\n\nIf not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned. For a similar function that checks the value of the current char but does not advance in the stream, see affirm_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"char ::genesis::utils::read_char_or_throw (InputStream & source, std::function< bool(char)> criterion, SkipWhitespace skip_ws)", "Lexing function that reads a single char from the stream and checks whether it fulfills the provided criterion.\n\nIf not, the function throws std::runtime_error. The stream is advanced by one position and the char is returned. For a similar function that checks the value of the current char but does not advance in the stream, see affirm_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"std::string ::genesis::utils::read_to_end_of_line (InputStream & source)", "Lexing function that reads until the end of the line (i.e., to the new line char), and returns the read chars (excluding the new line char).\n\nThe stream is left at the new line char. If the stream is already at its last line, this function reads to the end of the stream."},
    {"std::string ::genesis::utils::read_until (InputStream & source, char criterion)", "Lexing function that reads from the stream until its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_until (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream until its current char fulfills the provided criterion. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (InputStream & source, char criterion)", "Lexing function that reads from the stream while its current char equals the provided one. The read chars are returned."},
    {"std::string ::genesis::utils::read_while (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that reads from the stream while its current char fulfills the provided criterion. The read chars are returned."},
    {"TridiagonalDecompositionData ::genesis::utils::reduce_to_tridiagonal_matrix (Matrix< double > & data)", "Triangular decomposition of a symmetric matrix.\n\nThis function performs an intermediate step that is usually followed by an execution of the tridiagonal_ql_algorithm().It uses the Householder reduction of matrix a to tridiagonal form, according to Martin et al., Num. Math. 11, 181-195, 1968.\nRef: Smith et al., Matrix Eigensystem Routines -- EISPACK Guide\nSpringer-Verlag, 1976, pp. 489-494.\nW H Press et al., Numerical Recipes in C, Cambridge U P, 1988, pp. 373-374.\nThere, the function is called tred2().The implementation of this function is largely borrowed from http://www.classification-society.org/csna/mda-sw/pca.c published as Public Domain by Fionn Murtagh.\n\ndata\n\n\nInput data matrix. Operations are performed inline, that is, the matrix is changed during execution of the function."},
    {"std::string ::genesis::utils::repeat (std::string const & word, size_t times)", "Take a string and repeat it a given number of times."},
    {"std::string ::genesis::utils::replace_all (std::string const & text, std::string const & search, std::string const & replace)", "Return a copy of a string, where all occurrences of a search string are replaced by a replace string."},
    {"std::string ::genesis::utils::replace_all_chars (std::string const & text, std::string const & search_chars, char replace)", "Replace all occurrences of the search_chars in text by the replace char."},
    {"double ::genesis::utils::round_to (double x, size_t accuracy_order)", "Retun the value of x, rounded to the decimal digit given by accuracy_order."},
    {"std::string ::genesis::utils::sanitize_filname (std::string const & filename)", "Remove or replace all invalid parts of a filename.\n\nSimilar to is_valid_filname(), this function is not meant to be an ultimate solution to valid filenames. See there for details.The function is meant to be called on the file name itself, without the directory path leading to it. File extensions are allowed. Thus, you might need to call file_basename() before in order to get the file name without the path.This function does the following:\nAll non-printable characters are removed.Spaces at the beginning and end are removed.All invalid chars are replaced by an underscore. See is_valid_filname() for a list of those chars.\nIf after this procedure the filename is empty, an exception is thrown. This is meant to save the user from checking this, or from running into trouble when trying to write to this \"file\" - because an empty filename will point to a directory name."},
    {"double ::genesis::utils::sigma (const Histogram & h)", "Compute the bin-weighted standard deviation.\n\nThe histogram is regarded as a probability distribution. Negative bin values are ignored for the purposes of this calculation. The accuracy of the result is limited by the bin width."},
    {"constexpr int ::genesis::utils::signum (T x, std::false_type )", "Implementation of signum(T x) for unsigned types. See there for details."},
    {"constexpr int ::genesis::utils::signum (T x, std::true_type )", "Implementation of signum(T x) for signed types. See there for details."},
    {"constexpr int ::genesis::utils::signum (T x)", "Get the sign of a value, which is either -1, 0, or 1.\n\nWorks for all numerical types. We use two tagged implementations for signed and unsigned types in order to avoid compiler warnings. See http://stackoverflow.com/questions/1903954/is-there-a-standard-sign-function-signum-sgn-in-c-c for details."},
    {"void ::genesis::utils::skip_to_end_of_line (InputStream & source)", "Lexing function that advances the stream to the end of the line, i.e., to the new line char.\n\nIf the stream is already at its last line, this function moves to the end of the stream."},
    {"void ::genesis::utils::skip_until (InputStream & source, char criterion)", "Lexing function that advances the stream until its current char equals the provided one."},
    {"void ::genesis::utils::skip_until (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream until its current char fulfills the provided criterion."},
    {"void ::genesis::utils::skip_while (InputStream & source, char criterion)", "Lexing function that advances the stream while its current char equals the provided one."},
    {"void ::genesis::utils::skip_while (InputStream & source, std::function< bool(char)> criterion)", "Lexing function that advances the stream while its current char fulfills the provided criterion."},
    {"std::vector< size_t > ::genesis::utils::sort_indices (RandomAccessIterator first, RandomAccessIterator last, Comparator comparator)", "Get the indices to the sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use std::stable_sort instead, see stable_sort_indices()."},
    {"std::vector< size_t > ::genesis::utils::sort_indices (RandomAccessIterator first, RandomAccessIterator last)", "Get the indices to the sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use std::stable_sort instead, see stable_sort_indices()."},
    {"std::vector< std::string > ::genesis::utils::split (std::string const & str, std::string const & delimiters, const bool trim_empty)", "Spilt a string int parts, given a set of delimiter chars.\n\nThe string str is split using any of the chars in delimiters and returned as a vector of strings. If trim_empty is set, empty strings resulting from adjacent delimiter chars are excluded from the output."},
    {"std::vector< size_t > ::genesis::utils::stable_sort_indices (RandomAccessIterator first, RandomAccessIterator last, Comparator comparator)", "Get the indices to the stable sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the stable sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: stable_sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in stable sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use normal std::sort instead, see sort_indices()."},
    {"std::vector< size_t > ::genesis::utils::stable_sort_indices (RandomAccessIterator first, RandomAccessIterator last)", "Get the indices to the stable sorted order of the given range.\n\nThis function returns a list of indices into the given range, so that their order gives the stable sorted content of the elements in [ first, last ), using std::less for comparisons.For example, for( auto i: stable_sort_indices(v) ) {\n    cout << *( first + i ) << endl;\n}\noutputs the elements in the range in stable sorted order, without actually moving any elements in the range. This is useful if the same sorting order needs to be applied to some other container.There is also an overload of this function that takes an additional parameter comparator. It can be used to specify the function for comparing two values of the range.Furthermore, there are variants that use normal std::sort instead, see sort_indices()."},
    {"std::vector< MeanStddevPair > ::genesis::utils::standardize_cols (Matrix< double > & data, bool scale_means=true, bool scale_std=true)", "Standardize the columns of a Matrix by subtracting the mean and scaling to unit variance.\n\nThe function performs a column-wise z-transformation on the given data.The function returns a vector containing the mean and standard deviation of the columns before standardization, see MeanStddevPair. If both scale_means and scale_std are set to false, the original data is not manipulated, while the returned vector still contains the means and standard deviations. See also matrix_col_mean_stddev().\n\ndata\n\n\nInput data Matrix; standardizing is done inline. \n\n\n\nscale_means\n\n\nIf true (default), center the data by subtracting the mean per column. \n\n\n\nscale_std\n\n\nIf true (default), scale the data to unit variance (or equivalently, unit standard deviation) per column. \n\n\nVector containing the mean and standard deviation for each column before standardization."},
    {"std::vector< MeanStddevPair > ::genesis::utils::standardize_rows (Matrix< double > & data, bool scale_means=true, bool scale_std=true)", "Standardize the rows of a Matrix by subtracting the mean and scaling to unit variance.\n\nThe function performs a row-wise z-transformation on the given data.The function returns a vector containing the mean and standard deviation of the rows before standardization, see MeanStddevPair. If both scale_means and scale_std are set to false, the original data is not manipulated, while the returned vector still contains the means and standard deviations. See also matrix_row_mean_stddev().\n\ndata\n\n\nInput data Matrix; standardizing is done inline. \n\n\n\nscale_means\n\n\nIf true (default), center the data by subtracting the mean per column. \n\n\n\nscale_std\n\n\nIf true (default), scale the data to unit variance (or equivalently, unit standard deviation) per column. \n\n\nVector containing the mean and standard deviation for each column before standardization."},
    {"bool ::genesis::utils::starts_with (std::string const & text, std::string const & start)", "Return whether a string starts with another string."},
    {"Matrix< double > ::genesis::utils::sums_of_squares_and_cross_products_matrix (Matrix< double > const & data)", "Calculate the Sums of Squares and Cross Products Matrix (SSCP Matrix)."},
    {"void ::genesis::utils::swap_cols (Matrix< T > & data, size_t col_a, size_t col_b)", "Swap (interchange) two columns of a Matrix, given their indices."},
    {"void ::genesis::utils::swap_rows (Matrix< T > & data, size_t row_a, size_t row_b)", "Swap (interchange) two rows of a Matrix, given their indices."},
    {"std::string ::genesis::utils::tail (std::string const & text, size_t lines)", "Return the last lines of the text."},
    {"std::string ::genesis::utils::to_lower (std::string const & str)", "Return an all-lowercase copy of the given string, locale-aware."},
    {"char ::genesis::utils::to_lower_ascii (char c)", "Return the lower case of a given char, ascii-only."},
    {"std::string ::genesis::utils::to_lower_ascii (std::string const & str)", "Return an all-lowercase copy of the given string, ascii-only."},
    {"void ::genesis::utils::to_lower_ascii_inplace (std::string & str)", "Turn the given string to all-lowercase, ascii-only."},
    {"void ::genesis::utils::to_lower_inplace (std::string & str)", "Turn the given string to all-lowercase, locale-aware."},
    {"std::string ::genesis::utils::to_nucleic_acids (TwobitVector const & vec)", "Turn a TwobitVector into its string representation of nucleic acids."},
    {"std::string ::genesis::utils::to_string (T const & v)", "Return a string representation of a given value.\n\nThis function template is a drop-in replacement for std::to_string, with the difference that it treats floating point numbers more nicely: Instead of printing a fixed amount of digits, it only prints digits without trailing zeros.If you also want to round the value, see to_string_precise() and to_string_rounded().As it uses operator << on the given value, it is suitable for any class or value for which this stream operator is available. Thus, this function can also be used for conveniently returning a string where otherwise some stream operations would have been necessary."},
    {"std::string ::genesis::utils::to_string_precise (double value, const int precision)", "Return a precise string representation of the input value, using the provided precision value (determining its decimal places).\n\nThis function rounds the value to the given precision, and then returns its string representation with possible trailing zeros. Thus, it uses fixed precision. This is useful for e.g., output in a table format.For a version of this function that truncates trailing zeros, see to_string_rounded(). Also, use to_string() if you do not want to round the value at all."},
    {"std::string ::genesis::utils::to_string_rounded (double value, const int precision)", "Return a string representation of the input value, using the provided precision value (determining its decimal places) to round, and truncate trailing zeros.\n\nThis function rounds the value to the given precision, and then returns its string representation without trailing zeros. This is useful for output that keeps a certain amount of significant decimal digits, while making the output as short as possible.If you want to round, but also keep trailing zeros, see to_string_precise(). Also, use to_string() if you do not want to round the value at all."},
    {"std::string ::genesis::utils::to_upper (std::string const & str)", "Return an all-uppercase copy of the given string, locale-aware."},
    {"char ::genesis::utils::to_upper_ascii (char c)", "Return the upper case of a given char, ascii-only."},
    {"std::string ::genesis::utils::to_upper_ascii (std::string const & str)", "Return an all-uppercase copy of the given string, ascii-only."},
    {"void ::genesis::utils::to_upper_ascii_inplace (std::string & str)", "Turn the given string to all-uppercase, ascii-only."},
    {"void ::genesis::utils::to_upper_inplace (std::string & str)", "Turn the given string to all-uppercase, locale-aware."},
    {"TwobitVector::ValueType ::genesis::utils::translate_from_nucleic_acid (char site)", "Translate a char into TwobitVector::ValueType.\n\nValid chars are A, C, G, T, and their lower case variants."},
    {"char ::genesis::utils::translate_to_nucleic_acid (TwobitVector::ValueType value)", "Translate a TwobitVector::ValueType into its char representation.\n\nThis gives one of the values A, C, G and T."},
    {"Matrix< T > ::genesis::utils::transpose (Matrix< T > const & data)", "Transpose a Matrix."},
    {"void ::genesis::utils::tridiagonal_ql_algorithm (Matrix< double > & data, TridiagonalDecompositionData & tri, size_t max_iterations=1000)", "Reduce a symmetric matrix to a symmetric tridiagonal matrix.\n\nUses the data and the intermediate result after executing reduce_to_tridiagonal_matrix() in order to run the algorithm. See there for details.Both parameters are modified during the algorithm. After it is finished, tri.eigenvalues contains the eigenvalus and data the associated eigenvectors of the original data.The implementation of this function is largely borrowed from http://www.classification-society.org/csna/mda-sw/pca.c published as Public Domain by Fionn Murtagh.\n\ndata\n\n\nInput data matrix. Operations are performed inline, that is, the matrix is changed during execution of the function. \n\n\n\ntri\n\n\nTridiagonal matrix coming from reduce_to_tridiagonal_matrix(). \n\n\n\nmax_iterations\n\n\nMaximum number of iterations to perform, default is 1000. If set to 0, the algorithm continues until convergence. As convergence is not given for all data, this might result in an infinite loop."},
    {"std::string ::genesis::utils::trim (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with trimmed white spaces."},
    {"std::string ::genesis::utils::trim_left (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with right trimmed white spaces."},
    {"std::string ::genesis::utils::trim_right (std::string const & s, std::string const & delimiters)", "Return a copy of the input string, with left trimmed white spaces."},
    {"std::string ::genesis::utils::xml_deescape (std::string const & txt)", "De-escape special XML characters."},
    {"std::string ::genesis::utils::xml_escape (std::string const & txt)", "Escape special XML characters."},
    {"const XmlComment * ::genesis::utils::xml_value_to_comment (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlComment if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlComment object."},
    {"const XmlElement * ::genesis::utils::xml_value_to_element (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlElement if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlElement object."},
    {"const XmlMarkup * ::genesis::utils::xml_value_to_markup (const XmlValue * v)", "Converts a pointer to an XmlValue to XmlMarkup if appropriate.\n\nThrows if the dynamic type of the object is not actually an XmlMarkup object."},
    {"constexpr T ::genesis::utils::abs_diff (T const & lhs, T const & rhs)", "Calculate the absolute differenence between two values.\n\nThis function is particularly useful for unsigned types, as subtracting them and then using std::abs() does not work for them."},
    {"void ::genesis::utils::affirm_char_or_throw (InputStream & source, char criterion, SkipWhitespace skip_ws)", "Lexing function that checks whether the current char from the stream equals the provided one.\n\nIf not, the function throws std::runtime_error. The stream is not advanced (i.e., it stays at its current position). For a similar function that reads (i.e., also advances) the current char from the stream, see read_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"void ::genesis::utils::affirm_char_or_throw (InputStream & source, std::function< bool(char)> criterion, SkipWhitespace skip_ws)", "Lexing function that checks whether the current char from the stream fulfills the provided criterion.\n\nIf not, the function throws std::runtime_error. The stream is not advanced (i.e., it stays at its current position). For a similar function that reads (i.e., also advances) the current char from the stream, see read_char_or_throw().Using the parameter skip_ws, it is possible to skip leading and/or trailing whitespaces before/after treating the criterion char. See SkipWhitespace for more information."},
    {"bool ::genesis::utils::almost_equal_relative (double lhs, double rhs, double max_rel_diff=std::numeric_limits< double >::epsilon())", "Check whether two doubles are almost equal, using a relative epsilon to compare them."},
    {"std::string ::genesis::utils::bitstring (TwobitVector const & vec)", "Return a string with a bit-representation of a TwobitVector.\n\nIt returns the words of the vector with bits in the order of the underlying integer type. This is mainly useful for debugging and testing."},
    {"std::string ::genesis::utils::bitstring (TwobitVector::WordType const & vec)", "Return a string with a bit-representation of a TwobitVector::WordType.\n\nIt returns the word with bits in the order of the underlying integer type. This is mainly useful for debugging and testing."},
    {"bool ::genesis::utils::char_is_digit (const char c)", "Return whether a char is a digit (0-9)."},
    {"bool ::genesis::utils::char_is_number_part (char const c)", "Return whether a char is valid in a number, i.e., a digit, a dot, plus, minus, or 'e'/'E'."},
    {"bool ::genesis::utils::char_is_sign (const char c)", "Return whether a char is a sign (+-)."},
    {"bool ::genesis::utils::char_match_ci (const char c1, const char c2)", "Return whether two chars are the same, case insensitive."},
    {"Color ::genesis::utils::color_from_doubles (double r, double g, double b)", "Create a Color given three doubles in the range [0.0, 1.0] for each of the components red, green and blue."},
    {"Color ::genesis::utils::color_from_hex (std::string h, std::string prefix)", "Create a Color given a hex color string in the format \"#0033ff\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If the string is not correctly formatted, an std::invalid_argument exception is thrown."},
    {"std::string ::genesis::utils::color_to_hex (const Color & c, std::string prefix, bool uppercase)", "Return a hex string representation of a Color in the format \"#0033ff\".\n\nThe hash sign in the beginning can be replaced by any given prefix. If uppercase is set to true, any outputted alphabetical chars (between A and F for hex strings) will be uppercase."},
    {"bool ::genesis::utils::contains (const C & v, const T & x)", "Returns whether a container object has a certain element.\n\nThe usage of std::find just to check for presence of a certain item is a bit cumbersome. This template simply takes any container and a value and returns true iff the value is present in the container."},
    {"Matrix< double > ::genesis::utils::correlation_matrix (Matrix< double > const & data)", "Calculate the correlation Matrix of a given data Matrix.\n\nThis is done by standardizing the mean and variance of the given data and then calculating the sums_of_squares_and_cross_products_matrix()."},
    {"size_t ::genesis::utils::count_substring_occurrences (std::string const & str, std::string const & sub)", "Return the number of non-overlapping occurrences of a substring in a string."},
    {"Matrix< double > ::genesis::utils::covariance_matrix (Matrix< double > const & data)", "Calculate the covariance Matrix of a given data Matrix.\n\nThis is done by standardizing the mean of the given data and then calculating the sums_of_squares_and_cross_products_matrix()."},
    {"std::string ::genesis::utils::current_date ()", "Returns the current date as a string in the format \"2014-12-31\"."},
    {"std::string ::genesis::utils::current_time ()", "Returns the current time as a string in the format \"13:37:42\"."},
    {"std::string ::genesis::utils::deescape (std::string const & text)", "Return a string where backslash-escaped characters are transformed into their respective string form.\n\nAll occurrences of backslash + char in the string are de-escaped. That is, all \\n, \\t and \\r are turned into their respective control sequences, while all other chars folloing a backslash are translated into the char itself (so that e.g., quotation marks or backslashes themself can be escaped).Also see deescape( char c )."},
    {"char ::genesis::utils::deescape (char c)", "Return the de-escaped char for a backslash-escaped char.\n\nThe function takes the char that follows a backslash in an escaped string and returns its de-escaped char. That is, n is turned into a new line (\\n), t is turned into a tab (\\t) and r is turned into a carrier return (\\r). All other chars (e.g., quotation marks or the backslash itself) are simply returned as-is."},
    {"void ::genesis::utils::dir_create (std::string const & path)", "Create a directory.\n\nIf the directory already exists, nothing happens. If the path exists, but is not a directory, a std::runtime_error is thrown. If the creation fails for some other reason, also a std::runtime_error is thrown."},
    {"bool ::genesis::utils::dir_exists (std::string const & dir)", "Return true iff the directory exists."},
    {"std::vector< std::string > ::genesis::utils::dir_list_contents (std::string const & dir)", "Get a list of files and directories in a directory.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_contents (std::string const & dir, std::string const & regex)", "Get a list of all files and directories in a directory whose name matches a regular expression.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_directories (std::string const & dir)", "Get a list of directories in a directory.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_directories (std::string const & dir, std::string const & regex)", "Get a list of all directories in a directory whose name matches a regular expression.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_files (std::string const & dir)", "Get a list of files in a directory.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::vector< std::string > ::genesis::utils::dir_list_files (std::string const & dir, std::string const & regex)", "Get a list of all files in a directory whose name matches a regular expression.\n\nIf the directory is not readable, the function throws std::runtime_error."},
    {"std::string ::genesis::utils::dir_normalize_path (std::string const & path)", "Normalize a dir name, i.e., make sure that the given path ends with exaclty one slash."},
    {"bool ::genesis::utils::ends_with (std::string const & text, std::string const & ending)", "Return whether a string ends with another string."},
    {"bool ::genesis::utils::equals_ci (std::string const & lhs, std::string const & rhs)", "Compare two strings case insensitive."},
    {"void ::genesis::utils::erase_if (Container & c, UnaryPredicate p)", "Erases all elements from the container that satisfy a given predicate. An element is erased, if the predicate evaluates to true for it. The predicate needs to have a signature similar to (T const&)->bool.\n\nc\n\n\nThe container to modify. \n\n\n\np\n\n\nThe predicate to satisfy."},
    {"std::string ::genesis::utils::escape (std::string const & text)", "Return a string where special chars are replaces by their escape sequence.\n\nAll new lines are transformed into either \\r or \\n, tabs into \\t. Double quotation marks are preceeded by a backslash, also the backslash itself will be escaped, so that \"</tt> becomes <tt>\\\\\" and \\ becomes \\\\."},
    {"void ::genesis::utils::file_append (std::string const & content, std::string const & filename)", "Append the content of a string to a file.\n\nIf the file is not writable, the function throws std::runtime_error."},
    {"bool ::genesis::tree::all_equal (TreeSet const & tset, std::function< bool(TreeNode const &, TreeNode const &)> node_comparator, std::function< bool(TreeEdge const &, TreeEdge const &)> edge_comparator)", "Compare whether all Trees in a TreeSet are equal using a given comparator functional.\n\nSee Tree::equal() for more information."},
    {"bool ::genesis::tree::all_identical_topology (TreeSet const & tset)", "Compare whether all Trees in a TreeSet are equal using their default comparision operators for nodes and edges.\n\nReturn true iff all Trees in a TreeSet have an identical topology."},
    {"Tree ::genesis::tree::average_branch_length_tree (TreeSet const & tset)", "Return a Tree where the branch lengths are the average of the Trees in the TreeSet, given that they all have the same topology.\n\nThe function works only under the following conditions: * All trees must have the same topology.\n* The TreeType must provide a data member `branch_length` for the edges.\nOtherwise, the function throws an std::runtime_error. It does not check for node names, but the returned tree will contain the names of the first tree in the set.TODO this function assumes that the tree edge has a branch_length. move it to default tree."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeNode const & node)", "Return whether the TreeNode belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeNode const & node, Tree const & tree)", "Return whether the TreeNode belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeEdge const & edge)", "Return whether the TreeEdge belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeEdge const & edge, Tree const & tree)", "Return whether the TreeEdge belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (Tree const & tree, TreeLink const & link)", "Return whether the TreeLink belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"bool ::genesis::tree::belongs_to (TreeLink const & link, Tree const & tree)", "Return whether the TreeLink belongs to the Tree, i.e., whether it is owned by the Tree."},
    {"std::vector< double > ::genesis::tree::branch_lengths (Tree const & tree)", "Get a vector of all branch lengths of a Tree, index by the edge index."},
    {"double ::genesis::tree::center_masses_on_branches (EmdTree & tree)", "Accumulate all masses of the Tree on the centers of their edges. Return the work (mass times distance) that was needed to move the masses to the centers."},
    {"std::vector< std::pair< TreeNode const *, size_t > > ::genesis::tree::closest_leaf_depth_vector (const Tree & tree)", "Returns a vector containing the closest leaf node for each node, measured in number of edges between them and its depth (number of edges between them).\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node (with respect to its depth) and the second element its depth with respect to the node at the given index of the vector. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).Thus, leaf nodes will have a pointer to themselves and a depth value of 0, and for all other nodes the depth will be the number of edges between it and the closest leaf node.There might be more than one leaf with the same depth to a given node. In this case, an arbitrary one is used."},
    {"std::vector< std::pair< TreeNode const *, double > > ::genesis::tree::closest_leaf_distance_vector (Tree const & tree)", "Return a vector containing the closest leaf node for each node, using the branch_length as distance measure.\n\nThe vector is indexed using the node().index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node of the node at the index, measured using the branch_length; the second element of the pair is the distance value itself. Thus, leaf nodes will have a pointer to themselves and a distance value of 0."},
    {"Tree ::genesis::tree::convert (Tree const & source, std::function< std::unique_ptr< BaseNodeData >(BaseNodeData const &node_data)> node_data_converter, std::function< std::unique_ptr< BaseEdgeData >(BaseEdgeData const &edge_data)> edge_data_converter)", "Create a tree with the same topology as the source tree, while converting its data.\n\nThis function takes the given source Tree (possibly with different data types at the nodes and edges), and copies its topology (i.e., all links, nodes and edges, and their structure) to the newly created result tree.The data types are then converted using the two provided functions for the node data type and edge data type, respectively. If a node or an edge does not have data (i.e., the data pointer is a nullptr), the converter functions are not called, but the data of the new tree at that node or edge is also set to a nullptr."},
    {"EmdTree ::genesis::tree::convert_default_tree_to_emd_tree (DefaultTree const & source)", "Helper function that takes a DefaultTree (or any Tree with Node and Edge data derived from it) and turns its data into an EmdTree, that is, a Tree with EmdNodeData and EmdEdgeData."},
    {"double ::genesis::tree::deepest_distance (Tree const & tree)", "Return the longest distance from any point in the tree (on the edges) to any leaf."},
    {"double ::genesis::tree::diameter (Tree const & tree)", "Get the diameter of the tree, i.e., the longest distance between any two nodes, measured using the branch_length."},
    {"double ::genesis::tree::earth_movers_distance (EmdTree const & tree)", "Calculate the earth mover's distance of two distributions of masses on a given tree.\n\nThe earth mover's distance is typically a distance measure between two distributions. See https://en.wikipedia.org/wiki/Earth_mover's_distance for an introduction.In our case, we use distibutions of masses along the branches of a tree. Each branch can have multiple masses at different positions within [0.0, branch_length].The distance is calculated as the amount of work needed to move the masses of one distribution so that they end up in the positions of the masses of the other distribution. Work is here defined as mass times dislocation. Thus, the work ( = total distance ) is higher if either more mass has to be moved, or mass has to be moved further.The resulting distance is independed of the rooting of the tree and commutative with respect to the two mass distributions.In order to keep the calculations simple, we use the following convention for the two distributions: The masses of one distribution are stored using a positive sign, the masses of the other distribution use a negative sign. This way, only one storage for the masses can be used and the algorithm is simplyfied.The earth mover's distance is only meaningful if both mass distributions contain the same amount of total mass. Thus, as they use opposite signs, the sum of all masses on the tree should ideally be zero (apart from numerical derivations). See sum_of_masses()  and validate_emd_tree()  for functions to verify this.See earth_movers_distance( Sample const&, ... )  for an exemplary usage of this function, which applies the earth mover's distance to the placement weights (like_weight_ratio) of a PlacementTree."},
    {"TreeEdge * ::genesis::tree::edge_between (TreeNode & lhs, TreeNode & rhs)", "Return the TreeEdge between two TreeNode&s, if they are neighbours, or nullptr otherwise."},
    {"TreeEdge const * ::genesis::tree::edge_between (TreeNode const & lhs, TreeNode const & rhs)", "Return the TreeEdge between two TreeNode&s, if they are neighbours, or nullptr otherwise."},
    {"bool ::genesis::tree::equal (Tree const & lhs, Tree const & rhs, std::function< bool(TreeNode const &, TreeNode const &) > node_comparator, std::function< bool(TreeEdge const &, TreeEdge const &) > edge_comparator)", "Compares two trees for equality given binary comparator functionals for their nodes and edges.\n\nThis function does a preorder traversal of both trees in parallel and calls the comparator functionals for each position of the iterator. It returns true iff the comparators are true for every position.The comparator functionals can be either function pointers, function objects, or lambda expressions.As the traversal is done in parallel, the trees are also checked for equal topology: their elements (links, nodes, edges) have to be equal in size and the rank of each node during the traversal has to be identical in both trees. Those assumptions are made because two trees that do not have identical topology are never considered equal."},
    {"TreeNode const * ::genesis::tree::find_node (Tree const & tree, const std::string & name, bool replace_underscores)", "Finds a Node, given its name. If not found, nullptr is returned."},
    {"TreeNode * ::genesis::tree::find_node (Tree & tree, const std::string & name, bool replace_underscores)", "Finds a Node, given its name. If not found, nullptr is returned."},
    {"Tree * ::genesis::tree::find_tree (TreeSet & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"Tree const * ::genesis::tree::find_tree (TreeSet const & tset, std::string const & name)", "Get the first Tree in a TreeSet that is stored with a given name, or nullptr if not found."},
    {"double ::genesis::tree::height (Tree const & tree)", "Get the height of the tree, i.e., the longest distance from the root to a leaf, measured using the branch_length."},
    {"bool ::genesis::tree::identical_topology (Tree const & lhs, Tree const & rhs)", "Returns true iff both trees have an identical topology.\n\nThe topology is considered identical only if the order of edges is also the same in both trees. This means, although two trees might have the same number of leaves and branches, they might still be not identical (with respect to this function) when the branches appear in a different order or when the root sits at a different node."},
    {"size_t ::genesis::tree::inner_node_count (Tree const & tree)", "Count the number of inner nodes."},
    {"bool ::genesis::tree::is_bifurcating (Tree const & tree)", "Return whether the Tree is bifurcating."},
    {"size_t ::genesis::tree::leaf_node_count (Tree const & tree)", "Count the number of leaf nodes of a Tree."},
    {"double ::genesis::tree::length (Tree const & tree)", "Get the length of the tree, i.e., the sum of all branch lengths."},
    {"TreeNode const & ::genesis::tree::lowest_common_ancestor (TreeNode const & node_a, TreeNode const & node_b)", "Return the lowest common ancestor of two TreeNodes."},
    {"TreeNode & ::genesis::tree::lowest_common_ancestor (TreeNode & node_a, TreeNode & node_b)", "Return the lowest common ancestor of two TreeNodes."},
    {"int ::genesis::tree::max_rank (Tree const & tree)", "Return the highest rank of the nodes of the Tree."},
    {"utils::Matrix< double > ::genesis::tree::node_branch_length_distance_matrix (Tree const & tree)", "Return a distance matrix containing pairwise distances between all Nodes, using the branch_length of the Edges as distance measurement.\n\nThe elements of the matrix are indexed using node().index()."},
    {"std::vector< double > ::genesis::tree::node_branch_length_distance_vector (Tree const & tree, TreeNode const * node)", "Return a vector containing the distance of all nodes with respect to the given start node, where distance is measured in the sum of branch lengths between the nodes.\n\nThe vector is indexed using the node().index() for every node. Its elements give the distance of each node with respect to the given start node. The distance is the sum of branch lengths of the edges visited on the path between the two nodes.If no Node pointer is provided, the root is taken as node."},
    {"std::unordered_set< std::string > ::genesis::tree::node_names (Tree const & tree, bool leaves_only)", "Returns an unordered set of all TreeNode names of a Tree.\n\nIf leaves_only is set to true, nodes names of inner nodes are not included. Unnamed nodes (node.data.name == \"\") are always excluded. The only difference to node_names_sorted() is the type of container used for storing the result.The provided Tree needs to have TreeNodes with data types deriveed from DefaultNodeData."},
    {"std::unordered_set< std::string > ::genesis::tree::node_names (TreeSet const & tree_set, bool leaves_only)", "Returns a set of all TreeNode names of a TreeSet.\n\nThe function returns the set of all names of all Trees in the set. See node_names(...) this version of the function for details."},
    {"utils::SortedVector< std::string > ::genesis::tree::node_names_sorted (Tree const & tree, bool leaves_only)", "Returns a set of all TreeNode names of a Tree.\n\nIf leaves_only is set to true, nodes names of inner nodes are not included. Unnamed nodes (node.data.name == \"\") are always excluded. The only difference to node_names() is the type of container used for storing the result.The provided Tree needs to have TreeNodes with data types deriveed from DefaultNodeData."},
    {"utils::SortedVector< std::string > ::genesis::tree::node_names_sorted (TreeSet const & tree_set, bool leaves_only)", "Returns a set of all TreeNode names of a TreeSet.\n\nThe function returns the set of all names of all Trees in the set. See node_names_sorted(...) this version of the function for details."},
    {"utils::Matrix< size_t > ::genesis::tree::node_path_length_matrix (Tree const & tree)", "Return a matrix containing the pairwise depth of all nodes of the tree.\n\nSee node_path_length_vector(...) for more information.The vector is indexed using the node().index() for every node."},
    {"std::vector< size_t > ::genesis::tree::node_path_length_vector (Tree const & tree, TreeNode const & node)", "Return a vector containing the depth of all nodes with respect to the given start node.\n\nThe vector is indexed using the node().index() for every node. Its elements give the depth of each node with respect to the given start node. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc)."},
    {"std::vector< size_t > ::genesis::tree::node_path_length_vector (Tree const & tree)", "Return a vector containing the depth of all nodes with respect to the root node.\n\nThis function calls and returns the value of node_path_length_vector(...) using the root node of the tree."},
    {"bool ::genesis::tree::parse_newick_tree (NewickLexer::iterator & ct, const NewickLexer::iterator & end, NewickBroker & broker)", "Takes a NewickLexer in form of iterators and parses its tokens into a NewickBroker.\n\nThis function uses a pair of iterators to lexer tokens in order to process the tree, because for files with multiple trees in them (for example, when reading a TreeSet), this function has to be called with a new broker for each tree. This means, we cannot take the lexer as a whole but have to provide more finely grained access to its elements for this funtion."},
    {"std::vector< TreeLink const * > ::genesis::tree::path_to_root (TreeNode const & node)", "Helper function that finds all TreeLinks between a given TreeNode and the root of the Tree.\n\nBoth the primary_link() of the Node and the root_link() of the Tree are included in the list. The order of the list starts at the provided node and ends at the root."},
    {"void ::genesis::tree::reroot (Tree & tree, TreeLink & at_link)", "Reroot the Tree at the given TreeLink.\n\nThe function sets the root of the tree to the node of the given link. This operation does not change the topology of the tree, but merely adjusts some internal properties. The main changes are that Tree::root_node() and Tree::root_link() will return the new root after calling this function, and that tree iterators will start traversing the tree from this new root by default.There are three internal changes made to the tree data structure:\nAll primary and secondary ends of the edges on the path between the new root and the old root are swapped. This is because the edges now need to point towards the new root.Similarly, all (primary) links of the nodes on that path are changed so that they point towards the new root.Also, the (internal) root_link_index is changed to the new root link. This is used for the functions Tree::root_node() and Tree::root_link().\nThe difference between this function and its node version is that when specifying a specific link, this link is used as the (primary) link of the new root node. This way, algorithms and iterators (e.g., IteratorLevelorder) will start traversing the tree in the direction of this link by default. When specifying a node for rerooting instead, the primary link of that node is used, so that iterators start traversing the tree in the direction of the old root instead. For most applications, this does not make a difference. However, there might be cases where the start directing makes a difference. Thus, we offer both versions of this function.The link needs to be part of the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::reroot (Tree & tree, TreeNode & at_node)", "Reroot the Tree at the given TreeNode.\n\nSee this version of the function for details.The node needs to be part of the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::reroot_at_node (Tree & tree, size_t node_index)", "Reroot the Tree at the TreeNode with the given index.\n\nSee reroot(...) for details.The node index needs to be valid for the tree, otherwise an exception is thrown."},
    {"void ::genesis::tree::scale_all_branch_lengths (Tree & tree, double factor)", "Scale all branch lengths of a Tree by a given factor.\n\nThis function simply multiplies all branch lengths with the given factor. See also set_all_branch_lengths() for setting the branch lengths to a value."},
    {"void ::genesis::tree::set_all_branch_lengths (Tree & tree, double length)", "Set all branch lengths of a Tree to a given value.\n\nSee also scale_all_branch_lengths() for a scaling function."},
    {"size_t ::genesis::tree::subtree_max_path_height (Tree const & tree, TreeLink const & link)", "Calculate the height of a subtree, that is, the maximum path length to a leaf of that subtree, measured in edges between the link and the leaf."},
    {"size_t ::genesis::tree::subtree_size (Tree const & tree, TreeLink const & link)", "Return the size of the subtree defined by the given TreeLink, measured in number of nodes."},
    {"std::vector< size_t > ::genesis::tree::subtree_sizes (Tree const & tree, TreeNode const & node)", "Calculate the sizes of all subtrees as seen from the given TreeNode.\n\nThe function returns a vector with as many elements as the Tree has nodes. The vector is indexed using the TreeNode::index() values.Each value in the vector tells the size (in number of nodes) of the subtree of the correnspinding node, as seen from the given starting node, and excluding that starting node.In methaphorical words, the given starting node is used as a hook where the tree is suspended from, so that it hangs down. A subtree is then the part of the tree that \"hangs down\" from a certain node. We then count the number of nodes in each of those subtrees (that is, we examine the subtree starting at each node of the tree). For the starting node, the count is always the number of nodes of the tree minus one (because the node is not counted itself)."},
    {"std::vector< size_t > ::genesis::tree::subtree_sizes (Tree const & tree)", "Calculate the sizes of all subtrees as seen from the root of the tree.\n\nSee subtree_sizes(...) for details."},
    {"double ::genesis::tree::sum_of_masses (EmdTree const & tree)", "Return the total sum of all masses on the Tree.\n\nIn order for the earth_movers_distance() algorithm to work properly (and give meaningful results), the total mass on the tree should ideally be 0.0. This function can be used to check this.Because of numerical issues however, be aware that the result might be slighly off zero. This is okay, as it usually is in the last digits of the double."},
    {"void ::genesis::tree::transform_to_unit_branch_lengths (EmdTree & tree)", "Set all branch lengths of the Tree to 1.0, while keeping the relative position of all masses on the branches."},
    {"bool ::genesis::tree::tree_data_is (Tree const & tree)", "Check whether the data of the nodes and edges of the Tree are exactly of the specified data types.\n\nThis function returns true iff all data types of the nodes and edges match exaclty the specified types. It uses typeid() for this matching."},
    {"bool ::genesis::tree::tree_data_is_derived_from (Tree const & tree)", "Check whether the data of the nodes and edges of the Tree are derived from the specified data types.\n\nThis function returns true iff all data types of the nodes and edges are derived from the specified types. It uses dynamic_cast() for this."},
    {"bool ::genesis::tree::validate_emd_tree (EmdTree const & tree, double valid_total_mass_difference)", "Validate the data on an Tree.\n\nThis function returns true iff the data on the Tree is valid:\nThe node and edge data types have to be EmdNodeData and EmdEdgeData, respectively.The positions of the masses are in [0.0, branch_length] on their respective branches.The sum of all masses is close to 0.0, using the optional arument valid_total_mass_difference as a measure of closeness.\nThe function stops at the first encountered invalid condition and outputs a description message of the invalid value to LOG_INFO.\n\ntree\n\n\nTree to be validated. \n\n\n\nvalid_total_mass_difference\n\n\n(= 0.00001 by default) allowed difference from zero for the total sum of all masses on the tree."},
    {"bool ::genesis::tree::validate_topology (Tree const & tree)", "Validate that all internal pointers of the Tree elements (TreeLinks, TreeNodes, TreeEdges) to each other are correct and that some other invariants are met.\n\nValidate the correctness of all Tree pointers etc.This check is a bit pedantic, but better safe than sorry."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_taxopath (Taxonomy & tax, Taxopath const & taxopath)", "Find a Taxon in a Taxonomy, given its Taxopath."},
    {"void ::genesis::taxonomy::levelorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in levelorder.\n\nThe given Taxonomy is traversed in levelorder (i.e., breadth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::levelorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in levelorder.\n\nThe given Taxonomy is traversed in levelorder (i.e., breadth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"std::ostream & ::genesis::taxonomy::operator<< (std::ostream & out, Taxonomy const & tax)", "Print the contents of a Taxonomy, i.e., all nested taxa, up to a limit of 10.\n\nThis simple output function prints the first 10 nested Taxa of a Taxonomy. If you need all Taxa and more control over what you want to print, see PrinterNested class."},
    {"void ::genesis::taxonomy::postorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in postorder.\n\nThe given Taxonomy is traversed in postorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::postorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in postorder.\n\nThe given Taxonomy is traversed in postorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"void ::genesis::taxonomy::preorder_for_each (Taxonomy & tax, std::function< void(Taxon &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in preorder.\n\nThe given Taxonomy is traversed in preorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the non-const version of the function."},
    {"void ::genesis::taxonomy::preorder_for_each (Taxonomy const & tax, std::function< void(Taxon const &)> fn, bool include_inner_taxa=true)", "Apply a function to all taxa of the Taxonomy, traversing it in preorder.\n\nThe given Taxonomy is traversed in preorder (i.e., a variant of depth-first search). If include_inner_taxa is set to true (default), the provided functional is called for all Taxa . Otherwise, the functional is only called for the taxa of lowest rank, that is, for each Taxon that does not have sub-taxa.This is the const version of the function."},
    {"std::string ::genesis::taxonomy::print_pruned_taxonomy (Taxonomy const & taxonomy)", "Print a Taxonomy, highlighting those Taxa that are the pruning border, i.e., where we cut off the sub-taxa, and print their entropies next to them."},
    {"void ::genesis::taxonomy::prune_by_entropy (Taxonomy & taxonomy, size_t target_taxonomy_size, PruneByEntropySettings settings={})", "Prune a Taxonomy so that the result (approximately) contains a desired number of \"leaf\" Taxa, using the entropy of the Taxa as indicator where to prune.\n\nThe function takes a Taxonomy with data type EntropyTaxonData and a target size which indicates the desired number of \"leaf\" Taxa after pruning the Taxonomy. In the pruned Taxonomy, some Taxa are considered as belonging to the Taxonomy (have status EntropyTaxonData::PruneStatus::kInside or EntropyTaxonData::PruneStatus::kBorder), while others (deeper in the Taxonomy) are excluded (have status EntropyTaxonData::PruneStatus::kOutside). The number of border taxa (or \"leaves\") of the included Taxa then is aimed to be as close as possible to the target size.That means, this function sets the status of the Taxa, but does not remove any Taxa. All Taxa with status EntropyTaxonData::PruneStatus::kOutside are then considered to be pruned from the taxonomy.Example: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n        Tax_4\n    Tax_5\n        Tax_6\nTax_7\n    Tax_8\n    Tax_9\ncontains 5 \"leaf\" taxa, i.e., Tax_3, Tax_4, Tax_6, Tax_8 and Tax_9. If we want to prune it with a target size of 3, we might end up with either Tax_1\n    Tax_2\n    Tax_5\nTax_7\nor Tax_1\nTax_7\n    Tax_8\n    Tax_9\nas both contain 3 \"leaves\": Tax_2, Tax_5 and Tax_7 in the former case and Tax_1, Tax_8 and Tax_9 in the latter. Which of those two is used depends on the entropies of the Taxa.In the former case, Tax_1 is considered inside, Tax_2, Tax_5 and Tax_7 are border, and all other taxa are outside of the pruned Taxonomy. In the latter case, Tax_7 is inside, Tax_1, Tax_8 and Tax_9 are border, and again all others are outside.It is not always possible to prune a Taxonomy in a way the we exaclty hit the target size. The function then ends at a number of border Taxa that is closest (either below or above the target size).In order to decide which Taxa to set to inside (i.e., not include as leaves, but further resolve into their children), we use the entropies of the Taxa: We choose to split up at a current border Taxon with the highest entropy value, as long as this brings us closer to the target size.This means that the above case where we had two possible ways of splitting should be rare, as the entropies will rarely be identical with real world data sets. If this happens nonetheless, it is random which of the Taxa with equal entropy will be used.In order to control further settings, see PruneByEntropySettings."},
    {"std::string ::genesis::taxonomy::rank_from_abbreviation (char r)", "Get the taxonomic rank name given its abbreviation.\n\nThe common taxonomic ranks are used: D Domain\nK Kingdom\nP Phylum\nC Class\nO Order\nF Family\nG Genus\nS Species\nIf any of those abbreviations (case-independend) is given, the full rank name is returned. For all other input, an empty string is returned."},
    {"std::string ::genesis::taxonomy::rank_to_abbreviation (std::string const & rank)", "Get the abbreviation of a taxonomic rank name.\n\nThis function returns the abbreviation for a given common taxonomic rank name, case-independently. See rank_from_abbreviation() for a list of valid rank names. If the given rank name is invalid, an empty string is returned."},
    {"void ::genesis::taxonomy::remove_pruned_taxonomy_children (Taxonomy & taxonomy)", "Remove the children of all Taxa that are pruned, i.e, that have prune status == kOutside.\n\nThe function does not validate the status before. Use validate_pruned_taxonomy() if you are unsure whether the status is correct for all Taxa."},
    {"void ::genesis::taxonomy::remove_taxa_at_level (Taxonomy & tax, size_t level)", "Remove all Taxa  at a given level of depth in the Taxonomy hierarchy, and all their children.\n\nThat is, providing level = 0 has the same effect as calling clear_children()  on the given Taxonomy; level = 1 has this effect for the children of the given Taxonomy; and so on.See taxon_level() for more information on the level."},
    {"void ::genesis::taxonomy::reset_taxonomy_data (Taxonomy & taxonomy, bool allow_overwrite=true)", "(Re-)set all Taxon data of a Taxonomy to a specified data type.\n\nThe data is created empty, using BaseTaxonData::create(). If the optional parameter allow_overwrite is set to false (instead of the default true), the function throws an exception if a Taxon already has data assigned to it."},
    {"std::pair< std::string, std::string > ::genesis::taxonomy::resolve_rank_abbreviation (std::string const & entry)", "Resolve a combined rank and name entry of the form \"k_Bacteria\" into the full rank and the name, i.e. \"Kingdom\" and \"Bacteria\".\n\nThe function returns a pair of { \"rank\", \"name\" }.The expected format of the input string is \"x_abc\", where \"x\" is a rank name abbreviation and \"abc\" is a taxon name. If the string is in this format, it is split and the rank name abbreviation is resolved. If this abbreviation is valid, the rank (first) and the name (second) are returned. See rank_from_abbreviation() for the list of valid rank name abbreviations. The number of underscores is irrelevant, that is, C___Mammalia also works and will return { \"Class\", \"Mammalia\" }.If any of the conditions is not met (either, the string does not start with \"x_\", or the rank name abbreviation is invalid), the rank is left empty, and the whole given string is used as name. Thus, this function also works on normal taxon names."},
    {"void ::genesis::taxonomy::sort_by_name (Taxonomy & tax, bool recursive, bool case_sensitive)", "Sort the Taxa of a Taxonomy by their name.\n\nAfter calling this function, the Taxa are stored in the order given by their names. This is useful for e.g., output.\n\ntax\n\n\nTaxonomy to be sorted. \n\n\n\nrecursive\n\n\nOptional, default is true. If set to true, the sub-taxa are also sorted. If set to false, only the immediate children of the given Taxonomy are sorted. \n\n\n\ncase_sensitive\n\n\nOptional, default is false. Determines whether the name string comparison is done in a case sensitive manner or not."},
    {"void ::genesis::taxonomy::swap (Taxonomy & lhs, Taxonomy & rhs)", "Swapperator for Taxonomy."},
    {"void ::genesis::taxonomy::swap (Taxon & lhs, Taxon & rhs)", "Swapperator for Taxon."},
    {"size_t ::genesis::taxonomy::taxa_count_at_level (Taxonomy const & tax, size_t level)", "Count the number of Taxa at a certain level of depth in the Taxonomy.\n\nThe function returns how many Taxa there are in the Taxonomy that are at a certain level - that is excluding the number of their respective sub-taxa. The first/top level has depth 0.See here for a version of this function that returns those values for all levels of depth."},
    {"std::vector< size_t > ::genesis::taxonomy::taxa_count_levels (Taxonomy const & tax)", "Count the number of Taxa at each level of depth in the Taxonomy.\n\nThe function returns how many Taxa there are in the Taxonomy that are at each level - that is excluding the number of their respective sub-taxa. The first/top level has depth 0; it's count is the first element in the returned vector, and so on.This function returns the values of taxa_count_at_level( Taxonomy const& tax, size_t level ) for all levels of depth."},
    {"size_t ::genesis::taxonomy::taxa_count_lowest_levels (Taxonomy const & tax)", "Return the number of lowest level Taxa (i.e., taxa without sub-taxa) in the Taxonomy.\n\nThe function counts the number of taxa without any sub-taxa, that is, the \"leaves\" of the Taxonomy.Example: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n    Tax_4\n        Tax_5\nTax_6\n    Tax_7\ncontains 3 such taxa, i.e., Tax_3, Tax_5 and Tax_7."},
    {"std::unordered_map< std::string, size_t > ::genesis::taxonomy::taxa_count_ranks (Taxonomy const & tax, bool case_sensitive)", "Count the number of Taxa in a Taxonomy per rank.\n\nThe function gives a list of all ranks found in the Taxonomy, with a count of how many Taxa there are that have this rank.It is similar to this function, but gives the result for all ranks.If the optional parameter case_sensitive is set to true, all ranks are treated case sensitive, that is, ranks with different case produce different entries. If left at the default false, they are converted to lower case first, so that they are all treated case insensitivly."},
    {"size_t ::genesis::taxonomy::taxa_count_with_rank (Taxonomy const & tax, std::string const & rank, bool case_sensitive)", "Count the number of Taxa in a Taxonomy that have a certain rank assigned to them.\n\nThe function recursively iterates all sub-taxa of the Taxonomy and counts how many of the Taxa have the given rank assigned (case sensitive or not).See here for a version of this function that returns this number for all ranks in the Taxonomy."},
    {"size_t ::genesis::taxonomy::taxon_level (Taxon const & taxon)", "Return the level of depth of a given Taxon.\n\nThis level is the number of parents the Taxon has, excluding the Taxonomy which contains them. That means, the immediate children of a Taxonomy all have level 0, their children level 1, and so on."},
    {"bool ::genesis::taxonomy::taxonomy_data_is (Taxonomy const & taxonomy)", "Check whether the data of a Taxonomy are exactly of the specified data type.\n\nThis function returns true iff all Taxa have data of the given type, using typeid() for this matching."},
    {"bool ::genesis::taxonomy::taxonomy_data_is_derived_from (Taxonomy const & taxonomy)", "Check whether the data of a Taxonomy are derived from the specified data type.\n\nThis function returns true iff all Taxa have data whose types are derived from the specified type. It uses dynamic_cast() for this."},
    {"size_t ::genesis::taxonomy::total_taxa_count (Taxonomy const & tax)", "Return the total number of taxa contained in the Taxomony, i.e., the number of (non-unique) names of all children (recursively).\n\nExample: The Taxonomy Tax_1\n    Tax_2\n        Tax_3\n    Tax_4\n        Tax_3\nTax_5\ncontains a total of 6 taxa. The name Tax_3 appears twice and is counted twice."},
    {"bool ::genesis::taxonomy::validate (Taxonomy const & taxonomy, bool stop_at_first_error)", "Validate the internal data structures of a Taxonomy and its child Taxa Taxa.\n\nThe function validates the correctness of internal pointers, particularly, the parent pointers of Taxon. If the structure is broken, a log message is logged to LOG_INFO and the functions returns false.\n\ntaxonomy\n\n\nThe Taxonomy object to validate. \n\n\n\nstop_at_first_error\n\n\nOptional, defaults to false. By default, all errors are reported. If set to true, only the first one is logged and the function immediately returns false (or runs through and returns true if no errors are found)."},
    {"bool ::genesis::taxonomy::validate_pruned_taxonomy (Taxonomy const & taxonomy)", "Validate that the pruning status of a Taxonomy is valid.\n\nThis function expects the Taxa of the Taxonomy to have data type EntropyTaxonData. It then checks whether the pruning states are all correctly set.That means:\nTaxa with status kInside can only have children of the same status or of kBorder.Taxa with status kBorder can only have children of status kOutside.Taxa with status kOutside can only have children of the same status.\nIf any of those conditions is not met, an information about the faulty Taxon is written to LOG_INFO, and the function returns false."},
    {"double ::genesis::placement::center_of_gravity_variance (const Sample & smp, bool with_pendant_length=false)", "Calcualte the variance of the PqueryPlacements of a Sample around its Center of Gravity.\n\nThe caluclation of the variance is as follows:$ Var(X) = E[ (x - \\mu)^2 ] = \\frac{\\sum (x - \\mu)^2 \\cdot \\omega} {\\sum \\omega} $, where the weights $ \\omega $ are the like_weight_ratios of the placements.See center_of_gravity() for more."},
    {"std::vector< int > ::genesis::placement::closest_leaf_depth_histogram (Sample const & smp)", "Return a histogram representing how many placements have which depth with respect to their closest leaf node.\n\nThe depth between two nodes on a tree is the number of edges between them. Thus, the depth of a placement (which sits on an edge of the tree) to a specific node is the number of edges between this node and the closer one of the two nodes at the end of the edge where the placement sits.The closest leaf to a placement is thus the leaf node which has the smallest depth to that placement. This function then returns a histogram of how many placements (values of the vector) are there that have a specific depth (indices of the vector) to their closest leaf.Example: A return vector of histogram[0] = 2334\nhistogram[1] = 349\nhistogram[2] = 65\nhistogram[3] = 17\nmeans that there are 2334 placements that sit on an edge which leads to a leaf node (thus, the depth of one of the nodes of the edge is 0). It has 349 placements that sit on an edge where one of its nodes has one neighbour that is a leaf; and so on.The vector is automatically resized to the needed number of elements."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram_auto (Sample const & smp, double & min, double & max, const int bins=10)", "Returns the same type of histogram as closest_leaf_distance_histogram(), but automatically determines the needed boundaries.\n\nSee closest_leaf_distance_histogram() for general information about what this function does. The difference between both functions is that this one first procresses all distances from placements to their closest leaf nodes to find out what the shortest and longest are, then sets the boundaries of the histogram accordingly. The number of bins is then used to divide this range into intervals of equal size.The boundaries are returned by passing two doubles min and max to the function by reference. The value of max will actually contain the result of std::nextafter() called on the longest distance; this makes sure that the value itself will be placed in the interval.Example: double min, max;\nint    bins = 25;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\ndouble bin_size = (max - min) / bins;\nLOG_INFO << \"Histogram boundaries: [\" << min << \",\" << max << \").\";\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \"\n             << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}\nIt has a slightly higher time and memory consumption than the non-automatic version closest_leaf_distance_histogram(), as it needs to process the values twice in order to find their min and max."},
    {"std::vector< int > ::genesis::placement::closest_leaf_distance_histogram (Sample const & smp, const double min, const double max, const int bins=10)", "Returns a histogram counting the number of placements that have a certain distance to their closest leaf node, divided into equally large intervals between a min and a max distance.\n\nThe distance range between min and max is divided into bins many intervals of equal size. Then, the distance from each placement to its closest leaf node is calculated and the counter for this particular distance inverval in the histogram is incremented.The distance is measured along the branch_length values of the edges, taking the pendant_length and proximal_length of the placements into account. If the distances is outside of the interval [min,max], the counter of the first/last bin is incremented respectively.Example: double min      =  0.0;\ndouble max      = 20.0;\nint    bins     = 25;\ndouble bin_size = (max - min) / bins;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \"\n             << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}"},
    {"void ::genesis::placement::collect_duplicate_pqueries (Sample & smp)", "Find all Pqueries  that share a common name and combine them into a single Pquery containing all their collective PqueryPlacements and PqueryNames.\n\nThe function collects all Pqueries that share at least one name. This is transitive, so that for example three Pqueries with two names each like (a,b) (b,c) (c,d) will be combined into one Pquery. Thus, the transitive closure of shared names is collected.All those Pqueries with shared names are combined by simply moving all their Placements and Names into one Pquery and deleting the others. This means that at least the shared names will be doubled after this function. Also, Placements on the same edge can occur. Thus, usually merge_duplicate_names() and merge_duplicate_placements() are called after this function. The function merge_duplicates() does exaclty this, for convenience."},
    {"bool ::genesis::placement::compatible_trees (PlacementTree const & lhs, PlacementTree const & rhs)", "Return whether two PlacementTrees are compatible.\n\nThis is the case iff:\nthey have the same topology,they have the same internal structure (e.g., node indices),they have the same node names at corresponding nodes,they have the same edge nums at corresponding edges,the data types of all nodes and edges are those of a PlacementTree\nIn all other cases, false is returned."},
    {"bool ::genesis::placement::all_identical_trees (SampleSet const & sset)", "Returns true iff all Trees of the Samples in the set are identical.\n\nThis is the case if they have the same topology, node names and edge_nums. However, branch lengths are not checked, because usually those differ slightly."},
    {"std::unordered_set< std::string > ::genesis::placement::all_pquery_names (Sample const & sample)", "Return a set of all unique PqueryNames of the Pqueries  of the given sample.\n\nIf a Pquery contains multiple names, all of them are added to the set."},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::center_of_gravity (const Sample & smp, bool with_pendant_length=false)", "Calculate the Center of Gravity of the placements on a tree.\n\nThe center of gravity is the point on the tree where all masses of the placements on the one side of it times their distance from the point are equal to this sum on the other side of the point. In the following example, the hat ^ marks this point on a line with two placements: One has mass 1 and distance 3 from the central point, and one as mass 3 and distance 1, so that the product of their mass and distance to the point is the same:               3\n              |\n1             |\n|_____________|\n          ^\nIt is thus like calculating masses and torques on a lever in order to find their physical center of mass/gravity.This calculation is done for the whole tree, with the masses calculated from the like_weight_ratio and distances in terms of the branch_length of the edges and the proximal_length and (if specificed in the method parameter) the pendant_length of the placements."},
    {"double ::genesis::placement::center_of_gravity_distance (const Sample & smp_a, const Sample & smp_b, bool with_pendant_length=false)", "Calculate the distance between the two Centers of Gravity of two Samples.\n\nThe distance is measured in branch length units; for the Center of Gravity, see center_of_gravity()."},
    {"Taxon & ::genesis::taxonomy::add_from_taxopath (Taxonomy & taxonomy, Taxopath const & taxopath, bool expect_parents)", "Add a Taxon to a Taxonomy, using the taxonomic elements of a Taxopath.\n\nFor example, given a Taxopath like [ \"Animalia\", \"Vertebrata\", \"Mammalia\", \"Carnivora\" ]\nthis functions adds the following hierarchy to the Taxonomy: Animalia\n    Vertebrata\n        Mammalia\n            Carnivora\nFor any existing Taxa, nothing happens. If any (parent) Taxon in the hierarchy does not exist, it is created by default.\n\ntaxonomy\n\n\nTaxonomy to add the Taxon to. \n\n\n\ntaxopath\n\n\nA Taxopath object from which the Taxon and its parents are taken. \n\n\n\nexpect_parents\n\n\nOptional, defaults to false. If set to true, the function expects all super-taxa of the added Taxon to exists, that is, all taxa except for the last one in the hierachry. If this expectation is not met, that is, if not all super-taxa exist, an std::runtime_error exception is thrown. If left at the default (false), all necessary super-taxa are created if they do not exists yet.\n\n\nThe function returns a reference to the newly created Taxon. This is the deepest Taxon of the Taxopath; in other words, its last element."},
    {"size_t ::genesis::taxonomy::count_taxa_with_prune_status (Taxonomy const & taxonomy, EntropyTaxonData::PruneStatus status)", "Return the number of Taxa that have a certain prune status."},
    {"void ::genesis::taxonomy::expand_small_subtaxonomies (Taxonomy & taxonomy, size_t min_subtaxonomy_size)", "Expand the leaves of a pruned Taxonomy if their sub-taxonomies are smaller than the given threshold.\n\nThis function takes a Taxonomy with EntropyTaxonData on its Taxa and looks for taxa with status kBorder which have fewer than the threshold many leaves. If so, this sub-taxonomy is expaneded. This is, it is turned into taxa with status kInside for inner taxa and kBorder for leaf taxa."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_name (Taxonomy const & tax, std::string const & name)", "Find a Taxon with a given name by recursively searching the Taxonomy."},
    {"Taxon * ::genesis::taxonomy::find_taxon_by_name (Taxonomy & tax, std::string const & name)", "Find a Taxon with a given name by recursively searching the Taxonomy."},
    {"Taxon const * ::genesis::taxonomy::find_taxon_by_taxopath (Taxonomy const & tax, Taxopath const & taxopath)", "Find a Taxon in a Taxonomy, given its Taxopath."},
    {"bool ::genesis::placement::has_name (Sample const & smp, std::string const & name)", "Return true iff the given Sample contains a Pquery with a particular name, i.e., a PqueryName whose name member equals the given name."},
    {"Sample const * ::genesis::placement::find_sample (SampleSet const & sset, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"bool ::genesis::placement::has_correct_edge_nums (PlacementTree const & tree)", "Verify that the tree has correctly set edge nums.\n\nThe edge_num property of the PlacementTreeEdges is defined by the jplace standard. The values have to be assigned increasingly with a postorder traversal of the tree. This function checks whether this is the case."},
    {"bool ::genesis::placement::has_name (Pquery const & pquery, std::string const & name)", "Return true iff the given Pquery contains a particular name."},
    {"Sample * ::genesis::placement::find_sample (SampleSet & sset, std::string const & name)", "Get the first Sample in a SampleSet that has a given name, or nullptr if not found."},
    {"double ::genesis::sequence::site_information (SequenceCounts const & counts, size_t site_index, bool use_small_sample_correction=false, SiteEntropyOptions options)", "Calculate the information content at one site of a SequenceCounts object.\n\nThe information content $ R $ at site $ i $ (= site_index) is calculated as $ R_{i} = \\log_{2}( s ) - (H_{i}+e_{n}) $.Here, $ s $ is the number of possible characters in the sequences (usually, 4 for nucleic acids and 20 for amino acids), which is taken from the characters() used in the SequenceCounts object. Furthermore, $ H_{i} $ is the site_entropy() at the given site.The optional term $ e_{n} $ is the small-sample correction, calculated as $ e_{n}={\\frac{1}{\\ln {2}}}\\times {\\frac{s-1}{2n}} $, with $ n $ being the number of sequences. It is only used if use_small_sample_correction is set to true (default is false).The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"size_t ::genesis::sequence::total_length (SequenceSet const & set)", "Return the total length (sum) of all Sequences in the SequenceSet."},
    {"std::string ::genesis::sequence::translate_nucleic_acid (char code)", "Get the name of a nucleic acid given its IUPAC code.\n\nThe codes are translated as follows: A Adenine\nC Cytosine\nG Guanine\nT Thymine\nU Uracil\nW Weak\nS Strong\nM aMino\nK Keto\nR puRine\nY pYrimidine\nB not A\nD not C\nH not G\nV not T\nN any\nO omitted\nX masked\n. gap\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"bool ::genesis::sequence::validate_chars (SequenceSet const & set, std::string const & chars)", "Returns true iff all Sequences only consist of the given chars.\n\nFor presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... For example, to check whether the sequences are nucleic acids, use nucleic_acid_codes_all(). The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"std::string ::genesis::sequence::translate_amino_acid (char code)", "Get the name of a amino acid given its IUPAC code.\n\nThe codes are translated as follows: A Alanine\nB Aspartic acid or Asparagine\nC Cysteine\nD Aspartic acid\nE Glutamic acid\nF Phenylalanine\nG Glycine\nH Histidine\nI Isoleucine\nJ Leucine or Isoleucine\nK Lysine\nL Leucine\nM Methionine\nN Asparagine\nO Pyrrolysine\nP Proline\nQ Glutamine\nR Arginine\nS Serine\nT Threonine\nU Selenocysteine\nV Valine\nW Tryptophan\nY Tyrosine\nZ Glutamic acid or Glutamine\nX any\n* translation stop\n- gap\n? gap\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies_accumulator (std::map< char, size_t > const & sitehistogram, std::string const & plain_chars)", "Local helper function that turns a site histogram into base frequencies."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (Sequence const & seq, std::string const & plain_chars)", "Get the base frequencies of the sites in a Sequence given the base chars.\n\nThis returns the relative proportions of the given plain_chars to each other. Typically, the given chars come from either nucleic_acid_codes_plain() or amino_acid_codes_plain(), depending on the dataset.It is necessary to select those chars on a per-dataset basis, as it is up to the user to define the meaning of those chars."},
    {"std::string ::genesis::sequence::consensus_sequence_with_ambiguities (SequenceCounts const & counts, double similarity_factor, bool allow_gaps)", "Calculate a consensus sequence by using the most frequent characters at each site, for nucleic acid codes ACGT and their ambiguities.\n\nThe function calculates a consensus sequence for nucleic acid codes (ACGT), using their ambiguity codes (e.g., W for \"weak\" == AT) if the counts (i.e., character frequencies) are similar at a site. It uses similarity_factor to decide which counts are close enough to each other in order to be considered ambiguous.For example, with similarity_factor == 1.0, only exact matches are used, that is, if two counts are exactly the same. Let count('A') == 42 and count('T') == 42, and both other counts be 0, this results in the code W at that site. If however count('T') == 41, only A is used for the site. Thus, with similarity_factor == 1.0, this function behaves very similar to consensus_sequence_with_majorities(), except in cases were two counts are exaclty the same.On the other hand, with similarity_factor == 0.0, all codes that are present at a site are considered to be ambiguous. That is, if a site contains counts > 0 for A, G and T, the resulting site gets the code D (\"not C\").For intermediate values, e.g., the default 0.9, the value is used as a threshold to decide the ambiguities. For example, let count('A') == 42 and count('T') == 38, and both other counts be 0. Then, the allowed deviation from the maximum 42 is 0.9 * 42 = 37.8. Thus, as the count for T is above this value, those two codes are considered ambiguous, resulting in a W at that site.The optional parameter allow_gaps (default is true) behaves similar to its counterpart in consensus_sequence_with_majorities(). If set to true, the count of the gap character is also considered. If then the count of no character is within the similarity range of the gap count, the result contains a gap at that site. If however there are codes within the range (i.e., above similarity_factor * max_count), those are used instead, even if gaps are more frequent.If allow_gaps is set to false instead, gaps are not considered. That means, the ambiguities are calculated as if there were no gaps. So even if a site contains mostly gaps, but only a few other characters, those will be used. Solely all-gap sites result in a gap at that site.Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here. The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more information on the used codes.If the provided SequenceCounts object does not use nucleic acid codes, or if the similarity_factor is not within the range [ 0.0, 1.0 ], an exception is thrown."},
    {"std::string ::genesis::sequence::consensus_sequence_with_ambiguities (SequenceSet const & sequences, double similarity_factor, bool allow_gaps)", "Calculate a consensus sequence by using the most frequent characters at each site, for nucleic acid codes ACGT and their ambiguities.\n\nSee consensus_sequence_with_ambiguities(...) for details. This is merely a wrapper function that takes a SequenceSet instead of a SequenceCounts object."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SequenceCounts const & counts, bool allow_gaps, char gap_char)", "Calculate the majority rule consensus sequence by using the most frequent character at each site.\n\nThe function creates a consensus sequence by using the character at each position that has the highest count (or frequency). It does not assume any character codes. Thus, it works for all kinds of sequence codes, e.g., nucleic acid or amino acid codes.The optional parameter allow_gaps (default is true) determines whether gaps in the consensus sequence are allowed. By default, if a site consists mostly of gaps, the consensus sequence also contains a gap at that site. If however this option is set to false, the consensus sequence will contain the most frequent non-gap character, even if there are more gaps at this site than the character itself. In other words, if the parameter is set to false, gaps are treated as missing characters instead of another type of character for computing the consensus. The only exception are gaps-only sites; in this case, the resulting sites contain a gap characters even if the parameter is set to false.The optional parameter gap_char (default value '-') is used for sites where no counts are available (i.e., are all zero), or, if allow_gaps is set to true, for sites that contain mostly gaps.Furthermore, if two or more characters have the same frequency, the first one is used. That is, the one that appears first in SequenceCounts::characters().For an alternative version of this function that takes those ambiguities into account, see consensus_sequence_with_ambiguities(). Also, for a version of this function that takes a threshold for the character frequencies into account, see consensus_sequence_with_threshold(). However, both of them currently only work for nucleic acid codes (ACGT)."},
    {"std::map< char, double > ::genesis::sequence::base_frequencies (SequenceSet const & set, std::string const & plain_chars)", "Get the base frequencies of the sites in a SequenceSet given the base chars.\n\nSee the Sequence implementation of this function for details."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SequenceSet const & sequences, std::string const & characters, bool allow_gaps, char gap_char)", "Calculate the majority rule consensus sequence by using the most frequent character at each site.\n\nSee consensus_sequence_with_majorities(...) for details.This function is merely a wrapper that instead of a SequenceCount objects, takes a SequenceSet object and the set of characters to be used for counting character frequencies in the Sequences. That means, only the provided characters are counted and used for the consensus sequence. This is useful in order to get rid of errors and noise in the Sequences. For example, if you want to build a consensus sequence for a set of sequences with amino acid codes, use amino_acid_codes_plain() for set characters parameter."},
    {"double ::genesis::placement::total_multiplicity (Pquery const & pqry)", "Return the sum of all multiplicities  of the Pquery."},
    {"double ::genesis::placement::total_multiplicity (Sample const & sample)", "Return the sum of all multiplicities  of all the Pqueries of the Sample."},
    {"std::vector< PqueryPlacement const * > ::genesis::placement::placements_per_edge (Sample const & smp, PlacementTreeEdge const & edge)", "Return a vector of all PqueryPlacements that are placed on the given PlacementTreeEdge.\n\nThis functions iterates over all placements and collects those that are placed on the given edge. In case that this is needed for multiple edges, it will be faster to use placements_per_edge( Sample ) instead.This map is invalidated after calling Pquery::add_placement()."},
    {"std::vector< PqueryPlain > ::genesis::placement::plain_queries (Sample const & smp)", "Return a plain representation of all pqueries of this map.\n\nThis method produces a whole copy of all pqueries and their placements (though, not their names) in a plain POD format. This format is meant for speeding up computations that need access to the data a lot - which would require several pointer indirections in the normal representation of the data.This comes of course at the cost of reduced flexibility, as all indices are fixed in the plain data structre: changing a value here will not have any effect on the original data or even on the values of the pqueries. Thus, most probably this will lead to corruption. Therefore, this data structure is meant for reading only."},
    {"void ::genesis::placement::learn_per_edge_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistributionso that they follow the same distribution of placement weight per edge as a given Sample.\n\nThis method \"learns\" how the placements on the given Sample are distributed by summing up their weight per edge and using this as weights. This way, the given distribution can be imitated by randomly generated placements.The method is intended to be used on a Tree that has the same topology as the one that is given with the Sample, otherwise the Edge indices will not fit."},
    {"double ::genesis::sequence::averaged_entropy (SequenceCounts const & counts, bool only_determined_sites=false, SiteEntropyOptions per_site_options)", "Return the averaged sum of all site entropies.\n\nThis function sums up up the site_entropy() for all sites of the SequenceCount object and returns the average result per site.If only_determined_sites is false (default), the average is calculated using the total number of sites, that is, it simply calculates the average entropy per site.If only_determined_sites is true, the average is calculated using the number of determined sites only; that is, sites that only contain zeroes in all counts are skipped. Those sites do not contribute entropy anyway. Thus, it calcuates the average entropy per determiend site.The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"double ::genesis::sequence::absolute_entropy (SequenceCounts const & counts, SiteEntropyOptions per_site_options)", "Return the sum of all site entropies.\n\nThis function simply sums up up the site_entropy() for all sites of the SequenceCount object. The function additionally takes optional flags to refine the site entropy calculation, see SiteEntropyOptions for their explanation."},
    {"std::string ::genesis::sequence::amino_acid_codes_all ()", "Return all valid amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWYBJZX*-?\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_plain ()", "Return all plain amino acid codes. Those are \"ACDEFGHIKLMNOPQRSTUVWY\"."},
    {"std::map< char, utils::Color > ::genesis::sequence::amino_acid_colors ()", "Return a map of Colors for each amino acid code.\n\nThis function gives a Color for each amino acid code."},
    {"std::string ::genesis::sequence::amino_acid_codes_degenerated ()", "Return all degenerated amino acid codes. Those are \"BJZ\"."},
    {"std::string ::genesis::sequence::amino_acid_codes_undetermined ()", "Return all undetermined amino acid codes. Those are \"X*-?\"."},
    {"std::map< char, std::string > ::genesis::sequence::amino_acid_text_colors ()", "Return a map of text colors for each amino acid code.\n\nThis function gives a color name usable for utils::Style for each amino acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"void ::genesis::placement::set_random_edges (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of a SimulatorEdgeDistribution randomly to either 0.0 or 1.0, so that a random subset of edges is selected (with the same probability for each selected edge).\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::set_random_edges (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution randomly to either 0.0 or 1.0, so that a random subset of edges is selected (with the same probability for each selected edge)."},
    {"size_t ::genesis::placement::set_random_subtree_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for a randomly chosen subtree, all others to 0.0.\n\nReturns the index of the chosen edge."},
    {"size_t ::genesis::placement::total_placement_count (Sample const & smp)", "Get the total number of PqueryPlacements in all Pqueries  of the given Sample."},
    {"bool ::genesis::placement::validate (Sample const & smp, bool check_values, bool break_on_values)", "Validate the integrity of the pointers, references and data in a Sample object.\n\nReturns true iff everything is set up correctly. In case of inconsistencies, the function stops and returns false on the first encountered error.If check_values is set to true, also a check on the validity of numerical values is done, for example that the proximal_length is smaller than the corresponding branch_length. If additionally break_on_values is set, validate() will stop on the first encountered invalid value. Otherwise it will report all invalid values to the log stream."},
    {"double ::genesis::placement::total_placement_mass_with_multiplicities (Sample const & smp)", "Get the mass of all PqueryPlacements of the Sample, using the multiplicities  as factors.\n\nThis function returns the summed mass of all PqueryPlacements in all Pqueries  of the given Sample, where mass is measured by like_weight_ratio, and the mass of each Pquery is multiplied by the sum of the multiplicities  of this Pquery.This method returns the same value as total_placement_mass() in case that the multiplicity is left at its default value of 1.0."},
    {"tree::TreeSet ::genesis::placement::tree_set (SampleSet const & sset)", "Return a TreeSet containing all the trees of the SampleSet."},
    {"double ::genesis::placement::total_placement_mass (Sample const & smp)", "Get the summed mass of all PqueryPlacements in all Pqueries  of the given Sample, where mass is measured by the like_weight_ratios of the PqueryPlacements.\n\nBe aware that this function only gives the pure sum of the like_weight_ratios. See total_placement_mass_with_multiplicities() for a version of this function, which also takes the multiplicities  of the Pqueries into account."},
    {"void ::genesis::placement::set_depths_distributed_weights (Sample const & sample, std::vector< double > const & depth_weights, SimulatorEdgeDistribution & edge_distrib)", "Set the weights so that they follow a given depth distribution of the edges in the PlacementTree.\n\nThe depth_weights vector provides weights for each level of depth for an edge in the tree. This means, each edge which is adjacent to a leaf node (speak: it has depth 0) will use the weight at position 0; edges which are one level deeper in the tree will get the weight at position 1, and so on.This method can conveniently be used with the output of closest_leaf_weight_distribution() called on some exemplary Sample. This way, it will mimic this sample in terms of the depths distribution of the placements: E.g., if the original sample (the one where the histrogram results were taken from and used as input for this method) has many placements near the leaves, so will the simulated one. See set_depths_distributed_weights( Sample const& sample, SimulatorEdgeDistribution& edge_distrib ) for a version of this function which does exaclty that."},
    {"void ::genesis::sequence::filter_min_sequence_length (SequenceSet & set, size_t min_length)", "Remove all Sequences from the SequenceSet whose length is below the given min_length.\n\nSee also filter_max_sequence_length() and filter_min_max_sequence_length()."},
    {"Sequence const * ::genesis::sequence::find_sequence (SequenceSet const & set, std::string const & label)", "Return a pointer to a Sequence with a specific label, or nullptr iff not found."},
    {"utils::Bitvector ::genesis::sequence::gap_sites (Sequence const & seq, std::string const & gap_chars)", "Return a Bitvector that is true where the Sequence has a gap and false where not.\n\nThe gap_chars are used case-insensitively to determine what is considerted to be a gap. By default, nucleic_acid_codes_undetermined() are used, but any other set of characters is allowed."},
    {"double ::genesis::sequence::gapyness (SequenceSet const & set, std::string const & gap_chars)", "Return the \"gapyness\" of the Sequences, i.e., the proportion of gap chars and other completely undetermined chars to the total length of all sequences.\n\nThis function returns a value in the interval 0.0 (no gaps and undetermined chars at all) and 1.0 (all chars are undetermined). See nucleic_acid_codes_undetermined() and amino_acid_codes_undetermined() for presettings of gap character that can be used here depending on the data set type. The chars are treated case-insensitive. In the special case that there are no sequences or sites, 0.0 is returned."},
    {"utils::Bitvector ::genesis::sequence::gap_sites (SequenceSet const & set, std::string const & gap_chars)", "Return a Bitvector that is true where all Sequences in the SequenceSet have a gap and false where not, that is, where at least on Sequence is not a gap.\n\nThe gap_chars are used case-insensitively to determine what is considerted to be a gap. By default, nucleic_acid_codes_undetermined() are used, but any other set of characters is allowed."},
    {"void ::genesis::sequence::merge_duplicate_sequences (SequenceSet & set, MergeDuplicateSequencesCountPolicy count_policy, std::string const & counter_prefix=\"_\")", "Merge all Sequences in a SequenceSet that have identical sites.\n\nThe merging is done by removing all but the first Sequence with identical sites. That means, the resulting \"representative\" of a set of merged Sequences has the label and metadata of the original Sequence that was first in the SequenceSet.Using the MergeDuplicateSequencesCountPolicy, it is possible to store the counts of the Sequences (i.e., how often they appeard before merging) within either the label or metadata of the Sequence, separated by counter_prefix. With the default settings, the count is appended to the label, separated by an underscore."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_all ()", "Return all valid nucleic acid codes. Those are \"ACGTUWSMKRYBDHVNOX.-?\"."},
    {"std::string ::genesis::sequence::nucleic_acid_ambiguities (char code)", "Return the possible ambiguous nucleic acid codes for a given code char.\n\nThe codes are resolved as follows: 'A' ==> \"A\"\n'C' ==> \"C\"\n'G' ==> \"G\"\n'T' ==> \"T\"\n'U' ==> \"T\"\n\n'W' ==> \"AT\"\n'S' ==> \"CG\"\n'M' ==> \"AC\"\n'K' ==> \"GT\"\n'R' ==> \"AG\"\n'Y' ==> \"CT\"\n\n'B' ==> \"CGT\"\n'D' ==> \"AGT\"\n'H' ==> \"ACT\"\n'V' ==> \"ACG\"\n\n'N' ==> \"ACGT\"\n'O' ==> \"-\"\n'X' ==> \"-\"\n'.' ==> \"-\"\n'-' ==> \"-\"\n'?' ==> \"-\"\nThe code char is treated case-insensitive. If the given code char is not valid, an std::out_of_range exception is thrown.See nucleic_acid_ambiguity_code() for a reverse version of this function. It is however not exactly the reverse, as some degenerated codes are mapped to the gap char. Thus, this function is not injective."},
    {"char ::genesis::sequence::nucleic_acid_ambiguity_code (std::string codes)", "Return the nucleic acid code that represents all given codes.\n\nThe codes are resolved as follows: \"A\"    ==> 'A'\n\"C\"    ==> 'C'\n\"G\"    ==> 'G'\n\"T\"    ==> 'T'\n\n\"AT\"   ==> 'W'\n\"CG\"   ==> 'S'\n\"AC\"   ==> 'M'\n\"GT\"   ==> 'K'\n\"AG\"   ==> 'R'\n\"CT\"   ==> 'Y'\n\n\"CGT\"  ==> 'B'\n\"AGT\"  ==> 'D'\n\"ACT\"  ==> 'H'\n\"ACG\"  ==> 'V'\n\n\"ACGT\" ==> 'N'\n\"-\"    ==> '-'\nThe given codes are treated case-insensitive and order-independent. For example, given \"tCgG\", the function still returns 'B'. However, if any of the given codes is not valid, an std::out_of_range exception is thrown.See nucleic_acid_ambiguities() for the reverse of this function."},
    {"bool ::genesis::sequence::has_unique_labels (SequenceSet const & set, bool case_sensitive=true)", "Return true iff all labels of the Sequences in the SequenceSet are unique.\n\nThe optional parameter case_sensitive controls how labels are compared. Default is true, that is, Sequences are compared case-sensitively."},
    {"bool ::genesis::sequence::has_valid_label (Sequence const & seq)", "Check whether a Sequence has a valid label.\n\nThis might be important for printing the Sequence to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label. See sanitize_label() for a function that replaces all invalid characters of the label by underscores."},
    {"bool ::genesis::sequence::is_alignment (SequenceSet const & set)", "Return true iff all Sequences in the SequenceSet have the same length."},
    {"bool ::genesis::sequence::has_valid_labels (SequenceSet const & set)", "Check whether all Sequences in a SequenceSet have valid labels.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label. See sanitize_labels() for a function that replaces all invalid characters of the labels by underscores."},
    {"bool ::genesis::sequence::is_valid_label (std::string const & label)", "Check whether a given string is a valid label for a Sequence.\n\nWhile we can work with any form of label (as long as it is a string), most file formats and consequently most programs that read them restrict the set of valid characters for labels of sequences. We thus provide this function, which uses the most common interpretation of valid labels.A label is valid if its characters have a graphical representation (i.e., isgraph() is true) and if non of these characters occurs: :,();[]'\nThus, all whitespaces, control characters, and the listed special characters are invalid. See sanitize_label() for a function that replaces all invalid characters of the label by underscores."},
    {"std::unordered_set< std::string > ::genesis::sequence::labels (SequenceSet const & set)", "Return a set of all labels of the SequenceSet."},
    {"size_t ::genesis::sequence::longest_sequence_length (SequenceSet const & set)", "Return the length of the longest Sequence in the SequenceSet."},
    {"std::string ::genesis::genesis_header ()", "Return the header for genesis.\n\nThis is simply a text version of the logo, including the current version. It can for example be displayed at the start of a program to indicate that this program uses genesis."},
    {"std::string ::genesis::genesis_license ()", "Return the genesis license boilerplate information.\n\nThis function is useful for programs with terminal interaction. In such cases, you should include a command to show this license information."},
    {"bool ::genesis::placement::compatible_trees (Sample const & lhs, Sample const & rhs)", "Return whether the PlacementTrees of two Samples are compatible.\n\nSee this version  of the function for details."},
    {"PlacementTree ::genesis::placement::convert_to_placement_tree (tree::DefaultTree const & source_tree)", "Convert a DefaultTree  into a PlacementTree.\n\nThis function returns a new tree with the same topology as the source tree, and the same node names and branch lengths. In addition, the edge_num property of the PlacementTree is established, as it is not part of the DefaultTree data."},
    {"void ::genesis::placement::copy_pqueries (Sample const & source, Sample & target)", "Copy all Pqueries  from the source Sample (left parameter) to the target Sample (right parameter).\n\nFor this method to succeed, the PlacementTrees of the Samples need to have the same topology, including identical edge_nums and node names. Otherwise, this function throws an std::runtime_error.The PlacementTree of the target Sample is not modified. If the average branch length tree is needed instead, see SampleSet::merge_all()."},
    {"double ::genesis::placement::earth_movers_distance (tree::EmdTree & emd_tree, Sample const & lhs, Sample const & rhs, bool with_pendant_length)", "Local helper function to calculate the EMD given an EmdTree.\n\nPrecondictions for calling this function:\nThe tree needs to contain EmdNodeData and EmdEdgeData on its nodes and edges.It needs to be compatible with the trees of the two given Samples.The edges must not contain any masses on them already.\nAll this is not checked but assumed to be ensured by the caller. As this function is local to this compilation unit, potential callers are limited, so this should be okay."},
    {"double ::genesis::placement::earth_movers_distance (const Sample & lhs, const Sample & rhs, bool with_pendant_length=false)", "Calculate the earth mover's distance between two Samples.\n\nThis function interprets the like_weight_ratios of the PqueryPlacements as masses distributed along the branches of a tree. It then calculates the earth mover's distance between those masses for the distrubitons induced by the two given Samples.In order to do so, first, a tree with the average branch lengths of the two PlacementTrees is calculated. This is because of numerical issues that might yield different branch lengths. This necessiates that the trees have the same topology. If not, an std::runtime_error is thrown. The masses are then distributed on this tree, using the same relative position on their branches that they had in their original trees.The calculation furthermore takes the multiplicities of the Pqueries into account. That means, pqueries with higher (total) multiplicity have a higher influence on the calculated distance.As the two Samples might have a different total number of Pqueries, the masses of the Samples are first normalized to 1.0, using all the like_weight_ratios and multiplicities of the Pqueries. As a consequence, the resulting distance will not reflect the total number of Pqueries, but only their relative (normalized) distrubution on the tree.See earth_movers_distance( EmdTree const& )  for more information on the actual distance calculation."},
    {"utils::Matrix< double > ::genesis::placement::earth_movers_distance (SampleSet const & sample_set, bool with_pendant_length=false)", "Calculate the pairwise Earth Movers Distance for all Samples in a SampleSet.\n\nThe result is a pairwise distance Matrix using the indices of the Samples in the SampleSet. See the Sample version of this function for details on this distance measure."},
    {"std::unordered_map< int, PlacementTreeEdge * > ::genesis::placement::edge_num_to_edge_map (PlacementTree const & tree)", "Return a mapping of edge_num integers to the corresponding PlacementTreeEdge object.\n\nThis function depends on the tree only and does not involve any pqueries."},
    {"std::unordered_map< int, PlacementTreeEdge * > ::genesis::placement::edge_num_to_edge_map (Sample const & smp)", "Return a mapping of edge_num integers to the corresponding PlacementTreeEdge object.\n\nThis function depends on the tree only and does not involve any pqueries."},
    {"double ::genesis::placement::edpl (Sample const & sample, Pquery const & pquery)", "Shortcut alias for expected_distance_between_placement_locations()."},
    {"std::vector< double > ::genesis::placement::edpl (Sample const & sample)", "Shortcut alias for expected_distance_between_placement_locations()."},
    {"void ::genesis::placement::filter_min_weight_threshold (Sample & smp, double threshold)", "Remove all PqueryPlacements that have a like_weight_ratio below the given threshold from all Pqueries  of the Sample."},
    {"void ::genesis::placement::filter_n_max_weight_placements (Pquery & pquery, size_t n=1)", "Remove all PqueryPlacements but the n most likely ones from the Pquery.\n\nPqueries can contain multiple placements on different branches. For example, the EPA algorithm of RAxML outputs up to the 7 most likely positions for placements to the output Jplace file by default. The property like_weight_ratio weights those placement positions so that the sum over all positions (all branches of the tree) per pquery is 1.0.This function removes all but the n most likely placements (the ones which have the highest like_weight_ratio) from the Pquery. The like_weight_ratio of the remaining placements is not changed."},
    {"void ::genesis::placement::filter_min_weight_threshold (Pquery & pquery, double threshold)", "Remove all PqueryPlacements that have a like_weight_ratio below the given threshold."},
    {"void ::genesis::placement::filter_n_max_weight_placements (Sample & smp, size_t n=1)", "Remove all PqueryPlacements but the n most likely ones from all Pqueries  in the Sample.\n\nThis function calls filter_n_max_weight_placements( Pquery& pquery, size_t n ) for all Pqueries of the Sample. See this version of the function for more information."},
    {"void ::genesis::placement::filter_pqueries_differing_names (Sample & sample_1, Sample & sample_2)", "Remove all Pqueries from the two Samples that have a name in common.\n\nThis function builds the intersection of the set of names of both Samples and removes all those Pqueries that have a PqueryName with one of those names.This is not quite the same as building the symmetric difference and keeping those elements, and, although similar, it not the opposite of filter_pqueries_intersecting_names(), because Pqueries can have multiple names."},
    {"void ::genesis::placement::filter_pqueries_intersecting_names (Sample & sample_1, Sample & sample_2)", "Remove all Pqueries from the two Samples except the ones that have names in common.\n\nThis function builds the intersection of the set of names of both Samples and only keeps those Pqueries that have a PqueryName with one of those names."},
    {"void ::genesis::placement::filter_pqueries_keeping_names (Sample & smp, std::string const & regex)", "Remove all Pqueries which do not have at least one name that matches the given regex.\n\nIf the Pquery has a PqueryName whose PqueryName::name value matches the regex, the Pquery is kept. If none of its names matches, the Pquery is removed."},
    {"void ::genesis::placement::filter_pqueries_keeping_names (Sample & smp, std::unordered_set< std::string > keep_list)", "Remove all Pqueries which do not have at least one name that is in the given keep list.\n\nIf the Pquery has a PqueryName whose PqueryName::name value is in the keep_list, the Pquery is kept. If none of its names is in the keep_list, the Pquery is removed.This is similar to filter_pqueries_removing_names(), but not quite the opposite, as Pqueries can have multiple names."},
    {"void ::genesis::placement::filter_pqueries_removing_names (Sample & smp, std::string const & regex)", "Remove all Pqueries which have at least one name that matches the given regex.\n\nIf the Pquery has a PqueryName whose PqueryName::name value matches the reges, the Pquery is removed. If none of its names matches, the Pquery is kept."},
    {"void ::genesis::placement::filter_pqueries_removing_names (Sample & smp, std::unordered_set< std::string > remove_list)", "Remove all Pqueries which have at least one name that is in the given remove list.\n\nIf the Pquery has a PqueryName whose PqueryName::name value is in the remove_list, the Pquery is removed. If none of its names is in the remove_list, the Pquery is kept.This is similar to filter_pqueries_keeping_names(), but not quite the opposite, as Pqueries can have multiple names."},
    {"Pquery const * ::genesis::placement::find_pquery (Sample const & smp, std::string const & name)", "Return the first Pquery that has a particular name, or nullptr of none has."},
    {"Pquery * ::genesis::placement::find_pquery (Sample & smp, std::string const & name)", "Return the first Pquery that has a particular name, or nullptr of none has."},
    {"void ::genesis::sequence::replace_u_with_t (Sequence & seq)", "Replace all occurrences of U by T in the sites of the Sequence.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case u is replaced by lower case t, and upper case U by upper case T."},
    {"void ::genesis::sequence::replace_u_with_t (SequenceSet & set)", "Replace all occurrences of U by T in the sites of all Sequences in the SequenceSet.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case u is replaced by lower case t, and upper case U by upper case T."},
    {"std::string ::genesis::sequence::sanitize_label (std::string const & label)", "Sanitize a label by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"void ::genesis::sequence::sanitize_label (Sequence & seq)", "Sanitize a label by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"void ::genesis::placement::merge_duplicate_placements (Pquery & pquery)", "Merge all PqueryPlacements of a Pquery that are on the same TreeEdge into one averaged PqueryPlacement.\n\nThe merging is done via averaging all values of the PqueryPlacement: likelihood, like_weight_ratio, proximal_length, pendant_length and parsimony."},
    {"void ::genesis::placement::merge_duplicate_names (Sample & smp)", "Call merge_duplicate_names() for each Pquery of the Sample."},
    {"void ::genesis::placement::merge_duplicates (Sample & smp)", "Look for Pqueries  with the same name and merge them.\n\nThis function is a wrapper that simply calls three other functions on the provided Sample: * collect_duplicate_pqueries()\n* merge_duplicate_names()\n* merge_duplicate_placements()\nSee there for more information on what they do."},
    {"void ::genesis::placement::merge_duplicate_placements (Sample & smp)", "Call merge_duplicate_placements( Pquery& ) for each Pquery of a Sample."},
    {"Sample ::genesis::placement::merge_all (SampleSet const & sset)", "Returns a Sample where all maps of this set have been merged into.\n\nFor this method to succeed, all Samples need to have the same topology, including identical edge_nums and node names. The Tree of the returned Sample has the average branch lenghts from the input trees, using TreeSet::average_branch_length_tree()."},
    {"void ::genesis::placement::merge_duplicate_names (Pquery & pquery)", "Merge all PqueryNames that have the same name property into one, while adding up their multiplicity."},
    {"void ::genesis::placement::set_uniform_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for all edges, so that each edge has the same probability of being chosen.\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::sort_placements_by_weight (Pquery & pquery)", "Sort the PqueryPlacements of a Pquery by their like_weight_ratio, in descending order (most likely first)."},
    {"void ::genesis::placement::set_random_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution for the edges randomly to a value between 0.0 and 1.0.\n\nThe number of edges is taken from the provided Sample."},
    {"void ::genesis::placement::set_random_weights (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution for the edges randomly to a value between 0.0 and 1.0."},
    {"void ::genesis::placement::set_subtree_weights (Sample const & sample, size_t link_index, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of a subtree to 1.0 and all other weights to 0.0.\n\nThe subtree is selected via the index of the link that leads away from it. As leaf nodes do not count as subtrees, the link has to belong to an inner node."},
    {"void ::genesis::placement::set_uniform_weights (size_t edge_count, SimulatorEdgeDistribution & edge_distrib)", "Sets the weights of an SimulatorEdgeDistribution to 1.0 for all edges, so that each edge has the same probability of being chosen."},
    {"std::ostream & ::genesis::placement::operator<< (std::ostream & out, Sample const & smp)", "Print a table of all Pqueries with their Placements and Names to the stream."},
    {"double ::genesis::placement::pairwise_distance (const Sample & smp_a, const Sample & smp_b, bool with_pendant_length=false)", "Calculate the normalized pairwise distance between all placements of the two Samples.\n\nThis method calculates the distance between two Samples as the normalized sum of the distances between all pairs of Pqueries  in the Sample. It is similar to the variance() calculation, which calculates this sum for the squared distances between all Pqueries of one Sample.\n\nsmp_a\n\n\nFirst Sample to which the distances shall be calculated to. \n\n\n\nsmp_b\n\n\nSecond Sample to which the distances shall be calculated to. \n\n\n\nwith_pendant_length\n\n\nWhether or not to include all pendant lengths in the calculation.\n\n\nDistance value."},
    {"std::vector< utils::Color > ::genesis::placement::placement_color_count_gradient (Sample const & smp, bool linear)", "Returns a vector with a Color for each edge that visualizes the number of placements on that edge.\n\nThe vector is indexed using the edge.index(). Each edge gets assigned a Color value with these properties:\nEdges with no placements on them are grey (RGB 128, 128, 128).Edges with placements get a color according to the relative number of placements compared to the other edges. The edge with most placements is pure red (RGB 255, 0, 0), while lower numbers of placements smoothly transition towards yellow and green edges.\nThe gradient can be controlled via the linear parameter. If set to true, the scaling of the color gradient is linar in the number of placements. If set to false (default), it is logarithmic. This way, the color resolution is higher for low placement numbers, and compressed for higher numbers. A typical distribution of placements yields only some edges with a very high number of placements, while most of the other edges have little to no placements. Thus, it is reasonable to emphasize the differences between those edges with a lower placement count - which is what the default does.See color heat_gradient() for more information."},
    {"std::pair< PlacementTreeEdge const *, size_t > ::genesis::placement::placement_count_max_edge (Sample const & smp)", "Get the number of placements on the edge with the most placements, and a pointer to this edge."},
    {"std::pair< PlacementTreeEdge const *, double > ::genesis::placement::placement_mass_max_edge (Sample const & smp)", "Get the summed mass of the placements on the heaviest edge, measured by their like_weight_ratio, and a pointer to this edge."},
    {"std::vector< size_t > ::genesis::placement::placement_count_per_edge (Sample const & sample)", "Return a vector that contains the number of PqueryPlacements per edge of the tree of the Sample.\n\nThe vector is indexed using the index of the edges."},
    {"double ::genesis::placement::variance_partial (const PqueryPlain & pqry_a, const std::vector< PqueryPlain > & pqrys_b, const utils::Matrix< double > & node_distances, bool with_pendant_length)", "Internal function that calculates the sum of distances contributed by one pquery for the variance. See variance() for more information.\n\nThis function is intended to be called by variance() or variance_thread()  it is not a stand-alone function."},
    {"void ::genesis::placement::variance_thread (const int offset, const int incr, const std::vector< PqueryPlain > * pqrys, const utils::Matrix< double > * node_distances, double * partial, bool with_pendant_length)", "Internal function that calculates the sum of distances for the variance that is contributed by a subset of the pqueries. See variance() for more information.\n\nThis function is intended to be called by variance()  it is not a stand-alone function. It takes an offset and an incrementation value and does an interleaved loop over the pqueries, similar to the sequential version for calculating the variance."},
    {"double ::genesis::placement::variance (const Sample & smp, bool with_pendant_length=false)", "Calculate the variance of the placements on a tree.\n\nThe variance is a measure of how far a set of items is spread out in its space (http://en.wikipedia.org/wiki/variance). In many cases, it can be measured using the mean of the items. However, when considering placements on a tree, this does not truly measure how far they are from each other. Thus, this algorithm applies a different method of calculating the variance in terms of squared deviations of all items from each other: $ Var(X) = \\frac{1}{n^2} \\sum_{i=1}^n \\sum_{j=1}^n \\frac{1}{2}(x_i - x_j)^2 $, where $ (x_i - x_j) $ denotes the distance between two placements.According to the formula above, each pair of placements is evaluated twice, and subsequently their distance need to be halfed when being added to the sum of distanaces. Instead of that, we calculate the distance for each pair only once, thus are able skip half the calculations, and of course skip the division by two.Furthermore, the normalizing factor $ \\frac{1}{n^2} $ of the variance usually contains the number of elements being processed. However, as the placements are weighted by their like_weight_ratio, we instead calculate n as the sum of the like_weight_ratio of all placements. In case that for each pquery the ratios of all its placements sum up to 1.0, this number will be equal to the number of pqueries (and thus be equal to the usual case of using the number of elements). However, as this is not required (placements with small ratio can be dropped, so that their sum per pquery is less than 1.0), we cannout simply use the count."},
    {"std::vector< utils::Histogram > ::genesis::placement::node_distance_histograms (Sample const & sample, size_t histogram_bins)", "Local helper function to calculate the histograms of distances from all Nodes of the Tree of a Sample to all its PqueryPlacements."},
    {"utils::Histogram ::genesis::placement::node_distance_histogram (Sample const & sample, size_t node_index, utils::Matrix< double > const & node_dists, double diameter, size_t histogram_bins)", "Local helper function to calculate a histogram of distances from each PqueryPlacement in a Sample to a given Node of the Tree."},
    {"double ::genesis::placement::node_histogram_distance (Sample const & sample_a, Sample const & sample_b, size_t histogram_bins)", "Calculate the Node Histogram Distance of two Samples."},
    {"void ::genesis::placement::normalize_weight_ratios (Sample & smp)", "Recalculate the like_weight_ratio of the PqueryPlacement&s of each Pquery in the Sample, so that their sum is 1.0, while maintaining their ratio to each other.\n\nThis function simply calls normalize_weight_ratios( Pquery& pquery ) for all Pqueries of the Sample."},
    {"void ::genesis::placement::normalize_weight_ratios (Pquery & pquery)", "Recalculate the like_weight_ratio of the PqueryPlacement&s of a Pquery, so that their sum is 1.0, while maintaining their ratio to each other."},
    {"utils::Matrix< double > ::genesis::placement::node_histogram_distance (SampleSet const & sample_set, size_t histogram_bins)", "Calculate the node_histogram_distance() for every pair of Samples in the SampleSet."},
    {"std::string ::genesis::genesis_url ()", "Return the URL of the genesis home page."},
    {"std::string ::genesis::genesis_version ()", "Return the current genesis version.\n\nWe use semantic versioning 2.0.0 for genesis.Given a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes,MINOR version when you add functionality in a backwards-compatible manner, andPATCH version when you make backwards-compatible bug fixes.\nAdditional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format."},
    {"SiteEntropyOptions ::genesis::sequence::operator| (SiteEntropyOptions lhs, SiteEntropyOptions rhs)", "Or-operator to combine two SiteEntropyOptionss.\n\nTypical usage: auto options = SiteEntropyOptions::kWeighted | SiteEntropyOptions::kNormalized;\nUse the and-operator in order to check whether an option is set."},
    {"void ::genesis::sequence::remove_sites (Sequence & seq, utils::Bitvector sites)", "Remove all sites from a Sequence where the given Bitvector is true, and keep all others.\n\nThe Bitvector needs to have the same size as the Sequence, otherwise an expection is thrown.This function is for example useful in combination with gap_sites()."},
    {"void ::genesis::sequence::replace_characters (SequenceSet & set, std::string const & search, char replacement)", "Replace all occurences of the chars in search by the replace char, for all sites in the Sequences in the given SequenceSet.\n\nThe function is case sensitive. Thus, you need to use both cases for the search string if you are unsure. The replace char is always used as is, independent of the case of the matching search char."},
    {"void ::genesis::sequence::remove_gaps (SequenceSet & set, std::string const & gap_chars)", "Remove all gap characters from the sites of the Sequences in the SequenceSet.\n\nThis function is an alias for remove_characters(), which by default uses the gap sites of nucleic_acid_codes_undetermined()."},
    {"void ::genesis::sequence::replace_characters (Sequence & seq, std::string const & search, char replacement)", "Replace all occurences of the chars in search by the replace char, for all sites in the given Sequence.\n\nThe function is case sensitive. Thus, you need to use both cases for the search string if you are unsure. The replace char is always used as is, independent of the case of the matching search char."},
    {"void ::genesis::sequence::remove_sites (SequenceSet & set, utils::Bitvector sites)", "Remove all sites from all Sequences in a SequenceSet where the given Bitvector is true, and keep all others.\n\nThe Bitvector and all Sequences need to have the same size, otherwise an expection is thrown. This check is done before any Sequence is changed. Thus, if the function throws for this reason, the Sequences are left unchanged.This function is for example useful in combination with gap_sites()."},
    {"void ::genesis::sequence::replace_t_with_u (Sequence & seq)", "Replace all occurrences of T by U in the sites of the Sequence.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case t is replaced by lower case u, and upper case T by upper case U."},
    {"void ::genesis::sequence::sanitize_labels (SequenceSet & set)", "Sanitize the labels of all Sequences in the SequenceSet by replacing all invalid characters with underscores.\n\nThis might be important for printing the Sequences to a file that needs to be read by other applications. See is_valid_label() for details on what is considered a valid label."},
    {"double ::genesis::sequence::site_entropy (SequenceCounts const & counts, size_t site_index, SiteEntropyOptions options)", "Calculate the entropy at one site of a SequenceCounts object.\n\nThe entropy $ H $ (uncertainty) at site $ i $ (= site_idx) is calculated as $ H_{i}=-\\sum f_{{c,i}}\\times \\log _{2}f_{{c,i}} $, where $ f_{c,i} $ is the relative frequency of character $ c $ at site $ i $, summed over all characters in the SequenceCounts object.The function additionally takes optional flags to refine the calculation, see SiteEntropyOptions for their explanation."},
    {"void ::genesis::placement::scale_all_branch_lengths (Sample & smp, double factor=1.0)", "Scale all branch lengths of the Tree and the position of the PqueryPlacements by a given factor.\n\nThis function calls tree::scale_all_branch_lengths() for scaling the tree, and also applies the same scaling to the PqueryPlacement::proximal_length."},
    {"void ::genesis::placement::reset_edge_nums (PlacementTree & tree)", "Reset all edge nums of a PlacementTree.\n\nThe edge_num property of the PlacementTreeEdges is defined by the jplace standard. The values have to be assigned increasingly with a postorder traversal of the tree. This function resets them so that this is established.See has_correct_edge_nums() to check whether the edge nums are already correct. This should be the case for any valid jplace file."},
    {"std::string ::genesis::placement::print_tree (Sample const & smp)", "Return a simple view of the Tree of a Sample with information about the Pqueries  on it."},
    {"void ::genesis::placement::set_depths_distributed_weights (Sample const & sample, SimulatorEdgeDistribution & edge_distrib)", "Set the weights of an SimulatorEdgeDistribution so that they follow the depth distribution of the edges in the provided Sample.\n\nThis function is similar to set_depths_distributed_weights( Sample const& sample, std::vector<int> const& depth_weights, SimulatorEdgeDistribution& edge_distrib ), but instead of using a given depth_weight vector, this vector is also estimated from the given Sample. This is done by using closest_leaf_weight_distribution(), which counts the number of placements at a given depth in the tree."},
    {"double ::genesis::placement::pquery_distance (const PqueryPlain & pqry_a, const PqueryPlain & pqry_b, const utils::Matrix< double > & node_distances, bool with_pendant_length=false)", "Calculates the normalized distance between two plain pqueries. It is mainly a helper method for distance calculations (e.g., pairwise distance, variance).\n\nFor each placement in the two pqueries, a distance is calculated, and their normalized sum is returned. Normalization is done using the mass of placements in both pqueries.The distance between two placements is calculated as the shortest path between them. This includes the their position on the branches, and - if specified - the pendant_length of both. There are three cases that might occur:\nBoth placements are on the same branch. In this case, their distance is caluclated as their difference in proximal_lengths (plus if specified the sum of their pendant_lengths).The path between the placements includes the root. The distance of a placement from its neighbouring nodes is usually given in form of the proximal_length, which is the distance of the placement to the node (at the end of its branch) that lies in direction of the root. Thus, there is an implicit notion of a root, that we need to consider. If the path between two placements contains the root, we can directly calculate their distance as the distance between the two promixal nodes plus proximal_lengths (and possibly pendant_lengths) of both placements. We call this the promixal-promixal case.The root is not part of the path between the placements. This case means that one of the two placements lies on the path between the other placement and the root  thus, the path between the placements does not contain the root. The distance between the placements cannot be calculated using the proximal_lengths directly, but we need to get the distal_length (away from the root) of the inner placement first. This is simply the difference between branch_length and proximal_length of that placement. Of course, this case comes in two flavours, because both placements can be the inner or outer one. They are called proximal-distal case and distal-proximal case, respectively.\nThe first case is easy to detect by comparing the edge nums. However, distinguishing between the latter two cases is expensive, as it involves finding the path to the root for both placements. To speed this up, we instead use a distance matrix that is calculated in the beginning of any algorithm using this method and contains the pairwise distances between all nodes of the tree. Using this, we do not need to find paths between placements, but simply go to the nodes at the end of the branches of the placements and do a lookup for those nodes.With this technique, we can calculate the distances between the placements for all three cases (promixal-promixal, proximal-distal and distal-proximal) cheaply. The wanted distance is then simply the minimum of those three distances. This is correct, because the two wrong cases will always produce an overestimation of the distance.This distance is normalized using the like_weight_ratio of both placements, before summing it up to calculate the total distance between the pqueries."},
    {"void ::genesis::sequence::filter_min_max_sequence_length (SequenceSet & set, size_t min_length, size_t max_length)", "Remove all Sequences from the SequenceSet whose length is not inbetween the min_length and max_length.\n\nThis function has the same effect as calling filter_min_sequence_length() and filter_max_sequence_length(), but does it in one iteration over the SequenceSet."},
    {"void ::genesis::sequence::filter_max_sequence_length (SequenceSet & set, size_t max_length)", "Remove all Sequences from the SequenceSet whose length is above the given max_length.\n\nSee also filter_min_sequence_length() and filter_min_max_sequence_length()."},
    {"void ::genesis::sequence::filter_by_label_list (SequenceSet & set, std::unordered_set< std::string > const & labels, bool invert=false)", "Remove all those Sequences from a SequenceSet whose labels are in the given list.\n\nIf invert is set to true, it does the same inverted: it removes all Sequences except those whose label is in the list."},
    {"std::unordered_map< size_t, std::vector< PqueryPlacement const * > > ::genesis::placement::placements_per_edge (Sample const & smp)", "Return a mapping from PlacementTreeEdge indices to a vector of all PqueryPlacements that are placed on that edge, for all edges of the Sample.\n\nThis map is invalidated after calling Pquery::add_placement()."},
    {"std::vector< double > ::genesis::placement::placement_weight_per_edge (Sample const & sample)", "Return a vector that contains the sum of the weights of the PqueryPlacements per edge of the tree of the Sample.\n\nThe weight is measured in like_weight_ratio. The vector is indexed using the index of the edges."},
    {"std::string ::genesis::sequence::consensus_sequence_with_majorities (SequenceSet const & sequences, bool allow_gaps)", "Calculate the majority rule consensus sequence by using the most frequent character at each site for nucleic acid codes ACGT.\n\nSee consensus_sequence_with_majorities(...) for details.This function is merely a wrapper that instead of a SequenceCount objects, takes a SequenceSet object consisting of Sequences with nucleic acid codes ACGT and uses '-' for gaps."},
    {"std::string ::genesis::sequence::consensus_sequence_with_threshold (SequenceCounts const & counts, double frequency_threshold, bool allow_gaps, bool use_ambiguities)", "Calculate a consensus sequence where the character frequency needs to be above a given threshold, for nucleic acid codes ACGT.\n\nThe function calculates a consensus sequence for nucleic acid codes (ACGT). It uses the frequency of characters at each site to determine the consensus. The frequency is relative to the total number of counts at that site, thus, it is a value in the range [ 0.0, 1.0 ].If the frequency of a character at a site is above the given frequency_threshold, it is used for the consensus. If not, the resulting character depends on use_ambiguities. If use_ambiguities is set to true (default), the sorted frequencies of the characters are added until the threshold is reached, and the ambiguity code for those characters is used. For example, let frequency_threshold == 0.9, count('A') == 42 and count('T') == 42, and both other counts be 0. Then, neither A nor T have counts above the threshold, but combined they do, so the result is code W == AT at that site. If however use_ambiguities is false, the mask character X is used for sites that are below the threshold.Furthermore, if allow_gaps is set to true (default), gaps are counted when determining the threshold and checking whether the frequency is above it. That is, gaps are then treated as just another character at the site. For sites that mostly contain gaps and the gap frequency reaches the threshold, a gap is used as consensus. If allow_gaps is false, however, gaps are not counted for determining the frequency of the other characters. This is similar to the counterpart in consensus_sequence_with_majorities(). Solely sites that are gaps-only result in a gap char for the consensus then.For frequency_threshold < 0.5, it may happen that more than one character has a frequency above the threshold. In such cases, the most frequent character is used (or, if they have exaclty the same counts, they are used in the order ACGT). This is in line with the behaviour of consensus_sequence_with_majorities(). Usually, however, the threshold is above 0.5 anyway, as this gives more meaningful results. If you want to use ambiguity characters for low frequency characters, you can use consensus_sequence_with_ambiguities() instead.An extreme case is a frequency_threshold of 1.0. In this case, for sites which only have one character, this one is directly used in the consensus. Sites with multiple different characters result in the ambiguity code of all occuring characters at that site. Thus, the function then behaves similar to consensus_sequence_with_ambiguities() with a similarity_factor of 0.0.The other extrem case is a frequency_threshold of 0.0. In this case, the function simply uses the most frequent character per site, as it always fulfills the threshold. As said above, if then more than one character has exactly the same frequency, they are used in the order ACGT, thus the function then behaves similar to consensus_sequence_with_majorities().Remark: As this function expects nucleic acid codes, the gap character is fixed to '-' here, and the mask character to 'X'. The ambiguity codes are converted using nucleic_acid_ambiguity_code(). See there for more information on the used codes.If the provided SequenceCounts object does not use nucleic acid codes, or if the frequency_threshold is not within the range [ 0.0, 1.0 ], an exception is thrown."},
    {"std::string ::genesis::sequence::consensus_sequence_with_threshold (SequenceSet const & sequences, double frequency_threshold, bool allow_gaps, bool use_ambiguities)", "Calculate a consensus sequence where the character frequency needs to be above a given threshold, for nucleic acid codes ACGT.\n\nSee consensus_sequence_with_ambiguities(...) for details. This is merely a wrapper function that takes a SequenceSet instead of a SequenceCounts object."},
    {"size_t ::genesis::sequence::count_chars (SequenceSet const & set, std::string const & chars)", "Count the number of occurrences of the given chars within the sites of the SequenceSet.\n\nThis function can be used to count e.g. gaps or ambiguous characters in sequences. For presettings of usable chars, see the functions nucleic_acid_codes_... and amino_acid_codes_.... The chars are treated case-insensitive.If chars contains invalid (non-standard ASCII) characters, an std::invalid_argument exception is thrown."},
    {"double ::genesis::placement::expected_distance_between_placement_locations (Sample const & sample, Pquery const & pquery)", "Calculate the EDPL uncertainty values for a Pquery.\n\nSee http://matsen.github.io/pplacer/generated_rst/guppy_edpl.html for more information.This function expects a Pquery and the Sample it belongs to. This is necessary in order to get the Tree of the Sample and calculate distances between its Nodes."},
    {"std::vector< double > ::genesis::placement::expected_distance_between_placement_locations (Sample const & sample)", "Calculate the expected_distance_between_placement_locations() for all Pqueries in the Sample."},
    {"void ::genesis::placement::filter_min_accumulated_weight (Pquery & pquery, double threshold=0.99)", "Remove the PqueryPlacements with the lowest like_weight_ratio, while keeping the accumulated weight (sum of all remaining like_weight_ratios) above a given threshold.\n\nThis is a cleaning function to get rid of unlikely placement positions, withouth sacrificing too much detail of the overall distribution of weights. The EPA support a similar option, which only writes enough of the most likely placement positions to the output to fullfil a threshold."},
    {"void ::genesis::placement::filter_min_accumulated_weight (Sample & smp, double threshold=0.99)", "Remove the PqueryPlacements with the lowest like_weight_ratio, while keeping the accumulated weight (sum of all remaining like_weight_ratios) above a given threshold.\n\nThis function calls filter_min_accumulated_weight( Pquery& pquery, double threshold ) for all Pqueries of the Sample. See this version of the function for more information."},
    {"double ::genesis::placement::expected_distance_between_placement_locations (Pquery const & pquery, utils::Matrix< double > const & node_distances)", "Local helper function to calculate the expected_distance_between_placement_locations()."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (Sequence const & seq)", "Get a histogram of the occurrences of particular sites, given a Sequence.\n\nThis gives the raw counts of how often each site (character) appears in the Sequence. See base_frequencies() for the relative version of this function."},
    {"void ::genesis::placement::sort_placements_by_weight (Sample & smp)", "Sort the PqueryPlacements of all Pqueries  by their like_weight_ratio, in descending order (most likely first)."},
    {"SiteEntropyOptions & ::genesis::sequence::operator|= (SiteEntropyOptions & lhs, SiteEntropyOptions rhs)", "Or-assignment-operator to combine two SiteEntropyOptionss.\n\nTypical usage: SiteEntropyOptions options;\noptions |= SiteEntropyOptions::kWeighted;\nUse the and-operator in order to check whether an option is set."},
    {"void ::genesis::sequence::remove_characters (Sequence & seq, std::string const & search)", "Remove all of the characters in search from the sites of the Sequence."},
    {"void ::genesis::sequence::relabel_sha1 (Sequence & seq)", "Relabel the Sequence using the SHA1 hash digest of its sites."},
    {"void ::genesis::sequence::remove_characters (SequenceSet & set, std::string const & search)", "Remove all of the characters in search from the sites of the Sequences in the SequenceSet."},
    {"void ::genesis::sequence::relabel_sha1 (SequenceSet & set)", "Relabel all Sequences in the SequenceSet using the SHA1 hash digest of the sites.\n\nIf there are duplicate Sequences, this function will lead to multiple Sequences with the same name, which might be an issue for downstream programs that expect unique labels. See has_unique_labels() to check this."},
    {"void ::genesis::sequence::remove_gaps (Sequence & seq, std::string const & gap_chars)", "Remove all gap characters from the sites of the Sequence.\n\nThis function is an alias for remove_characters(), which by default uses the gap sites of nucleic_acid_codes_undetermined()."},
    {"void ::genesis::placement::epca_splitify_transform (utils::Matrix< double > & imbalance_matrix, double kappa=1.0)", "Perform a component-wise transformation of the imbalance matrix used for epca().\n\nAll entries of the Matrix are transformed inplace, using\\[ \\varphi_\\kappa(x) = \\mathrm{sgn}(x) \\cdot |x|^\\kappa \\]where the kappa ( $\\kappa$) parameter can be any non-negative number. This parameter scales between ignoring abundance information (kappa = 0), using it linearly (kappa = 1), and emphasizing it (kappa > 1).\n\nimbalance_matrix\n\n\nMatrix to transform inplace. \n\n\n\nkappa\n\n\nScaling value for abundance information. Has to be > 0."},
    {"void ::genesis::sequence::replace_t_with_u (SequenceSet & set)", "Replace all occurrences of T by U in the sites of all Sequences in the SequenceSet.\n\nThis is a small helper function for sequences with nucleic acid codes. It is case sensitive, that is, lower case t is replaced by lower case u, and upper case T by upper case U."},
    {"std::map< char, size_t > ::genesis::sequence::site_histogram (SequenceSet const & set)", "Get a histogram of the occurrences of particular sites, given a SequenceSet.\n\nThis gives the raw counts of how often each site (character) appears in the whole set. See base_frequencies() for the relative version of this function."},
    {"std::map< char, std::string > ::genesis::sequence::nucleic_acid_text_colors ()", "Return a map of text colors for each nucleic acid code.\n\nThis function gives a color name usable for utils::Style for each nucleic acid code. The return value of this function can for example be used in sequence::print_color() function."},
    {"bool ::genesis::sequence::operator& (SiteEntropyOptions lhs, SiteEntropyOptions rhs)", "And-operator to check whether a SiteEntropyOptions is set.\n\nTypical usage: SiteEntropyOptions options;\nif( options & SiteEntropyOptions::kWeighted ) {\n    // Do stuff...\n}\nUse the or-operator in order to set and combine options."},
    {"std::ostream & ::genesis::sequence::operator<< (std::ostream & out, Sequence const & seq)", "Print a Sequence to an ostream in the form \"label: sites\".\n\nAs this is meant for quickly having a look at the Sequence, only the first 100 sites are printed. If you need all sites, or more settings like color, use SimplePrinter."},
    {"std::ostream & ::genesis::sequence::operator<< (std::ostream & out, SequenceSet const & set)", "Print a SequenceSet to an ostream in the form \"label: sites\".\n\nAs this is meant for quickly having a look at the SequenceSet, only the first 10 Sequences and the first 100 sites of each are printed. If you need all sequences and sites, or more settings like color, use SimplePrinter."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_plain ()", "Return all plain nucleic acid codes. Those are \"ACGTU\"."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_degenerated ()", "Return all degenerated nucleic acid codes. Those are \"WSMKRYBDHV\"."},
    {"std::map< char, utils::Color > ::genesis::sequence::nucleic_acid_colors ()", "Return a map of Colors for each nucleic acid code.\n\nThis function gives a Color for each nucleic acid code."},
    {"std::string ::genesis::sequence::nucleic_acid_codes_undetermined ()", "Return all undetermined nucleic acid codes. Those are \"NOX.-?\"."},
};

const char* get_docstring (const std::string& signature)
{
    if (doc_strings_.count(signature) > 0) {
        return doc_strings_[signature].c_str();
    } else {
        return "";
    }
}
