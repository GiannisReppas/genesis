/**
* @brief Documentation strings for the genesis Python module.
 *
 * @file
 * @ingroup python
 */

#include <python/src/common.hpp>

#include <map>
#include <string>

static std::map<std::string, std::string> doc_strings_ = {
    {"BipartitionType * ::genesis::BipartitionSet::find_smallest_subtree (std::vector< NodeType * > nodes)", "Finds the smallest subtree (measured in number of nodes) that contains all given nodes.\n\nA subtree is defined by one of the two parts of a tree that are splitted by one edge. Thus, this function tries all subtrees by leaving out each edge once.If no fitting subtree exists, the function returns a nullptr."},
    {"size_t ::genesis::Bitvector::count () const", "Counts the number of set bits in the Bitvector."},
    {"void ::genesis::Bitvector::flip (size_t index)", "Flips (inverts) the value of a single bit, with boundary check."},
    {"bool ::genesis::Bitvector::get (size_t index) const", "Returns the value of a single bit, with boundary check."},
    {"size_t ::genesis::Bitvector::hash () const", "Returns an std::hash value for the Bitvector."},
    {"void ::genesis::Bitvector::invert ()", "Flip all bits."},
    {"void ::genesis::Bitvector::normalize ()", "Brings the Bitvector in a normalized form, where the first bit is always zero.\n\nIf the first bit is zero, nothing happens. However, if is is one, the whole Bitvector is flipped using invert()."},
    {"void ::genesis::Bitvector::reset (bool value=false)", "Reset all the bits to false. If provided with parameter true, sets all bits to true."},
    {"void ::genesis::Bitvector::set (size_t index)", "Sets the value of a single bit to true, with boundary check."},
    {"void ::genesis::Bitvector::set (size_t index, bool value)", "Sets the value of a single bit to a given bool value, with boundary check."},
    {"size_t ::genesis::Bitvector::size () const", "Returns the size (number of total bits) of this Bitvector."},
    {"void ::genesis::Bitvector::unset (size_t index)", "Sets the value of a single bit to false, with boundary check."},
    {"IntType ::genesis::Bitvector::x_hash () const", "Returns a hash value of type IntType, that is quicker to calculate than hash(), and thus can be used where the std::hash is not needed."},
    {"static Color ::genesis::Color::heat_gradient (int percentage)", "Returns a Color that represents a heat gradient for a percentage value.\n\nGiven a percentage value, the functions represents the heat of that value. For 0%, the heat gradient value is green, for 50% yellow and for 100% red. The values in between are interpolated accordingly."},
    {"void ::genesis::DefaultTreeEdgeData::from_newick_broker_element (NewickBrokerElement * node)", "Fills the edge with data from a NewickBrokerElement."},
    {"void ::genesis::DefaultTreeNodeData::from_newick_broker_element (NewickBrokerElement * node)", "Fills the node with data from a NewickBrokerElement."},
    {"static bool ::genesis::JplaceProcessor::check_version (const std::string version)", "Checks whether the version of the jplace format works with this parser."},
    {"bool ::genesis::JplaceProcessor::from_document (const JsonDocument & doc, PlacementMap & placements)", "Takes a JsonDocument object and parses it as a Jplace document into a PlacementMap object.\n\nReturns true iff successful."},
    {"bool ::genesis::JplaceProcessor::from_file (const std::string & fn, PlacementMap & placements)", "Reads a file and parses it as a Jplace document into a PlacementMap object.\n\nReturns true iff successful."},
    {"bool ::genesis::JplaceProcessor::from_files (const std::vector< std::string > & fns, PlacementMapSet & set)", "Reads a list of files and parses them as a Jplace document into a PlacementMapSet object.\n\nReturns true iff successful."},
    {"bool ::genesis::JplaceProcessor::from_string (const std::string & jplace, PlacementMap & placements)", "Parses a string as a Jplace document into a PlacementMap object.\n\nReturns true iff successful."},
    {"bool ::genesis::JplaceProcessor::from_strings (const std::vector< std::string > & jps, PlacementMapSet & set)", "Parses a list of strings as a Jplace document into a PlacementMapSet object.\n\nReturns true iff successful."},
    {"static std::string ::genesis::JplaceProcessor::get_version ()", "Returns the version number that this class is written for."},
    {"bool ::genesis::JsonProcessor::from_file (const std::string & fn, JsonDocument & document)", "Takes a JSON document file path and parses its contents into a JsonDocument.\n\nReturns true iff successfull."},
    {"bool ::genesis::JsonProcessor::from_string (const std::string & json, JsonDocument & document)", "Takes a string containing a JSON document and parses its contents into a JsonDocument.\n\nReturns true iff successfull."},
    {"bool ::genesis::JsonProcessor::to_file (const std::string & fn, const JsonDocument & document)", "Writes a Json file from a JsonDocument. Returns true iff successful."},
    {"void ::genesis::JsonProcessor::to_string (std::string & json, const JsonDocument & document)", "Gives the Json string representation of a JsonDocument."},
    {"std::string ::genesis::JsonProcessor::to_string (const JsonDocument & document)", "Returns the Json representation of a JsonDocument."},
    {"void ::genesis::JsonValueArray::add (JsonValue * value)", "Alias of push_back()."},
    {"JsonValue * ::genesis::JsonValueArray::at (const std::size_t index) const", "Provides index based array access to the array, doing a boundary check first.\n\nIn out of bounds cases, a nullptr is returned."},
    {"const_iterator ::genesis::JsonValueArray::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::JsonValueArray::cend () const", "Const version of end()."},
    {"void ::genesis::JsonValueArray::clear ()", "Clears all values, as if the array was newly created."},
    {"bool ::genesis::JsonValueArray::empty () const", "Returns whether the array is empty."},
    {"size_t ::genesis::JsonValueArray::size () const", "Returns the number of values in the array."},
    {"JsonValue * ::genesis::JsonValueObject::at (const std::string & name) const", "Provides index based array access to the object, doing a boundary check first. This is an alias for get().\n\nIn out of bounds cases, a nullptr is returned."},
    {"const_iterator ::genesis::JsonValueObject::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::JsonValueObject::cend () const", "Const version of end()."},
    {"void ::genesis::JsonValueObject::clear ()", "Clears all values, as if the object was newly created."},
    {"bool ::genesis::JsonValueObject::empty () const", "Returns whether the object is empty."},
    {"bool ::genesis::JsonValueObject::erase (const std::string name)", "Clears the value of a specific key; returns true iff this key existed."},
    {"JsonValue * ::genesis::JsonValueObject::get (const std::string & name) const", "Returns the value of a certain key if present in the object, nullptr otherwise."},
    {"bool ::genesis::JsonValueObject::has (const std::string & name) const", "Returns true iff the object contains a certain key."},
    {"void ::genesis::JsonValueObject::set (const std::string & name, JsonValue * value)", "Sets the value for a certain key."},
    {"size_t ::genesis::JsonValueObject::size () const", "Returns the number of values in the object."},
    {"LexerToken ::genesis::Lexer::back () const", "Returns a reference to the last token.\n\nCalling this function on an empty() lexer causes undefined behavior."},
    {"void ::genesis::Lexer::clear ()", "Clears all tokens, as if the object was newly created.\n\nThe options of the lexer are however not changed."},
    {"std::string ::genesis::Lexer::dump () const", "Returns a listing of the parse result in readable form."},
    {"bool ::genesis::Lexer::empty () const", "Returns whether the list of tokens is empty.\n\nThis is usually the case before ProcessString() was run."},
    {"bool ::genesis::Lexer::from_file (const std::string & fn)", "Shortcut function that reads the contents of a file and then calls from_string().\n\nIf the file does not exist, a warning is triggered and false returned. Otherwise, the result of from_string() is returned."},
    {"bool ::genesis::Lexer::from_string (const std::string & in)", "Process a string and store the resulting tokens in this Lexer object.\n\nThis process analyzes and splits the string into different tokens. For the types of tokens being extracted, see LexerToken; for accessing the results, see Lexer.Returns true iff successful. In case an error is encountered while analyzing the text, this functions returns false and the last token will be of type LexerTokenType::kError, with the value being an error message describing the type of error."},
    {"bool ::genesis::Lexer::has_error () const", "Returns whether there appeared an error while lexing."},
    {"bool ::genesis::Lexer::process_step ()", "Processes one step of the lexing.\n\nAs stated in the description of this Lexer class, the class is meant to be derived for concrete types of lexers. Thus, here are some comments about the working of this function:For most types of structured text, the first character of each token determines the type of the token (for example, a digit almost always leads to a number token). This is why we use a list telling us which char leads to which token type. This list is a speedup, because using it, we do not need to try every scanner (for numbers, symbols, strings, etc) at the beginning of each new token, but simply do a lookup to find out \"this char means we have to use\nthis scanner now\". (Also see get_char_type and SetCharType for this.)This does not mean that any char of a given type can only appear in tokens of that type. For example, typically a symbol can start with letters, but then contain numbers later, too. Thus, although a digit is of type kNumber, it can end up in a symbol token, depending on the context.Instead, the char type here is meant as a speedup for finding the right scanner when lexing the text: whenever one scanner finishes, the next char is inspected and depending on its type, a fitting scanner is activated (for digits the number scanner and so on).This technique will not work if finding the correct scanner depends on more than the first character of the token. For example, comments usually start with a more complex sequence (\"//\" or even \"<!--\"), which is why they are specially treaded in this function.So, in situations, where the type of the next token cannot be determined from its first character (except comments), this function has to be overridden in the derived class in order to do some other checking methods to determine the correct scanner."},
    {"size_t ::genesis::Lexer::size () const", "Returns the number of tokens produced during the analysis process."},
    {"bool ::genesis::Lexer::validate_brackets () const", "Checkes whether the bracket tokes are validly nested.\n\nIn order to be valid, every opening bracket must be matched with a corresponding closing bracket, and their order has to be correct.This function checks the following types of brackets: () [] {} <>\nIt is not particularly useful for xml, as there it is also important to use closing tags like <xml> ... </xml>."},
    {"void ::genesis::LexerIterator::consume_head ()", "Removes all tokens up to (but excluding) the current one.\n\nThis is a slow operation, thus should not be called in the inner parsing loop. It is meant to save memory when reading and parsing large files."},
    {"bool ::genesis::LexerIterator::has_error () const", "Returns whether there appeared an error while lexing."},
    {"std::ostringstream & ::genesis::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level)", "Getter for the singleton instance of log, is called by the standard macros.\n\nIt returns the string stream buffer used to capture the log messages."},
    {"std::ostringstream & ::genesis::Logging::get (const std::string & file, const int line, const std::string & function, const LoggingLevel level, const LoggingDetails dets)", "Getter for the singleton instance of log, is called by special macros that change the details of the log message.\n\nIt stores some relevant information and returns the string stream buffer used to capture the log messages."},
    {"static std::string ::genesis::Logging::level_to_string (const LoggingLevel level)", "Return a string representation of a log level."},
    {"static void ::genesis::Logging::log_to_file (const std::string & fn)", "Add an output file to which log messages are written.\n\nThis creates a stream to the file."},
    {"static void ::genesis::Logging::log_to_stdout ()", "Add stdout as output stream to which log messages are written."},
    {"static void ::genesis::Logging::log_to_stream (std::ostream & os)", "Add an output stream to which log messages are written."},
    {"static LoggingLevel ::genesis::Logging::max_level ()", "Get the highest log level that is reported."},
    {"static void ::genesis::Logging::max_level (const LoggingLevel level)", "Set the highest log level that is reported.\n\nInvocations of log with higher levels will create no output. It creates a warning if the set level is higher than the static compile time level set by LOG_LEVEL_MAX."},
    {"static int ::genesis::Logging::report_percentage ()", "Get the current percentage for reporting LOG_PROG messages."},
    {"static void ::genesis::Logging::report_percentage (const int percentage)", "set the percentage for reporting LOG_PROG messages."},
    {"void ::genesis::NewickBroker::assign_ranks ()", "Iterate over the tree and assign ranks (= number of immediate children) to all nodes.\n\nThis function is for example needed to check whether it is a bifurcating/binary tree, or to check how many leaves and inner nodes the tree has. Thus, it is usually called after the broker is filled with data."},
    {"NewickBrokerElement * ::genesis::NewickBroker::at (const std::size_t index) const", "Provides index based array access to the nodes, doing a boundary check first.\n\nIn out of bounds cases, a nullptr is returned."},
    {"NewickBrokerElement * ::genesis::NewickBroker::bottom ()", "Returns a reference to the bottom node of the tree stack.\n\nCalling this function on an empty() broker causes undefined behavior."},
    {"const_iterator ::genesis::NewickBroker::cbegin () const", "Const version of begin()."},
    {"const_iterator ::genesis::NewickBroker::cend () const", "Const version of end()."},
    {"void ::genesis::NewickBroker::clear ()", "Deletes all nodes from the broker."},
    {"const_reverse_iterator ::genesis::NewickBroker::crbegin ()", "Const version of rbegin()."},
    {"const_reverse_iterator ::genesis::NewickBroker::crend ()", "Const version of rend()."},
    {"std::string ::genesis::NewickBroker::dump () const", "Return a readable string representation of the elements of the NewickBroker."},
    {"bool ::genesis::NewickBroker::empty () const", "Returns whether the stack is empty."},
    {"int ::genesis::NewickBroker::leaf_count () const", "Returns the number of leaf nodes in the tree. assign_ranks() has to be called first."},
    {"int ::genesis::NewickBroker::max_rank () const", "Returns the highest rank of the nodes in the tree. assign_ranks() has to be called first."},
    {"reverse_iterator ::genesis::NewickBroker::rbegin ()", "Returns a reverse iterator to the nodes on the stack.\n\nThis is useful for iterating starting at the leaves and ending at the root."},
    {"reverse_iterator ::genesis::NewickBroker::rend ()", "Reverse version of end()."},
    {"size_t ::genesis::NewickBroker::size () const", "Returns the size of the stack, i.e. the number of nodes stored in the broker."},
    {"NewickBrokerElement * ::genesis::NewickBroker::top ()", "Returns a reference to the top node of the tree stack.\n\nUsually, the top element is the root of the tree (i.e., it has depth zero). Only when called during the broker is being filled with nodes (for example, while parsing a Newick tree), the top element is not the root.Calling this function on an empty() broker causes undefined behavior."},
    {"bool ::genesis::NewickBroker::validate () const", "Returns true iff the tree is valid. assign_ranks() has to be called first.\n\nA valid tree in a NewickBroker has to fullfill those criteria:\nIt's rank has to match the property is_leaf: Leaves have rank 0; a node with a higher rank cannot be a leaf.Furthermore, rank 1 is not valid, as this represents a node that is not furcating in any way.The depth (nesting level) of the nodes cannot increase more than one level between nodes, as this would imply a non-existing node with a depth in between. However, it can arbitrarily decrease, as this simply means the end of a subtree. %"},
    {"bool ::genesis::NewickProcessor::from_file (const std::string & filename, TreeType & tree)", "Create a Tree from a file containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::NewickProcessor::from_file (const std::string & filename, TreeSet< TreeType > & tree_set)", "Fill a TreeSet from a file containing a list of Newick trees.\n\nSee from_string() for information on the syntax of this file. The tree names are taken from the content if availabe. Unnamed trees will be prefixed by the file name.Returns true iff successful."},
    {"bool ::genesis::NewickProcessor::from_files (const std::vector< std::string > & filenames, TreeSet< TreeType > & tree_set)", "Fill a TreeSet from a list of files containing Newick trees.\n\nReturns true iff successful."},
    {"bool ::genesis::NewickProcessor::from_string (const std::string & tree_string, TreeType & tree)", "Create a Tree from a string containing a Newick tree.\n\nReturns true iff successful."},
    {"bool ::genesis::NewickProcessor::from_string (const std::string & tree_string, TreeSet< TreeType > & tree_set, const std::string & default_name="")", "Fill a TreeSet from a string containing a list of Newick trees.\n\nThese trees can either be named or unnamed, using this syntax: Tree_A = (...);\n'Tree B'=(...);\n(...);\nwhere the first two lines are named trees and the third line is an unnamed tree. The trees do not have to be on distinct lines of the input, as whitespaces are completely stripped during the lexing phase. However, they are required to end with a semicolon ;.In case of unnamed trees, a default_name can be provided, which will be appended by a counter that counts up all unnamed trees. If no default name is given, the trees will simpye be named using the counter itself.Returns true iff successful."},
    {"bool ::genesis::NewickProcessor::from_strings (const std::vector< std::string > & tree_strings, TreeSet< TreeType > & tree_set, const std::string & default_name="")", "Fill a TreeSet from a list of strings containing Newick trees.\n\nReturns true iff successful."},
    {"bool ::genesis::NewickProcessor::to_file (const TreeType & tree, const std::string fn)", "Writes the tree to a file in Newick format.\n\nIf the file already exists, the function does not overwrite it."},
    {"void ::genesis::NewickProcessor::to_string (const TreeType & tree, std::string & ts)", "Gives a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},
    {"std::string ::genesis::NewickProcessor::to_string (const TreeType & tree)", "Returns a Newick string representation of the tree.\n\nIn case the tree was read from a Newick file, this function should produce the same representation."},
    {"std::vector< std::string > ::genesis::Options::command_line () const", "Returns an array of strings containing the program's command line arguments."},
    {"std::string ::genesis::Options::command_line_string () const", "Returns a string containing the program's command line arguments."},
    {"std::string ::genesis::Options::dump () const", "Return a list of all options with their values."},
    {"static Options & ::genesis::Options::get ()", "Returns a single instance of this class."},
    {"unsigned int ::genesis::Options::number_of_threads () const", "Returns the number of threads."},
    {"std::default_random_engine & ::genesis::Options::random_engine ()", "Returns the default engine for random number generation.\n\nCaveat: This is not intended for the use in more than one thread. As the order of execution in threads is not deterministic, results would not be reproducible, even when using a fixed seed. Furthermore, it might be a speed bottleneck to add a mutex to this method.If in the furture there is need for multi-threaded random engines, they needed to be outfitted with separate seeds each (otherwise they would all produce the same results). Thus, for now we simply assume single-threaded use."},
    {"unsigned ::genesis::Options::random_seed () const", "Returns the random seed that was used to initialize the engine."},
    {"void ::genesis::Options::set_command_line (const int argc, const char * argv)", "Set arguments to the program's command line options.\n\nIf the program is run from the command line, this method has to be used to properly propagate the command line options to this options class."},
    {"void ::genesis::Options::set_number_of_threads (const unsigned int number)", "Overwrite the system given number of threads.\n\nOn startup, the value is initialized with the actual number of cores available in the system using std::thread::hardware_concurrency(). This method overwrites this value."},
    {"void ::genesis::Options::set_random_seed (const unsigned seed)", "Set a specific seed for the random engine.\n\nOn startup, the random engine is initialized using the current system time. This value can be overwritten using this method."},
    {"void ::genesis::PhyloxmlProcessor::to_document (const TreeType & tree, XmlDocument & xml)", "Stores the information of the tree into an Phyloxml-formatted XmlDocument."},
    {"bool ::genesis::PhyloxmlProcessor::to_file (const TreeType & tree, const std::string fn)", "Writes the tree to a file in Phyloxml format.\n\nIf the file already exists, the function does not overwrite it."},
    {"void ::genesis::PhyloxmlProcessor::to_string (const TreeType & tree, std::string & ts)", "Gives a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},
    {"std::string ::genesis::PhyloxmlProcessor::to_string (const TreeType & tree)", "Returns a Phyloxml string representation of the tree.\n\nIn case the tree was read from a Phyloxml file, this function should produce the same representation."},
    {"Pquery * ::genesis::PlacementMap::add_pquery ()", "Creats an empty Pquery, adds it to the PlacementMap and returns a pointer to it.\n\nThe returned pointer can then be used to add Placements and Names to the Pquery."},
    {"std::pair< PlacementTreeEdge *, double > ::genesis::PlacementMap::center_of_gravity (const bool with_pendant_length=true) const", "Calculate the Center of Gravity of the placements on a tree.\n\nThe center of gravity is the point on the tree where all masses of the placements on the one side of it times their distance from the point are equal to this sum on the other side of the point. In the following example, the hat ^ marks this point on a line with two placements: One has mass 1 and distance 3 from the central point, and one as mass 3 and distance 1, so that the product of their mass and distance to the point is the same:               3\n              |\n1             |\n|_____________|\n          ^\nIt is thus like calculating masses and torques on a lever in order to find their physical center of mass/gravity.This calculation is done for the whole tree, with the masses calculated from the like_weight_ratio and distances in terms of the branch_length of the edges and the proximal_length and (if specificed in the method parameter) the pendant_length of the placements."},
    {"double ::genesis::PlacementMap::center_of_gravity_variance (const bool with_pendant_length=true) const", "$ Var(X) = E[ (x - \\mu)^2 ] = \\frac{\\sum (x - \\mu)^2 \\cdot \\omega} {\\sum \\omega} $, where the weights $ \\omega $ are the like_weight_ratios of the placements."},
    {"void ::genesis::PlacementMap::clear ()", "Clears all data of this object.\n\nThe pqueries, the tree and the metadata are deleted."},
    {"void ::genesis::PlacementMap::clear_placements ()", "Clears all placements of this PlacementMap.\n\nAll pqueries are deleted. However, the Tree and metadata are left as they are, thus this is a useful method for simulating placements: Take a copy of a given map, clear its placements, then generate new ones using PlacementSimulator."},
    {"std::vector< int > ::genesis::PlacementMap::closest_leaf_depth_histogram () const", "Returns a histogram representing how many placements have which depth with respect to their closest leaf node.\n\nThe depth between two nodes on a tree is the number of edges between them. Thus, the depth of a placement (which sits on an edge of the tree) to a specific node is the number of edges between this node and the closer one of the two nodes at the end of the edge where the placement sits.The closest leaf to a placement is thus the leaf node which has the smallest depth to that placement. This function then returns a histogram of how many placements (values of the vector) are there that have a specific depth (indices of the vector) to their closest leaf.Example: A return vector of histogram[0] = 2334\nhistogram[1] = 349\nhistogram[2] = 65\nhistogram[3] = 17\nmeans that there are 2334 placements that sit on an edge which leads to a leaf node (thus, the depth of one of the nodes of the edge is 0). It has 349 placements that sit on an edge where one of its nodes has one neighbour that is a leaf; and so on.The vector is automatically resized to the needed number of elements."},
    {"std::vector< int > ::genesis::PlacementMap::closest_leaf_distance_histogram (const double min, const double max, const int bins=10) const", "Returns a histogram counting the number of placements that have a certain distance to their closest leaf node, divided into equally large intervals between a min and a max distance.\n\nThe distance range between min and max is divided into bins many intervals of equal size. Then, the distance from each placement to its closest leaf node is calculated and the counter for this particular distance inverval in the histogram is incremented.The distance is measured along the branch_length values of the edges, taking the pendant_length and proximal_length of the placements into account. If the distances is outside of the interval [min,max], the counter of the first/last bin is incremented respectively.Example: double min      =  0.0;\ndouble max      = 20.0;\nint    bins     = 25;\ndouble bin_size = (max - min) / bins;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \" << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}"},
    {"std::vector< int > ::genesis::PlacementMap::closest_leaf_distance_histogram_auto (double & min, double & max, const int bins=10) const", "Returns the same type of histogram as closest_leaf_distance_histogram(), but automatically determines the needed boundaries.\n\nSee closest_leaf_distance_histogram() for general information about what this function does. The difference between both functions is that this one first procresses all distances from placements to their closest leaf nodes to find out what the shortest and longest are, then sets the boundaries of the histogram accordingly. The number of bins is then used to divide this range into intervals of equal size.The boundaries are returned by passing two doubles min and max to the function by reference. The value of max will actually contain the result of std::nextafter() called on the longest distance; this makes sure that the value itself will be placed in the interval.Example: double min, max;\nint    bins = 25;\nstd::vector<int> hist = closest_leaf_distance_histogram (min, max, bins);\ndouble bin_size = (max - min) / bins;\nLOG_INFO << \"Histogram boundaries: [\" << min << \",\" << max << \").\";\nfor (unsigned int bin = 0; bin < hist.size(); ++bin) {\n    LOG_INFO << \"Bin \" << bin << \" [\" << bin * bin_size << \"; \" << (bin+1) * bin_size << \") has \" << hist[bin] << \" placements.\";\n}\nIt has a slightly higher time and memory consumption than the non-automatic version closest_leaf_distance_histogram(), as it needs to process the values twice in order to find their min and max."},
    {"std::string ::genesis::PlacementMap::dump () const", "Returns a list of all Pqueries with their Placements and Names."},
    {"std::string ::genesis::PlacementMap::dump_tree () const", "Returns a simple view of the Tree with information about the Pqueries on it."},
    {"double ::genesis::PlacementMap::earth_movers_distance (const PlacementMap & other, const bool with_pendant_length=true) const", "Calculates the Earth Movers Distance to another sets of placements on a fixed reference tree."},
    {"static double ::genesis::PlacementMap::earth_movers_distance (const PlacementMap & map_a, const PlacementMap & map_b, const bool with_pendant_length=true)", "Calculates the Earth Movers Distance between two sets of placements on a fixed reference tree."},
    {"EdgeNumMapType ::genesis::PlacementMap::edge_num_map () const", "Returns a mapping of edge_num integers to the corresponding Edge object.\n\nThis function depends on the tree only and does not involve any pqueries."},
    {"bool ::genesis::PlacementMap::load (const std::string & file_name)", "Loads a PlacementMap from a binary file that was written by using save()."},
    {"bool ::genesis::PlacementMap::merge (const PlacementMap & other)", "Adds the pqueries from another PlacementMap objects to this one.\n\nFor this method to succeed, the PlacementMaps need to have the same topology, including identical edge_nums and node names.The resulting tree is the original one of the PlacementMap on which this method was called. If instead the average branch length tree is needed, see PlacementMapSet::merge_all()."},
    {"void ::genesis::PlacementMap::normalize_weight_ratios ()", "Recalculates the like_weight_ratio of the placements of each Pquery so that their sum is 1.0, while maintaining their ratio to each other."},
    {"double ::genesis::PlacementMap::pairwise_distance (const PlacementMap & other, const bool with_pendant_length=true) const", "Calculate the pairwise distance between all placements of the two PlacementMaps.\n\nother\n\n\nThe second PlacementMap to which the distances shall be calculated to. \n\n\n\nwith_pendant_length\n\n\nWhether or not to include all pendant lengths in the calculation.\n\n\nDistance value."},
    {"static double ::genesis::PlacementMap::pairwise_distance (const PlacementMap & map_a, const PlacementMap & map_b, const bool with_pendant_length=true)", "Calculate the normalized pairwise distance between all placements of the two PlacementMaps.\n\nThis method calculates the distance between two maps as the normalized sum of the distances between all pairs of pqueries in the map. It is similar to the variance() calculation, which calculates this sum for the squared distances between all pqueries of one map.\n\nleft\n\n\nThe first PlacementMap to which the distances shall be calculated to. \n\n\n\nright\n\n\nThe second PlacementMap to which the distances shall be calculated to. \n\n\n\nwith_pendant_length\n\n\nWhether or not to include all pendant lengths in the calculation.\n\n\nDistance value."},
    {"size_t ::genesis::PlacementMap::placement_count () const", "Get the total number of placements in all pqueries."},
    {"std::pair< PlacementTreeEdge *, size_t > ::genesis::PlacementMap::placement_count_max_edge () const", "Get the number of placements on the edge with the most placements, and a pointer to this edge."},
    {"double ::genesis::PlacementMap::placement_mass () const", "Get the summed mass of all placements on the tree, given by their like_weight_ratio."},
    {"std::pair< PlacementTreeEdge *, double > ::genesis::PlacementMap::placement_mass_max_edge () const", "Get the summed mass of the placements on the heaviest edge, measured by their like_weight_ratio, and a pointer to this edge."},
    {"std::vector< PqueryPlain > ::genesis::PlacementMap::plain_queries () const", "Returns a plain representation of all pqueries of this map.\n\nThis method produces a whole copy of all pqueries and their placements (though, not their names) in a plain POD format. This format is meant for speeding up computations that need access to the data a lot - which would require several pointer indirections in the normal representation of the data.This comes of course at the cost of reduced flexibility, as all indices are fixed in the plain data structre: changing a value here will not have any effect on the original data or even on the values of the pqueries. Thus, most probably this will lead to corruption. Therefore, this data structure is meant for reading only."},
    {"void ::genesis::PlacementMap::restrain_to_max_weight_placements ()", "Removes all placements but the most likely one from all pqueries.\n\nPqueries can contain multiple placements on different branches. For example, the EPA algorithm of RAxML outputs up to the 7 most likely positions for placements to the output Jplace file by default. The property like_weight_ratio weights those placement positions so that the sum over all positions per pquery is 1.0.This function removes all but the most likely placement (the one which has the maximal like_weight_ratio) from each Pquery. It additionally sets the like_weight_ratio of the remaining placement to 1.0, as this one now is the only one left, thus it's \"sum\" has to be 1.0."},
    {"bool ::genesis::PlacementMap::save (const std::string & file_name)", "Saves the PlacementMap to a binary file that can later be read by using load()."},
    {"bool ::genesis::PlacementMap::validate (bool check_values=false, bool break_on_values=false) const", "Validates the integrity of the pointers, references and data in this Placement object.\n\nReturns true iff everything is set up correctly. In case of inconsistencies, the function stops and returns false on the first encountered error.If check_values is set to true, also a check on the validity of numerical values is done, for example that the proximal_length is smaller than the corresponding branch_length. If additionally break_on_values is set, validate() will stop on the first encountered invalid value. Otherwise it will report all invalid values."},
    {"double ::genesis::PlacementMap::variance (const bool with_pendant_length=true) const", "Calculate the variance of the placements on a tree.\n\nThe variance is a measure of how far a set of items is spread out in its space (http://en.wikipedia.org/wiki/variance). In many cases, it can be measured using the mean of the items. However, when considering placements on a tree, this does not truly measure how far they are from each other. Thus, this algorithm applies a different method of calculating the variance in terms of squared deviations of all items from each other: $ Var(X) = \\frac{1}{n^2} \\sum_{i=1}^n \\sum_{j=1}^n \\frac{1}{2}(x_i - x_j)^2 $, where $ (x_i - x_j) $ denotes the distance between two placements.According to the formula above, each pair of placements is evaluated twice, and subsequently their distance need to be halfed when being added to the sum of distanaces. Instead of that, we calculate the distance for each pair only once, thus are able skip half the calculations, and of course skip the division by two.Furthermore, the normalizing factor $ \\frac{1}{n^2} $ of the variance usually contains the number of elements being processed. However, as the placements are weighted by their like_weight_ratio, we instead calculate n as the sum of the like_weight_ratio of all placements. In case that for each pquery the ratios of all its placements sum up to 1.0, this number will be equal to the number of pqueries (and thus be equal to the usual case of using the number of elements). However, as this is not required (placements with small ratio can be dropped, so that their sum per pquery is less than 1.0), we cannout simply use the count."},
    {"bool ::genesis::PlacementMapSet::all_identical_trees ()", "Returns true iff all Trees of the PlacementMaps in the set are identical.\n\nThis is the case if they have the same topology, node names and edge_nums. However, branch lengths are not checked, because usually those differ slightly."},
    {"bool ::genesis::PlacementMapSet::empty () const", "Returns whether the placement map set is empty."},
    {"std::shared_ptr< PlacementMap > ::genesis::PlacementMapSet::get_first (const std::string & name)", "Get the first PlacementMap in the set that is stored with a given name."},
    {"PlacementMap ::genesis::PlacementMapSet::merge_all ()", "Returns a PlacementMap where all maps of this set have been merged into.\n\nFor this method to succeed, all PlacementMaps need to have the same topology, including identical edge_nums and node names. The Tree of the returned PlacementMap has the average branch lenghts from the input trees, using TreeSet::average_branch_length_tree()."},
    {"size_t ::genesis::PlacementMapSet::size () const", "Returns the size of the placement map set."},
    {"TreeSet< PlacementTree > ::genesis::PlacementMapSet::tree_set ()", "Returns a TreeSet containing all the trees of the Placement Maps."},
    {"void ::genesis::PlacementSimulatorTwostep::generate (size_t n)", "Generates n many Pqueries and places them in the PlacementMap."},
    {"size_t ::genesis::PlacementTreeEdgeData::placement_count () const", "Returns the number of placements on this edge."},
    {"double ::genesis::PlacementTreeEdgeData::placement_mass () const", "Returns the mass of the placements on this edge, as given by their like_weight_ratio."},
    {"void ::genesis::PlacementTreeEdgeData::sort_placements ()", "Sorts the placements on this edge by their distance from the root, ascending."},
    {"std::string ::genesis::Sequence::dump () const", "Prints the label and the whole sequence (possibly very long!)."},
    {"void ::genesis::Sequence::remove_gaps ()", "Removes all occurences of gap_char from the sequence."},
    {"void ::genesis::Sequence::replace (char search, char replace)", "Replaces all occurences of search by replace."},
    {"void ::genesis::SequenceSet::clear ()", "Deletes all sequences from the alignment."},
    {"std::string ::genesis::SequenceSet::dump () const", "Gives a summary of the sequences names and their lengths for this alignment."},
    {"Sequence * ::genesis::SequenceSet::find_sequence (std::string label) const", "Returns a pointer to a sequence with a specific label (or nullptr, if not found)."},
    {"void ::genesis::SequenceSet::remove_gaps ()", "Calls remove_gaps() for every Sequence."},
    {"void ::genesis::SequenceSet::remove_list (std::vector< std::string > labels, bool invert=false)", "Removes and deletes all those sequences from the Aligment whose labels are in the given list. If invert is set to true, it does the same inverted: it removes all except those in the list.\n\nWe cannot use standard algorithms like std::remove here, as those do not delete the elements (call their destructor)."},
    {"void ::genesis::SequenceSet::replace (char search, char replace)", "Calls replace() for every Sequence."},
    {"void ::genesis::Tree::clear ()", "Deletes all data of the tree, including all links, nodes and edges."},
    {"NodeIntVectorType ::genesis::Tree::closest_leaf_depth_vector () const", "Returns a vector containing the closest leaf node for each node, measured in number of edges between them and its depth (number of edges between them).\n\nThe vector is indexed using the node()->index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node (with respect to its depth) and the second element its depth with respect to the node at the given index of the vector. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).Thus, leaf nodes will have a pointer to themselves and a depth value of 0, and for all other nodes the depth will be the number of edges between it and the closest leaf node.There might be more than one leaf with the same depth to a given node. In this case, an arbitrary one is used."},
    {"NodeDoubleVectorType ::genesis::Tree::closest_leaf_distance_vector () const", "Returns a vector containing the closest leaf node for each node, using the branch_length as distance measure.\n\nThe vector is indexed using the node()->index() for every node. Its value contains an std::pair, where the first element is a NodeType* to the closest leaf node of the node at the index, measured using the branch_length; the second element of the pair is the distance value itself. Thus, leaf nodes will have a pointer to themselves and a distance value of 0."},
    {"double ::genesis::Tree::deepest_distance () const", "Returns the longest distance from any point in the tree (on the edges) to any leaf."},
    {"std::string ::genesis::Tree::dump () const", "Returns a simple text representation of the Tree, showing all nodes, edges and links with their indices."},
    {"std::string ::genesis::Tree::dump_lists () const", "Returns lists of all nodes, edges and links including their indices and connections with each other."},
    {"size_t ::genesis::Tree::edge_count () const", "Returns the number of Edges of the Tree."},
    {"bool ::genesis::Tree::equal (const TreeType & other) const", "Compares the tree to another one using the respective comparision operators for their nodes and edges.\n\nSee static equal() function for more information."},
    {"static bool ::genesis::Tree::equal (const TreeType & lhs, const TreeType & rhs)", "Compares two trees for equality using the respective comparision operators for their nodes and edges.\n\nThis method is mainly a shortcut for the static equal function, where the comparator functional is instanciated using the default comparision operators of the tree's data."},
    {"void ::genesis::Tree::export_content (LinkArray & links, NodeArray & nodes, EdgeArray & edges)", "Exports all elements of a tree.\n\nCaveat: Only the pointers to the tree elements are copied, not the elements themselves. Thus, this function is not intended for creating a deep copy. It merely is a fast way to pass pointers to tree elements."},
    {"NodeType * ::genesis::Tree::find_node (std::string name) const", "Find a Node, given its name."},
    {"double ::genesis::Tree::height () const", "Returns the height of the tree (longest distance from root to a leaf)."},
    {"bool ::genesis::Tree::identical_topology (const TreeType & other) const", "Returns true iff both trees have an identical topology.\n\nSee static identical_topology() method for more information."},
    {"static bool ::genesis::Tree::identical_topology (const TreeType & lhs, const TreeType & rhs)", "Returns true iff both trees have an identical topology.\n\nThe topology is considered identical only if the order of edges is also the same in both trees. This means, although two trees might have the same number of leaves and branches, they might still be not identical (with respect to this function) when the branches appear in a different order or when the root sits at a different node.Thus, this function is mainly intended to check whether two trees have been produced from the same input, for example from the same Newick file."},
    {"void ::genesis::Tree::import_content (LinkArray & links, NodeArray & nodes, EdgeArray & edges)", "Imports all elements of a tree.\n\nThis function overwrites the topology and data of this tree with a given set of links, nodes and edges. Use with care! No checks are done concerning the validity of the passed input.Caveat: Only the pointers to the tree elements are copied, not the elements themselves. Thus, this function is not intended for creating a deep copy. It merely is a fast way to pass pointers to tree elements.Therefore, the main usage of this function is to get a tree from different TreeProcessor objects for reading trees from files."},
    {"size_t ::genesis::Tree::inner_count () const", "Count the number of inner nodes."},
    {"bool ::genesis::Tree::is_bifurcating () const", "Returns whether the Tree is bifurcating."},
    {"size_t ::genesis::Tree::leaf_count () const", "Count the number of leaf nodes."},
    {"double ::genesis::Tree::length () const", "Returns the length of the tree (sum of all branch lengths)."},
    {"size_t ::genesis::Tree::link_count () const", "Returns the number of Links of the Tree."},
    {"int ::genesis::Tree::max_rank () const", "Returns the highest rank of the nodes of the Tree."},
    {"size_t ::genesis::Tree::node_count () const", "Returns the number of Nodes of the Tree."},
    {"Matrix< int > * ::genesis::Tree::node_depth_matrix () const", "The vector is indexed using the node()->index() for every node."},
    {"std::vector< int > ::genesis::Tree::node_depth_vector (const NodeType * node=nullptr) const", "Returns a vector containing the depth of all nodes with respect to the given start node.\n\nThe vector is indexed using the node()->index() for every node. Its elements give the depth of each node with respect to the given start node. The depth is the number of edges visited on the path between two nodes (0 for itself, 1 for immediate neighbours, etc).If no start node pointer is provided, the root is taken as node."},
    {"Matrix< double > * ::genesis::Tree::node_distance_matrix () const", "Returns a distance matrix containing pairwise distances between all Nodes, using the branch_length of the Edges as distance measurement.\n\nThe elements of the matrix are indexed using node()->index()."},
    {"std::vector< double > ::genesis::Tree::node_distance_vector (const NodeType * node=nullptr) const", "Returns a vector containing the distance of all nodes with respect to the given start node.\n\nThe vector is indexed using the node()->index() for every node. Its elements give the distance of each node with respect to the given start node. The distance is the sum of branch lengths of the edges visited on the path between the two nodes.If no Node pointer is provided, the root is taken as node."},
    {"void ::genesis::Tree::swap (TreeType & other)", "Swap."},
    {"std::string ::genesis::TreeEdge::dump () const", "Returns a one-line dump summary of the data of this edge."},
    {"size_t ::genesis::TreeEdge::index () const", "Returns the index of this Link."},
    {"LinkType * ::genesis::TreeEdge::primary_link () const", "Returns the link of this edge that points towards the root."},
    {"NodeType * ::genesis::TreeEdge::primary_node () const", "Returns the node of this edge that points towards the root."},
    {"LinkType * ::genesis::TreeEdge::secondary_link () const", "Returns the link of this edge that points away from the root."},
    {"NodeType * ::genesis::TreeEdge::secondary_node () const", "Returns the node of this edge that points away from the root."},
    {"std::string ::genesis::TreeLink::dump () const", "Returns a string containing dump information about this link.\n\nAt the moment, a link does not contain any information, so an empty string is returned. This might change in the future, in case links also contain data."},
    {"EdgeType * ::genesis::TreeLink::edge () const", "Returns a pointer to the TreeEdge containing the data of this link's edge."},
    {"size_t ::genesis::TreeLink::index () const", "Returns the index of this Link."},
    {"bool ::genesis::TreeLink::is_inner () const", "Returns true iff the node of this link is an inner node."},
    {"bool ::genesis::TreeLink::is_leaf () const", "Returns true iff the node of this link is a leaf node."},
    {"LinkType * ::genesis::TreeLink::next () const", "Returns a pointer to the next link within the node."},
    {"NodeType * ::genesis::TreeLink::node () const", "Returns a pointer to the TreeNode containing the data of this link's node."},
    {"LinkType * ::genesis::TreeLink::outer () const", "Returns a pointer to the link of the adjacent node."},
    {"LinkType * ::genesis::TreeLink::prev ()", "Returns a pointer to the previous link within the node.\n\nThe previous link of a given link L is the one whose next-pointer is pointing to L. As this link first has to be found, this function is not as cheap as next()."},
    {"std::string ::genesis::TreeNode::dump () const", "Returns a one-line dump summary of the data of this node."},
    {"size_t ::genesis::TreeNode::index () const", "Returns the index of this link."},
    {"bool ::genesis::TreeNode::is_inner () const", "True iff the node is an inner node."},
    {"bool ::genesis::TreeNode::is_leaf () const", "True iff the node is a leaf/tip."},
    {"LinkType * ::genesis::TreeNode::link () const", "Returns the link of this node that points towards the root.\n\nThis is just an alias for primary_link(), that is shorter to use when needed frequently in an algorithm."},
    {"LinkType * ::genesis::TreeNode::primary_link () const", "Returns the link of this node that points towards the root."},
    {"int ::genesis::TreeNode::rank () const", "Rank of the node, i.e. how many immediate children it has."},
    {"void ::genesis::TreeSet::add (const std::string & name, std::shared_ptr< TreeType > tree)", "Adds a Tree to the TreeSet."},
    {"bool ::genesis::TreeSet::all_equal (const std::function< bool(typename TreeType::ConstIteratorPreorder &, typename TreeType::ConstIteratorPreorder &)> comparator) const", "Compares whether all Trees in the set are equal using a given comparator functional.\n\nSee Tree::equal() for more information."},
    {"bool ::genesis::TreeSet::all_equal () const", "Compares whether all Trees in the set are equal using their default comparision operators for nodes and edges."},
    {"bool ::genesis::TreeSet::all_identical_topology () const", "Returns true iff all Trees in the set have an identical topology."},
    {"TreeType ::genesis::TreeSet::average_branch_length_tree () const", "Returns a Tree where the branch lengths are the average of the trees in the set, given that they all have the same topology.\n\nThe method works only under the following conditions: * All trees must have the same topology.\n* The TreeType must provide field `branch_length` for the edges.\nOtherwise, the method will return an empty tree. It does not check for node names, but the returned tree will contain the names of the first tree in the set."},
    {"void ::genesis::TreeSet::clear ()", "Clears the TreeSet and destroys all contained Trees."},
    {"std::string ::genesis::TreeSet::dump (bool full=false) const", "Dump a list of all names of the Trees in the set. If provided with the optional parameter full, also dump all Trees."},
    {"bool ::genesis::TreeSet::empty () const", "Returns whether the tree set is empty."},
    {"TreeType * ::genesis::TreeSet::get_first (const std::string & name) const", "Get the first Tree in the set that is stored with a given name."},
    {"size_t ::genesis::TreeSet::size () const", "Returns the size of the tree set."},
    {"bool ::genesis::XmlProcessor::to_file (const std::string & fn, const XmlDocument & document)", "Writes an XML file from an XmlDocument. Returns true iff successful."},
    {"void ::genesis::XmlProcessor::to_string (std::string & xml, const XmlDocument & document)", "Gives the XML string representation of a XmlDocument."},
    {"std::string ::genesis::XmlProcessor::to_string (const XmlDocument & document)", "Returns the XML representation of a XmlDocument."},
    {"void ::genesis::PlacementSimulatorTwostep::EdgeDistribution::set_depths_distributed_weights (const std::vector< int > & depth_weights)", "Set the weights so that they follow a given depth distribution of the edges in the PlacementTree.\n\nThe depth_weights vector provides weights for each level of depth for an edge in the tree. This means, each edge which is adjacent to a leaf node (speak: it has depth 0) will use the weight at position 0; edges which are one level deeper in the tree will get the weight at position 1, and so on.This method can conveniently be used with the output of PlacementMap::closest_leaf_depth_histogram() called on some other PlacementMap (or the same, for that matter). This way, it will mimic this map in terms of the depths distribution of the placements: E.g., if the original map (the one where the histrogram results were taken from and used as input for this method) has many placements near the leaves, so will the simulated one."},
    {"void ::genesis::PlacementSimulatorTwostep::EdgeDistribution::set_random_subtree_weights ()", "Sets the weights of a randomly chosen subtree to 1.0, all others to 0.0."},
    {"void ::genesis::PlacementSimulatorTwostep::EdgeDistribution::set_random_weights ()", "Set the weights randomly to 0.0 and 1.0."},
    {"void ::genesis::PlacementSimulatorTwostep::EdgeDistribution::set_uniform_weights ()", "Sets the weights to a uniform distribution for all edges."},
    {"bool ::genesis::PlacementSimulatorTwostep::EdgeDistribution::transfer_weights (const PlacementMap & from_map)", "Sets the weights so that they follow the same distribution of placements per edge as a given PlacementMap.\n\nThis method \"learns\" how the placements on the given map are distributed by counting them and using those counts as weights. This way, the given distribution can be imitated by randomly generated placements.The method is intended to be used on a Tree that has the same topology as the one that is given with the PlacementMap, otherwise the Edge indices will not fit. It does not need to be the same PlacementMap or Tree  usually, an empty copy is used.\n\nmap\n\n\nUse the counts of placements of this map to set the weights.\n\n\nReturns true iff the map has the same topology as the one used for simulation. If false, no weights were set."},
};

const char* get_docstring (const std::string& signature)
{
    if (doc_strings_.count(signature) > 0) {
        return doc_strings_[signature].c_str();
    } else {
        return "";
    }
}
